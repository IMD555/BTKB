Disassembly Listing for BTKB
Generated From:
C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/dist/XC8_18F67K40/production/BTKB.X.production.elf
Apr 17, 2018 11:11:37 AM

---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/user.c  -------------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #include <xc.h>         /* XC8 General Include File */
6:             
7:             #include <stdint.h>         /* For uint8_t definition */
8:             #include <stdbool.h>        /* For true/false definition */
9:             //#include <stdlib.h>
10:            //#include <stdio.h>
11:            
12:            #include "system.h"
13:            #include "user.h"
14:            #include "sw.h"
15:            #include "adcc.h"
16:            #include "eusart2.h"
17:            #include "eusart5.h"
18:            #include "main.h"
19:            #include "RN42.h"
20:            
21:            #define	SW1LONG	2000
22:            //M1,M2,M3,FnL,FnR,Ctrl,Alt,Win,ShiftL,ShiftR,CursorL,CursorR
23:            static const unsigned char ledAnodeTable[LEDNUM] = {8, 1, 4, 8, 2, 2, 2, 1, 4, 4, 1, 8};
24:            static const unsigned char ledCathodeTable[LEDNUM] = {1, 8, 8, 2, 4, 1, 8, 2, 2, 1, 4, 4};
25:            
26:            
27:            /******************************************************************************/
28:            /* User Functions                                                             */
29:            /******************************************************************************/
30:            
31:            /* <Initialize variables in user.h and insert code for user algorithms.> */
32:            unsigned char led[LEDNUM];
33:            
34:            void ledMatrixProcess(void)
35:            {
36:            	//call this function from interval timer interrupt
37:            	static unsigned char c = 0;
38:            
39:            	c++;
113B4  2A16     INCF c, F, ACCESS
40:            	if (c == LEDNUM)
113B6  0E0C     MOVLW 0xC
113B8  1816     XORWF c, W, ACCESS
113BA  A4D8     BTFSS STATUS, 2, ACCESS
113BC  D002     BRA 0x13C2
41:            	{
42:            		c = 0;
113BE  0E00     MOVLW 0x0
113C0  6E16     MOVWF c, ACCESS
43:            	}
44:            
45:            	LATE &= 0xf0;
113C2  0EF0     MOVLW 0xF0
113C4  167D     ANDWF LATE, F, ACCESS
46:            	TRISE = (TRISE & 0xf0) | (~(ledAnodeTable[c] | ledCathodeTable[c]) & 0x0f);
113C6  5016     MOVF c, W, ACCESS
113C8  0D01     MULLW 0x1
113CA  0E4B     MOVLW 0x4B
113CC  24F3     ADDWF PROD, W, ACCESS
113CE  6EF6     MOVWF TBLPTR, ACCESS
113D0  0EFB     MOVLW 0xFB
113D2  20F4     ADDWFC PRODH, W, ACCESS
113D4  6EF7     MOVWF TBLPTRH, ACCESS
113D6  6AF8     CLRF TBLPTRU, ACCESS
113D8  0E00     MOVLW 0x0
113DA  22F8     ADDWFC TBLPTRU, F, ACCESS
113DC  0008     TBLRD*
113DE  CFF5     MOVFF TABLAT, __pcstackCOMRAM
113E0  F027     NOP
113E2  5016     MOVF c, W, ACCESS
113E4  0D01     MULLW 0x1
113E6  0E57     MOVLW 0x57
113E8  24F3     ADDWF PROD, W, ACCESS
113EA  6EF6     MOVWF TBLPTR, ACCESS
113EC  0EFB     MOVLW 0xFB
113EE  20F4     ADDWFC PRODH, W, ACCESS
113F0  6EF7     MOVWF TBLPTRH, ACCESS
113F2  6AF8     CLRF TBLPTRU, ACCESS
113F4  0E00     MOVLW 0x0
113F6  22F8     ADDWFC TBLPTRU, F, ACCESS
113F8  0008     TBLRD*
113FA  50F5     MOVF TABLAT, W, ACCESS
113FC  1027     IORWF __pcstackCOMRAM, W, ACCESS
113FE  0AFF     XORLW 0xFF
11400  6E28     MOVWF 0x28, ACCESS
11402  0E0F     MOVLW 0xF
11404  1628     ANDWF 0x28, F, ACCESS
11406  5085     MOVF TRISE, W, ACCESS
11408  0BF0     ANDLW 0xF0
1140A  1028     IORWF 0x28, W, ACCESS
1140C  6E85     MOVWF TRISE, ACCESS
47:            	if (led[c])
1140E  5016     MOVF c, W, ACCESS
11410  0D01     MULLW 0x1
11412  0E6C     MOVLW 0x6C
11414  24F3     ADDWF PROD, W, ACCESS
11416  6ED9     MOVWF FSR2, ACCESS
11418  0E00     MOVLW 0x0
1141A  20F4     ADDWFC PRODH, W, ACCESS
1141C  6EDA     MOVWF FSR2H, ACCESS
1141E  50DF     MOVF INDF2, W, ACCESS
11420  B4D8     BTFSC STATUS, 2, ACCESS
11422  0012     RETURN 0
48:            	{
49:            		LATE |= ledAnodeTable[c] & 0x0f;
11424  5016     MOVF c, W, ACCESS
11426  0D01     MULLW 0x1
11428  0E57     MOVLW 0x57
1142A  24F3     ADDWF PROD, W, ACCESS
1142C  6EF6     MOVWF TBLPTR, ACCESS
1142E  0EFB     MOVLW 0xFB
11430  20F4     ADDWFC PRODH, W, ACCESS
11432  6EF7     MOVWF TBLPTRH, ACCESS
11434  6AF8     CLRF TBLPTRU, ACCESS
11436  0E00     MOVLW 0x0
11438  22F8     ADDWFC TBLPTRU, F, ACCESS
1143A  0008     TBLRD*
1143C  50F5     MOVF TABLAT, W, ACCESS
1143E  0B0F     ANDLW 0xF
11440  127D     IORWF LATE, F, ACCESS
11442  0012     RETURN 0
50:            	}
51:            }
52:            
53:            void sw1Process(void)
54:            {
55:            	//call this function from interval timer interrupt
56:            	static unsigned char sw1Count = 0;
57:            	static unsigned char sw1State = 0;
58:            	static unsigned short sw1Count2 = 0;
59:            	if (sw1State != SW1)
11906  BC8C     BTFSC PORTD, 6, ACCESS
11908  D002     BRA 0x190E
1190A  0E01     MOVLW 0x1
1190C  D001     BRA 0x1910
1190E  0E00     MOVLW 0x0
11910  1814     XORWF sw1State, W, ACCESS
11912  B4D8     BTFSC STATUS, 2, ACCESS
11914  D017     BRA 0x1944
60:            	{
61:            		if (++sw1Count == 10)
11916  2A15     INCF sw1Count, F, ACCESS
11918  0E0A     MOVLW 0xA
1191A  1815     XORWF sw1Count, W, ACCESS
1191C  A4D8     BTFSS STATUS, 2, ACCESS
1191E  D014     BRA 0x1948
62:            		{
63:            			sw1State = !sw1State;
11920  5014     MOVF sw1State, W, ACCESS
11922  A4D8     BTFSS STATUS, 2, ACCESS
11924  D002     BRA 0x192A
11926  0E01     MOVLW 0x1
11928  D001     BRA 0x192C
1192A  0E00     MOVLW 0x0
1192C  6E14     MOVWF sw1State, ACCESS
64:            			if (!sw1State)
1192E  5014     MOVF sw1State, W, ACCESS
11930  A4D8     BTFSS STATUS, 2, ACCESS
11932  D00A     BRA 0x1948
65:            			{
66:            				if (sw1Count2 < SW1LONG)
11934  0ED0     MOVLW 0xD0
11936  5C09     SUBWF sw1Count2, W, ACCESS
11938  0E07     MOVLW 0x7
1193A  580A     SUBWFB 0xA, W, ACCESS
1193C  B0D8     BTFSC STATUS, 0, ACCESS
1193E  D004     BRA 0x1948
67:            				{
68:            					mainFlags.sw1Pushed = 1;
11940  8011     BSF mainFlags, 0, ACCESS
69:            				}
70:            			}
71:            		}
72:            	}
11942  D002     BRA 0x1948
73:            	else
74:            	{
75:            		sw1Count = 0;
11944  0E00     MOVLW 0x0
11946  6E15     MOVWF sw1Count, ACCESS
76:            	}
77:            	if (sw1State)
11948  5014     MOVF sw1State, W, ACCESS
1194A  B4D8     BTFSC STATUS, 2, ACCESS
1194C  D010     BRA 0x196E
78:            	{
79:            		if (sw1Count2 == SW1LONG)
1194E  0ED0     MOVLW 0xD0
11950  1809     XORWF sw1Count2, W, ACCESS
11952  E10A     BNZ 0x1968
11954  0E07     MOVLW 0x7
11956  180A     XORWF 0xA, W, ACCESS
11958  A4D8     BTFSS STATUS, 2, ACCESS
1195A  D006     BRA 0x1968
80:            		{
81:            			mainFlags.sw1LongPushing = 1;
1195C  8211     BSF mainFlags, 1, ACCESS
82:            			sw1Count2 = SW1LONG + 1;
1195E  0E07     MOVLW 0x7
11960  6E0A     MOVWF 0xA, ACCESS
11962  0ED1     MOVLW 0xD1
11964  6E09     MOVWF sw1Count2, ACCESS
83:            		}
11966  0012     RETURN 0
84:            		else
85:            		{
86:            			sw1Count2++;
11968  4A09     INFSNZ sw1Count2, F, ACCESS
1196A  2A0A     INCF 0xA, F, ACCESS
87:            		}
88:            	}
1196C  0012     RETURN 0
89:            	else
90:            	{
91:            		sw1Count2 = 0;
1196E  0E00     MOVLW 0x0
11970  6E0A     MOVWF 0xA, ACCESS
11972  0E00     MOVLW 0x0
11974  6E09     MOVWF sw1Count2, ACCESS
11976  0012     RETURN 0
92:            	}
93:            }
94:            
95:            void PMD_AllOff(void)
96:            {
97:            	PMD0 = 0xff;
11EA6  010E     MOVLB 0xE
11EA8  694C     SETF 0x4C, BANKED
98:            	PMD1 = 0xff;
11EAA  694D     SETF 0x4D, BANKED
99:            	PMD2 = 0xff;
11EAC  694E     SETF 0x4E, BANKED
100:           	PMD3 = 0xff;
11EAE  694F     SETF 0x4F, BANKED
101:           	PMD4 = 0xff;
11EB0  6950     SETF 0x50, BANKED
102:           	PMD5 = 0xff;
11EB2  6951     SETF 0x51, BANKED
103:           
104:           	PMD0bits.IOCMD = 0;
11EB4  914C     BCF 0x4C, 0, BANKED
105:           }
0818  8045     BSF btemp, 0, ACCESS
11EB6  0012     RETURN 0
106:           
107:           void PMD_Initialize(void)
108:           {
109:           	// CLKRMD CLKR disabled; SYSCMD SYSCLK enabled; SCANMD SCANNER disabled; FVRMD FVR disabled; IOCMD IOC enabled; CRCMD CRC disabled; HLVDMD HLVD enabled; NVMMD NVM disabled; 
110:           	PMD0 = 0x3e;
11E08  0E3E     MOVLW 0x3E
11E0A  010E     MOVLB 0xE
11E0C  6F4C     MOVWF 0x4C, BANKED
111:           	// TMR0MD TMR0 disabled; TMR1MD TMR1 enabled; TMR4MD TMR4 disabled; TMR5MD TMR5 disabled; TMR2MD TMR2 disabled; TMR3MD TMR3 enabled; TMR6MD TMR6 disabled; TMR7MD TMR7 disabled; 
112:           	PMD1 = 0xf5;
11E0E  0EF5     MOVLW 0xF5
11E10  6F4D     MOVWF 0x4D, BANKED
113:           	// DSMMD DSM disabled; SMU1MD SMT1 disabled; SMU2MD SMT2 disabled; CWG1MD CWG1 disabled; TMR8MD TMR8 disabled; 
114:           	PMD2 = 0xff;
11E12  694E     SETF 0x4E, BANKED
115:           	// ZCDMD ZCD disabled; DACMD DAC disabled; CMP3MD CMP3 disabled; CMP1MD CMP1 disabled; ADCMD ADC enabled; CMP2MD CMP2 disabled; 
116:           	PMD3 = 0xdf;
11E14  0EDF     MOVLW 0xDF
11E16  6F4F     MOVWF 0x4F, BANKED
117:           	// CCP2MD CCP2 disabled; CCP1MD CCP1 disabled; CCP4MD CCP4 disabled; CCP3MD CCP3 disabled; CCP5MD CCP5 disabled; PWM6MD PWM6 disabled; PWM7MD PWM7 disabled; 
118:           	PMD4 = 0xff;
11E18  6950     SETF 0x50, BANKED
119:           	// UART5MD EUSART5 enabled; UART4MD EUSART4 disabled; UART3MD EUSART3 disabled; UART2MD EUSART2 enabled; MSSP1MD MSSP1 disabled; UART1MD EUSART1 disabled; 
120:           	PMD5 = 0xb7;
11E1A  0EB7     MOVLW 0xB7
11E1C  6F51     MOVWF 0x51, BANKED
121:           }
11E1E  0012     RETURN 0
122:           
123:           void StandbyMainBoardIO(void)
124:           {
125:           	//Set to lowest power consumption state!
126:           
127:           	LATD = 0x00; //(UI Board),SW1,SW2,LED1
11894  0E00     MOVLW 0x0
11896  6E7C     MOVWF LATD, ACCESS
128:           	LATA = 0x00; //Bat_Check_EN,BT_Reset
11898  0E00     MOVLW 0x0
1189A  6E79     MOVWF LATA, ACCESS
129:           	LATF = 0x05; //BT_RTS,BT_GPIO5,USB_RTS,USB_CBUS0,1,3,Chg_State,Chg_500mA,
1189C  0E05     MOVLW 0x5
1189E  6E7E     MOVWF LATF, ACCESS
130:           	LATG = 0x02; //BT_TX,RX,USB_TX,RX
118A0  0E02     MOVLW 0x2
118A2  6E7F     MOVWF LATG, ACCESS
131:           	LATH = 0x00; //Bat_Volt
118A4  0E00     MOVLW 0x0
118A6  6E80     MOVWF LATH, ACCESS
132:           
133:           	TRISD = 0x43;
118A8  0E43     MOVLW 0x43
118AA  6E84     MOVWF TRISD, ACCESS
134:           	TRISA = 0x01;
118AC  0E01     MOVLW 0x1
118AE  6E81     MOVWF TRISA, ACCESS
135:           	TRISF = 0xee;
118B0  0EEE     MOVLW 0xEE
118B2  6E86     MOVWF TRISF, ACCESS
136:           	TRISG = 0x05;
118B4  0E05     MOVLW 0x5
118B6  6E87     MOVWF TRISG, ACCESS
137:           	TRISH = 0x00;
118B8  0E00     MOVLW 0x0
118BA  6E88     MOVWF TRISH, ACCESS
138:           
139:           	ANSELD = 0xbf;
118BC  0EBF     MOVLW 0xBF
118BE  010E     MOVLB 0xE
118C0  6FA7     MOVWF 0xA7, BANKED
140:           	ANSELA = 0xff;
118C2  6992     SETF 0x92, BANKED
141:           	ANSELF = 0xff;
118C4  69B4     SETF bufU2_intH, BANKED
142:           	ANSELG = 0xff;
118C6  69BC     SETF sameRow, BANKED
143:           
144:           	WPUD = 0x40;
118C8  0E40     MOVLW 0x40
118CA  6FA6     MOVWF 0xA6, BANKED
145:           	WPUA = 0x00;
118CC  0E00     MOVLW 0x0
118CE  6F91     MOVWF 0x91, BANKED
146:           	WPUF = 0x00;
118D0  0E00     MOVLW 0x0
118D2  6FB3     MOVWF 0xB3, BANKED
147:           	WPUG = 0x20;
118D4  0E20     MOVLW 0x20
118D6  6FBB     MOVWF sameCol, BANKED
148:           	WPUH = 0x00;
118D8  0E00     MOVLW 0x0
118DA  6FC0     MOVWF ttt, BANKED
149:           
150:           	INLVLD = 0xff;
118DC  69A3     SETF 0xA3, BANKED
151:           	INLVLA = 0xff;
118DE  698E     SETF 0x8E, BANKED
152:           	INLVLF = 0xff;
118E0  69B0     SETF 0xB0, BANKED
153:           	INLVLG = 0xff;
118E2  69B8     SETF 0xB8, BANKED
154:           	INLVLH = 0xff;
118E4  69BD     SETF n, BANKED
155:           
156:           	SLRCOND = 0xff;
118E6  69A4     SETF 0xA4, BANKED
157:           	SLRCONA = 0xff;
118E8  698F     SETF 0x8F, BANKED
158:           	SLRCONF = 0xff;
118EA  69B1     SETF 0xB1, BANKED
159:           	SLRCONG = 0xff;
118EC  69B9     SETF __pcstackBANK0, BANKED
160:           	SLRCONH = 0xff;
118EE  69BE     SETF d, BANKED
161:           
162:           	ODCOND = 0x00;
118F0  0E00     MOVLW 0x0
118F2  6FA5     MOVWF 0xA5, BANKED
163:           	ODCONA = 0x00;
118F4  0E00     MOVLW 0x0
118F6  6F90     MOVWF 0x90, BANKED
164:           	ODCONF = 0x01;
118F8  0E01     MOVLW 0x1
118FA  6FB2     MOVWF 0xB2, BANKED
165:           	ODCONG = 0x00;
118FC  0E00     MOVLW 0x0
118FE  6FBA     MOVWF 0xBA, BANKED
166:           	ODCONH = 0x00;
11900  0E00     MOVLW 0x0
11902  6FBF     MOVWF n, BANKED
167:           }
11904  0012     RETURN 0
168:           
169:           void InitMainBoardIO(void)
170:           {
171:           	ANSELD = 0x00;
11E7E  0E00     MOVLW 0x0
11E80  010E     MOVLB 0xE
11E82  6FA7     MOVWF 0xA7, BANKED
172:           	ANSELA = 0x01;
11E84  0E01     MOVLW 0x1
11E86  6F92     MOVWF 0x92, BANKED
173:           	ANSELF = 0x00;
11E88  0E00     MOVLW 0x0
11E8A  6FB4     MOVWF bufU2_intH, BANKED
174:           	ANSELG = 0x00;
11E8C  0E00     MOVLW 0x0
11E8E  6FBC     MOVWF sameRow, BANKED
175:           }
11E90  0012     RETURN 0
176:           
177:           void waitBootTrigger(void)
178:           {
179:           	INT2PPSbits.INT2PPS = 0x1e;
11B02  010D     MOVLB 0xD
11B04  91F2     BCF aaa, 0, BANKED
11B06  83F2     BSF aaa, 1, BANKED
11B08  85F2     BSF aaa, 2, BANKED
11B0A  87F2     BSF aaa, 3, BANKED
11B0C  89F2     BSF aaa, 4, BANKED
11B0E  9BF2     BCF aaa, 5, BANKED
180:           
181:           	INTCONbits.GIE = 0;
11B10  9EF2     BCF INTCON, 7, ACCESS
182:           	INTCONbits.INT2EDG = 0;
11B12  94F2     BCF INTCON, 2, ACCESS
183:           	IPR0bits.INT2IP = 1;
11B14  010E     MOVLB 0xE
11B16  851F     BSF 0x1F, 2, BANKED
184:           	PIR0bits.INT2IF = 0;
11B18  9533     BCF 0x33, 2, BANKED
185:           	PIE0bits.INT2IE = 1;
11B1A  8529     BSF multiplicand, 2, BANKED
186:           
187:           	IOCBF = 0x00;
11B1C  0E00     MOVLW 0x0
11B1E  6F93     MOVWF 0x93, BANKED
188:           	IOCEF = 0x00;
11B20  0E00     MOVLW 0x0
11B22  6FA8     MOVWF 0xA8, BANKED
189:           
190:           	IOCBN = 0xff;
11B24  6994     SETF 0x94, BANKED
191:           	IOCEN = 0xf0;
11B26  0EF0     MOVLW 0xF0
11B28  6FA9     MOVWF 0xA9, BANKED
192:           
193:           	PIE0bits.IOCIE = 1;
11B2A  8929     BSF multiplicand, 4, BANKED
194:           	IPR0bits.IOCIP = 1;
11B2C  891F     BSF 0x1F, 4, BANKED
195:           
196:           	do
197:           	{
198:           		LED1 = 0;
11B2E  9E8C     BCF PORTD, 7, ACCESS
199:           		PMD0bits.HLVDMD = 1;
11B30  8B4C     BSF 0x4C, 5, BANKED
200:           		Sleep(); //Wait for SW1 Push
11B32  0003     SLEEP
201:           		Nop();
11B34  F000     NOP
202:           		LED1 = 1;
11B36  8E8C     BSF PORTD, 7, ACCESS
203:           		PMD0bits.HLVDMD = 0;
11B38  010E     MOVLB 0xE
11B3A  9B4C     BCF 0x4C, 5, BANKED
204:           		HLVDCON0 = 0x01;
11B3C  0E01     MOVLW 0x1
11B3E  6FC2     MOVWF 0xC2, BANKED
205:           		HLVDCON1 = 0x07;
11B40  0E07     MOVLW 0x7
11B42  6FC3     MOVWF n, BANKED
206:           		HLVDCON0bits.EN = 1;
11B44  8FC2     BSF 0xC2, 7, BANKED
207:           
208:           		while (!HLVDCON0bits.HLVDRDY)
11B46  A9C2     BTFSS 0xC2, 4, BANKED
11B48  D7FE     BRA 0x1B46
209:           		{
210:           		}
211:           	}
212:           	while (HLVDCON0bits.OUT);
11B4A  BBC2     BTFSC 0xC2, 5, BANKED
11B4C  D7F0     BRA 0x1B2E
213:           	PIE0bits.INT2IE = 0;
11B4E  9529     BCF multiplicand, 2, BANKED
214:           	PIE0bits.IOCIE = 0;
11B50  9929     BCF multiplicand, 4, BANKED
215:           	LED1 = 0;
11B52  9E8C     BCF PORTD, 7, ACCESS
216:           }
11B54  0012     RETURN 0
217:           
218:           void InitApp(void)
219:           {
220:           	NVMCON1bits.NVMREG = 2;
11E68  5077     MOVF NVMCON1, W, ACCESS
11E6A  0B3F     ANDLW 0x3F
11E6C  0980     IORLW 0x80
11E6E  6E77     MOVWF NVMCON1, ACCESS
221:           	//Power down state
222:           	StandbyMainBoardIO();
11E70  EC4A     CALL 0x11894, 0
11E72  F08C     NOP
223:           	StandbyUiBoardIO();
11E74  EC35     CALL 0x11C6A, 0
11E76  F08E     NOP
224:           	PMD_AllOff();
11E78  EC53     CALL 0x11EA6, 0
11E7A  F08F     NOP
225:           }
11E7C  0012     RETURN 0
226:           
227:           void InitApp2(void){
228:           	//Start 
229:           	PMD_Initialize();
117AC  EC04     CALL 0x11E08, 0
117AE  F08F     NOP
230:           	ConfigureOscillator();
117B0  EC28     CALL 0x11E50, 0
117B2  F08F     NOP
231:           	InitMainBoardIO();
117B4  EC3F     CALL 0x11E7E, 0
117B6  F08F     NOP
232:           	InitUiBoardIO();
117B8  ECA8     CALL 0x11550, 0
117BA  F08A     NOP
233:           
234:           	RG1PPS = 0x0E; //RG1->EUSART2:TX2;
117BC  0E0E     MOVLW 0xE
117BE  010E     MOVLB 0xE
117C0  6F83     MOVWF BtGPIO5LowCount, BANKED
235:           	RX2PPSbits.RX2PPS = 0x30; //RG0->EUSART2:RX2;
117C2  9111     BCF mainFlags, 0, BANKED
117C4  9311     BCF mainFlags, 1, BANKED
117C6  9511     BCF mainFlags, 2, BANKED
117C8  9711     BCF mainFlags, 3, BANKED
117CA  8911     BSF mainFlags, 4, BANKED
117CC  8B11     BSF mainFlags, 5, BANKED
236:           	RG3PPS = 0x14; //RG3->EUSART5:TX5;
117CE  0E14     MOVLW 0x14
117D0  6F85     MOVWF consumerKey, BANKED
237:           	RX5PPSbits.RX5PPS = 0x32; //RG2->EUSART5:RX5;
117D2  9117     BCF connectedStringIndex, 0, BANKED
117D4  8317     BSF connectedStringIndex, 1, BANKED
117D6  9517     BCF connectedStringIndex, 2, BANKED
117D8  9717     BCF connectedStringIndex, 3, BANKED
117DA  8917     BSF connectedStringIndex, 4, BANKED
117DC  8B17     BSF connectedStringIndex, 5, BANKED
238:           
239:           	/* Setup analog functionality and port direction */
240:           
241:           	/* Initialize peripherals */
242:           	TMR1CLK = 0x05; //MFINTOSC 500kHz
117DE  0E05     MOVLW 0x5
117E0  6ED2     MOVWF T1CLK, ACCESS
243:           	T1CON = 0x01;
117E2  0E01     MOVLW 0x1
117E4  6ECF     MOVWF T1CON, ACCESS
244:           
245:           	TMR3CLK = 0x05; //MFINTOSC 500kHz
117E6  0E05     MOVLW 0x5
117E8  6ECC     MOVWF T3CLK, ACCESS
246:           	T3CON = 0x01;
117EA  0E01     MOVLW 0x1
117EC  6EC9     MOVWF T3CON, ACCESS
247:           
248:           	FVRCON = 0x82;
117EE  0E82     MOVLW 0x82
117F0  6FC4     MOVWF 0xC4, BANKED
249:           	ADCC_Initialize();
117F2  ECAB     CALL 0x11B56, 0
117F4  F08D     NOP
250:           
251:           	EUSART5_Initialize();
117F6  EC10     CALL 0x11E20, 0
117F8  F08F     NOP
252:           	EUSART2_Initialize();
117FA  EC1C     CALL 0x11E38, 0
117FC  F08F     NOP
253:           
254:           
255:           	/* Set the IPEN bit to turn on INT priorities */
256:           	INTCONbits.IPEN = 1;
117FE  8AF2     BSF INTCON, 5, ACCESS
257:           
258:           	/* Enable interrupts */
259:           	IPR3bits.RC2IP = 1; //BT
11800  010E     MOVLB 0xE
11802  8F22     BSF bufU5_intH, 7, BANKED
260:           	PIE3bits.RC2IE = 1;
11804  8F2C     BSF 0x2C, 7, BANKED
261:           	IPR4bits.RC5IP = 0; //USB
11806  9B23     BCF 0x23, 5, BANKED
262:           	PIE4bits.RC5IE = 1;
11808  8B2D     BSF 0x2D, 5, BANKED
263:           	//	IPR2bits.HLVDIP = 0; //Low Battery
264:           	//	PIE2bits.HLVDIE = 1;
265:           	IPR5bits.TMR1IP = 1; //LED matrix
1180A  8124     BSF 0x24, 0, BANKED
266:           	PIE5bits.TMR1IE = 1;
1180C  812E     BSF 0x2E, 0, BANKED
267:           	IPR5bits.TMR3IP = 0; //SW matrix...
1180E  9524     BCF 0x24, 2, BANKED
268:           	PIE5bits.TMR3IE = 1;
11810  852E     BSF 0x2E, 2, BANKED
269:           	INTCONbits.PEIE = 1;
11812  8CF2     BSF INTCON, 6, ACCESS
270:           
271:           	SendCharUSB(0xff);
11814  0EFF     MOVLW 0xFF
11816  ECF5     CALL 0x11DEA, 0
11818  F08E     NOP
272:           
273:           	BT_Reset(0);
1181A  8879     BSF LATA, 4, ACCESS
274:           	BT_SetReady(1);
1181C  8486     BSF TRISF, 2, ACCESS
275:           }
1181E  0012     RETURN 0
276:           
277:           unsigned char GetSW2(void)
278:           {
279:           	unsigned char ret;
280:           
281:           	TRISD |= 0x3c;
282:           	WPUD |= 0x3c;
283:           	Nop();
284:           	ret = (PORTD >> 2) & 0x0f;
285:           	WPUD &= 0xc3;
286:           	LATD &= 0xc3;
287:           	TRISD &= 0xc3;
288:           
289:           	return ret;
290:           }
291:           
292:           unsigned char GetChgState(void)
293:           {
294:           	unsigned char ret;
295:           
296:           	TRISF3 = 1;
297:           	WPUF3 = 1;
298:           	Nop();
299:           	ret = RF3;
300:           	WPUF3 = 0;
301:           	LATF3 = 0;
302:           	TRISF3 = 0;
303:           
304:           	return ret;
305:           }
306:           
307:           void waitMs(unsigned long t)
308:           {
309:           	time = 0;
11BA0  0E00     MOVLW 0x0
11BA2  0100     MOVLB 0x0
11BA4  6F7F     MOVWF time, BANKED
11BA6  0E00     MOVLW 0x0
11BA8  6F80     MOVWF 0x80, BANKED
11BAA  0E00     MOVLW 0x0
11BAC  6F81     MOVWF 0x81, BANKED
11BAE  0E00     MOVLW 0x0
11BB0  6F82     MOVWF 0x82, BANKED
310:           	while ((time / 2) < t);
11BB2  C07F     MOVFF time, multiplicand
11BB4  F1D6     NOP
11BB6  C080     MOVFF 0x80, d
11BB8  F1D7     NOP
11BBA  C081     MOVFF 0x81, d
11BBC  F1D8     NOP
11BBE  C082     MOVFF 0x82, 0x1D9
11BC0  F1D9     NOP
11BC2  0101     MOVLB 0x1
11BC4  90D8     BCF STATUS, 0, ACCESS
11BC6  33D9     RRCF 0xD9, F, BANKED
11BC8  33D8     RRCF 0xD8, F, BANKED
11BCA  33D7     RRCF 0xD7, F, BANKED
11BCC  33D6     RRCF 0xD6, F, BANKED
11BCE  51D2     MOVF 0xD2, W, BANKED
11BD0  5DD6     SUBWF 0xD6, W, BANKED
11BD2  51D3     MOVF 0xD3, W, BANKED
11BD4  59D7     SUBWFB 0xD7, W, BANKED
11BD6  51D4     MOVF 0xD4, W, BANKED
11BD8  59D8     SUBWFB 0xD8, W, BANKED
11BDA  51D5     MOVF 0xD5, W, BANKED
11BDC  59D9     SUBWFB 0xD9, W, BANKED
11BDE  B0D8     BTFSC STATUS, 0, ACCESS
11BE0  0012     RETURN 0
11BE2  D7E7     BRA 0x1BB2
311:           }
312:           
313:           void showBatteryState(void)
314:           {
315:           	unsigned short v = GetFuel();
114CC  EC9C     CALL 0x11738, 0
114CE  F08B     NOP
114D0  C1D8     MOVFF d, t
114D2  F1E0     NOP
114D4  C1D9     MOVFF 0x1D9, 0x1E1
114D6  F1E1     NOP
316:           
317:           	//	LED1 = 0;
318:           	//	waitMs(500);
319:           	//	if (v > 400)
320:           	//	{
321:           	//		LED1 = 1;
322:           	//		waitMs(100);
323:           	//		LED1 = 0;
324:           	//		waitMs(300);
325:           	//	}
326:           	//	if (v > 370)
327:           	//	{
328:           	//		LED1 = 1;
329:           	//		waitMs(100);
330:           	//		LED1 = 0;
331:           	//		waitMs(300);
332:           	//	}
333:           	//	if (v > 350)
334:           	//	{
335:           	//		LED1 = 1;
336:           	//		waitMs(100);
337:           	//		LED1 = 0;
338:           	//		waitMs(300);
339:           	//	}
340:           	//	if (v > 330)
341:           	//	{
342:           	//		LED1 = 1;
343:           	//		waitMs(100);
344:           	//		LED1 = 0;
345:           	//		waitMs(300);
346:           	//	}
347:           
348:           	led[LED_FNL] = v > 400;
114D8  0E91     MOVLW 0x91
114DA  0101     MOVLB 0x1
114DC  5DE0     SUBWF 0xE0, W, BANKED
114DE  0E01     MOVLW 0x1
114E0  59E1     SUBWFB 0xE1, W, BANKED
114E2  A0D8     BTFSS STATUS, 0, ACCESS
114E4  D002     BRA 0x14EA
114E6  0E01     MOVLW 0x1
114E8  D001     BRA 0x14EC
114EA  0E00     MOVLW 0x0
114EC  0100     MOVLB 0x0
114EE  6F6F     MOVWF 0x6F, BANKED
349:           	led[LED_ALT] = v > 370;
114F0  0E73     MOVLW 0x73
114F2  0101     MOVLB 0x1
114F4  5DE0     SUBWF 0xE0, W, BANKED
114F6  0E01     MOVLW 0x1
114F8  59E1     SUBWFB 0xE1, W, BANKED
114FA  A0D8     BTFSS STATUS, 0, ACCESS
114FC  D002     BRA 0x1502
114FE  0E01     MOVLW 0x1
11500  D001     BRA 0x1504
11502  0E00     MOVLW 0x0
11504  0100     MOVLB 0x0
11506  6F72     MOVWF 0x72, BANKED
350:           	led[LED_GUI] = v > 350;
11508  0E5F     MOVLW 0x5F
1150A  0101     MOVLB 0x1
1150C  5DE0     SUBWF 0xE0, W, BANKED
1150E  0E01     MOVLW 0x1
11510  59E1     SUBWFB 0xE1, W, BANKED
11512  A0D8     BTFSS STATUS, 0, ACCESS
11514  D002     BRA 0x151A
11516  0E01     MOVLW 0x1
11518  D001     BRA 0x151C
1151A  0E00     MOVLW 0x0
1151C  0100     MOVLB 0x0
1151E  6F73     MOVWF 0x73, BANKED
351:           	led[LED_CTL] = v > 330;
11520  0E4B     MOVLW 0x4B
11522  0101     MOVLB 0x1
11524  5DE0     SUBWF 0xE0, W, BANKED
11526  0E01     MOVLW 0x1
11528  59E1     SUBWFB 0xE1, W, BANKED
1152A  A0D8     BTFSS STATUS, 0, ACCESS
1152C  D002     BRA 0x1532
1152E  0E01     MOVLW 0x1
11530  D001     BRA 0x1534
11532  0E00     MOVLW 0x0
11534  0100     MOVLB 0x0
11536  6F71     MOVWF 0x71, BANKED
352:           	waitMs(500);
11538  0EF4     MOVLW 0xF4
1153A  0101     MOVLB 0x1
1153C  6FD2     MOVWF 0xD2, BANKED
1153E  0E01     MOVLW 0x1
11540  6FD3     MOVWF 0xD3, BANKED
11542  0E00     MOVLW 0x0
11544  6FD4     MOVWF 0xD4, BANKED
11546  0E00     MOVLW 0x0
11548  6FD5     MOVWF 0xD5, BANKED
1154A  ECD0     CALL 0x11BA0, 0
1154C  F08D     NOP
353:           }
1154E  0012     RETURN 0
354:           
355:           unsigned short GetFuel(void)
356:           {
357:           	unsigned char c = 0;
11738  0E00     MOVLW 0x0
1173A  0101     MOVLB 0x1
1173C  6FDF     MOVWF 0xDF, BANKED
358:           	unsigned short ret = 0;
1173E  0E00     MOVLW 0x0
11740  6FDE     MOVWF 0xDE, BANKED
11742  0E00     MOVLW 0x0
11744  6FDD     MOVWF 0xDD, BANKED
359:           	BatCheckEn(1);
11746  8A79     BSF LATA, 5, ACCESS
360:           
361:           	for (c = 0; c < 10; c++)
11748  0E00     MOVLW 0x0
1174A  6FDF     MOVWF 0xDF, BANKED
1174C  0E09     MOVLW 0x9
1174E  65DF     CPFSGT 0xDF, BANKED
11750  D001     BRA 0x1754
11752  D014     BRA 0x177C
362:           	{
363:           		unsigned short r = ADCC_GetSingleConversion(0);
11754  0E00     MOVLW 0x0
11756  ECAD     CALL 0x11D5A, 0
11758  F08E     NOP
1175A  C1D2     MOVFF __pcstackBANK1, r
1175C  F1DB     NOP
1175E  C1D3     MOVFF d, c
11760  F1DC     NOP
364:           		if (ret < r)
11762  0101     MOVLB 0x1
11764  51DB     MOVF 0xDB, W, BANKED
11766  5DDD     SUBWF 0xDD, W, BANKED
11768  51DC     MOVF 0xDC, W, BANKED
1176A  59DE     SUBWFB 0xDE, W, BANKED
1176C  B0D8     BTFSC STATUS, 0, ACCESS
1176E  D004     BRA 0x1778
365:           		{
366:           			ret = r;
11770  C1DB     MOVFF r, d
11772  F1DD     NOP
11774  C1DC     MOVFF c, second
11776  F1DE     NOP
367:           		}
11778  2BDF     INCF 0xDF, F, BANKED
1177A  D7E8     BRA 0x174C
368:           	}
369:           
370:           	BatCheckEn(0);
1177C  9A79     BCF LATA, 5, ACCESS
371:           
372:           	return ret * 108 / 128; //110/128
1177E  C1DD     MOVFF d, __pcstackBANK1
11780  F1D2     NOP
11782  C1DE     MOVFF second, d
11784  F1D3     NOP
11786  0E00     MOVLW 0x0
11788  6FD5     MOVWF 0xD5, BANKED
1178A  0E6C     MOVLW 0x6C
1178C  6FD4     MOVWF 0xD4, BANKED
1178E  EC99     CALL 0x11D32, 0
11790  F08E     NOP
11792  0E07     MOVLW 0x7
11794  0101     MOVLB 0x1
11796  6FDA     MOVWF 0xDA, BANKED
11798  90D8     BCF STATUS, 0, ACCESS
1179A  33D3     RRCF 0xD3, F, BANKED
1179C  33D2     RRCF 0xD2, F, BANKED
1179E  2FDA     DECFSZ 0xDA, F, BANKED
117A0  D7FB     BRA 0x1798
117A2  C1D2     MOVFF __pcstackBANK1, d
117A4  F1D8     NOP
117A6  C1D3     MOVFF d, 0x1D9
117A8  F1D9     NOP
117AA  0012     RETURN 0
373:           }
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/system.c  -----------------------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:                 #include <xc.h>         /* XC8 General Include File */
6:             
7:             #include <stdint.h>         /* For uint8_t definition */
8:             #include <stdbool.h>        /* For true/false definition */
9:             
10:            #include "system.h"
11:            
12:            /* Refer to the device datasheet for information about available
13:            oscillator configurations. */
14:            void ConfigureOscillator(void)
15:            {
16:                /* TODO Add clock switching code if appropriate.  */
17:            
18:                /* Typical actions in this function are to tweak the oscillator tuning
19:                register, select new clock sources, and to wait until new clock sources
20:                are stable before resuming execution of the main project. */\
21:            	
22:            	
23:                // NOSC HFINTOSC; NDIV 1; 
24:                OSCCON1 = 0x60;
11E50  0E60     MOVLW 0x60
11E52  010E     MOVLB 0xE
11E54  6F43     MOVWF firstPush, BANKED
25:                // CSWHOLD may proceed; SOSCPWR Low power; 
26:                OSCCON3 = 0x00;
11E56  0E00     MOVLW 0x0
11E58  6F45     MOVWF btemp, BANKED
27:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
28:                OSCEN = 0x00;
11E5A  0E00     MOVLW 0x0
11E5C  6F47     MOVWF 0x47, BANKED
29:                // HFFRQ 16_MHz; 
30:                OSCFRQ = 0x05;
11E5E  0E05     MOVLW 0x5
11E60  6F49     MOVWF 0x49, BANKED
31:                // TUN 0; 
32:                OSCTUNE = 0x00;
11E62  0E00     MOVLW 0x0
11E64  6F48     MOVWF 0x48, BANKED
33:            }
11E66  0012     RETURN 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/sw.c  ---------------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #include <xc.h>         /* XC8 General Include File */
6:             
7:             #include <stdint.h>         /* For uint8_t definition */
8:             #include <stdbool.h>        /* For true/false definition */
9:             
10:            #include "user.h"
11:            #include "sw.h"
12:            #include "RN42.h"
13:            #include "HID_Define.h"
14:            #include "FT230X.h"
15:            #include "main.h"
16:            
17:            #define	ON_COUNT	5
18:            
19:            
20:            #define N_PUSHABLE	10
21:            
22:            #define	N_COL		16
23:            
24:            
25:            #define	MicroQWERTY
26:            
27:            
28:            #ifdef MicroQWERTY
29:            #define	getKeyCode(x)	keyMapList[fnEnable + keyMode*2][x]
30:            #define NO_DIODE
31:            #define	N_ROW		6
32:            #define	swInput	((~(((unsigned short)bitOrderSwap[PORTE] << 8) | bitOrderSwap[PORTB])) & 0x0fff)
33:            
34:            
35:            
36:            static const unsigned short keyMap1[] = {
37:            	//0     1     2     3     4     5     6     7     8     9     A     B
38:            	__1_, __2_, __3_, __4_, __5_, __6_, __7_, __8_, __9_, __0_, MIN_, EQU_, ____, ____, ____, ____, //0x0n
39:            	__Q_, __W_, __E_, __R_, __T_, __Y_, __U_, __I_, __O_, __P_, DEL_, BSP_, ____, ____, ____, ____, //0x1n
40:            	__A_, __S_, __D_, __F_, __G_, __H_, __J_, __K_, __L_, BR_L, BR_R, ENT_, ____, ____, ____, ____, //0x2n
41:            	SH_L, __Z_, __X_, __C_, __V_, __B_, __N_, __M_, SEMI, APOS, C_UP, SH_R, ____, ____, ____, ____, //0x3n
42:            	CT_L, GU_L, AL_L, FN_L, _SP_, TAB_, COMM, DOT_, FN_R, C_LT, C_DN, C_RT, ____, ____, ____, ____, //0x4n
43:            	CONN, SHDN, ESC_, CAPS, SLAS, BSLA, GRAV, ____, ____, ____, V_DN, V_UP, ____, ____, ____, ____, //0x5n
44:            };
45:            
46:            static const unsigned short keyMap1Fn[] = {
47:            	//0     1     2     3     4     5     6     7     8     9     A     B
48:            	_F1_, _F2_, _F3_, _F4_, _F5_, _F6_, _F7_, _F8_, _F9_, F10_, F11_, F12_, ____, ____, ____, ____, //0x0n
49:            	__Q_, __W_, __E_, __R_, __T_, __Y_, __U_, __I_, __O_, __P_, DEL_, BSP_, ____, ____, ____, ____, //0x1n
50:            	__A_, __S_, __D_, __F_, __G_, __H_, __J_, __K_, __L_, BR_L, BR_R, ENT_, ____, ____, ____, ____, //0x2n
51:            	SH_L, __Z_, __X_, __C_, __V_, __B_, __N_, __M_, SEMI, APOS, P_UP, SH_R, ____, ____, ____, ____, //0x3n
52:            	CT_L, GU_L, AL_L, FN_L, _SP_, TAB_, COMM, DOT_, FN_R, HOME, P_DN, END_, ____, ____, ____, ____, //0x4n
53:            	NEXT, PREV, BATT, CAPS, SLAS, BSLA, GRAV, MD_1, MD_2, MD_3, MUTE, PLAY, ____, ____, ____, ____, //0x5n
54:            };
55:            
56:            static const unsigned short keyMap2[] = {
57:            	//0     1     2     3     4     5     6     7     8     9     A     B
58:            	CL_L, CL_L, M_UL, M_UL, M_UU, M_UU, M_UR, M_UR, CL_R, CL_R, M_FT, M_FT, ____, ____, ____, ____, //0x0n
59:            	CL_L, CL_L, M_UL, M_UL, M_UU, M_UU, M_UR, M_UR, CL_R, CL_R, M_FT, M_FT, ____, ____, ____, ____, //0x1n
60:            	CL_L, CL_L, M_LL, M_LL, CL_L, CL_L, M_RR, M_RR, CL_M, CL_M, M_SW, M_SW, ____, ____, ____, ____, //0x2n
61:            	CL_L, CL_L, M_LL, M_LL, CL_L, CL_L, M_RR, M_RR, CL_M, CL_M, M_SW, M_SW, ____, ____, ____, ____, //0x3n
62:            	CL_L, CL_L, M_DL, M_DL, M_DD, M_DD, M_DR, M_DR, FN_R, ____, ____, ____, ____, ____, ____, ____, //0x4n
63:            	S_UP, S_DN, M_DL, M_DL, M_DD, M_DD, M_DR, M_DR, ____, ____, S_DN, S_UP, ____, ____, ____, ____, //0x5n
64:            };
65:            
66:            static const unsigned short keyMap2Fn[] = {
67:            	//0     1     2     3     4     5     6     7     8     9     A     B
68:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
69:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
70:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
71:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x3n
72:            	____, ____, ____, ____, ____, ____, ____, ____, FN_R, ____, ____, ____, ____, ____, ____, ____, //0x4n
73:            	CONN, SHDN, ____, ____, ____, ____, ____, MD_1, MD_2, MD_3, V_DN, V_UP, ____, ____, ____, ____, //0x5n
74:            };
75:            
76:            static const unsigned short keyMap3[] = {
77:            	//0     1     2     3     4     5     6     7     8     9     A     B
78:            	PLAY, PLAY, PLAY, PREV, PREV, PREV, NEXT, NEXT, NEXT, V_UP, V_UP, V_UP, ____, ____, ____, ____, //0x0n
79:            	PLAY, PLAY, PLAY, PREV, PREV, PREV, NEXT, NEXT, NEXT, V_UP, V_UP, V_UP, ____, ____, ____, ____, //0x1n
80:            	PLAY, PLAY, PLAY, PREV, PREV, PREV, NEXT, NEXT, NEXT, V_DN, V_DN, V_DN, ____, ____, ____, ____, //0x2n
81:            	PLAY, PLAY, PLAY, PREV, PREV, PREV, NEXT, NEXT, NEXT, V_DN, V_DN, V_DN, ____, ____, ____, ____, //0x3n
82:            	____, ____, ____, ____, ____, ____, ____, ____, FN_R, ____, ____, ____, ____, ____, ____, ____, //0x4n
83:            	CONN, SHDN, ____, ____, ____, ____, ____, ____, ____, ____, V_DN, V_UP, ____, ____, ____, ____, //0x5n
84:            };
85:            
86:            static const unsigned short keyMap3Fn[] = {
87:            	//0     1     2     3     4     5     6     7     8     9     A     B
88:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
89:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
90:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
91:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x3n
92:            	____, ____, ____, ____, ____, ____, ____, ____, FN_R, ____, ____, ____, ____, ____, ____, ____, //0x4n
93:            	CONN, SHDN, ____, ____, ____, ____, ____, MD_1, MD_2, MD_3, V_DN, V_UP, ____, ____, ____, ____, //0x5n
94:            };
95:            static const unsigned short* keyMapList[] = {
96:            	keyMap1, keyMap1Fn,
97:            	keyMap2, keyMap2Fn,
98:            	keyMap3, keyMap3Fn,
99:            };
100:           #else 
101:           #define	REMOTE_CONTROL
102:           #define	getKeyCode(x)	(fnEnable ? keyMapMouseFn[x] : keyMapMouse[x])
103:           #define NO_DIODE
104:           #define	N_ROW		3
105:           #define	swInput (~bitOrderSwap[PORTB&0x20|(PORTB&0x90>>1)|(PORTB&0x48)<<1]))
106:           static const unsigned short keyMapMouse[] = {
107:           	//0    1    2    3    4
108:           	____, ____, PREV, M_LL, CL_L, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
109:           	FN_L, ____, NEXT, M_DD, M_UU, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
110:           	V_DN, V_UP, PLAY, M_RR, CL_R, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
111:           };
112:           static const unsigned short keyMapMouseFn[] = {
113:           	//0    1    2    3    4
114:           	____, ____, PREV, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
115:           	FN_L, ____, NEXT, ____, CL_M, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
116:           	V_DN, V_UP, PLAY, S_DN, S_UP, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
117:           };
118:           static const unsigned short keyMapCursor[] = {
119:           	//0    1    2    3    4
120:           	____, ____, PREV, ____, CONN, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
121:           	FN_L, ____, NEXT, ____, DISC, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
122:           	V_DN, V_UP, PLAY, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
123:           };
124:           static const unsigned short keyMapCursorFn[] = {
125:           	//0    1    2    3    4
126:           	____, ____, PRE, CON, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
127:           	____, FNL, NXT, DIS, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
128:           	VUP, VDN, PaP, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
129:           };
130:           #endif
131:           
132:           void swPush(unsigned char n);
133:           void swRelease(unsigned char n);
134:           void setScanCodes(void);
135:           
136:           static const unsigned char rowTable[] = {~0x01, ~0x02, ~0x40, ~0x80, ~0x04, ~0x08};
137:           static const unsigned char bitOrderSwap[] = {
138:           	0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
139:           	0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
140:           	0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
141:           	0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
142:           	0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
143:           	0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
144:           	0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
145:           	0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
146:           	0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
147:           	0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
148:           	0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
149:           	0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
150:           	0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
151:           	0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
152:           	0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
153:           	0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
154:           };
155:           
156:           #define B2(n) n,     n+1,     n+1,     n+2
157:           #define B4(n) B2(n), B2(n+1), B2(n+1), B2(n+2)
158:           #define B6(n) B4(n), B4(n+1), B4(n+1), B4(n+2)
159:           static const unsigned char popCount8bits[] = {
160:           	B6(0), B6(1), B6(1), B6(2)
161:           };
162:           
163:           #define	popCount16bits(x)	(popCount8bits[(unsigned char)x]+popCount8bits[(unsigned char)(x >> 8)])
164:           
165:           
166:           
167:           struct MoniteringSwitch mSw[N_PUSHABLE];
168:           unsigned char firstPush = 0xff;
169:           unsigned char lastPush = 0xff;
170:           
171:           unsigned short sw[N_ROW];
172:           
173:           unsigned char keyMode = 0;
174:           unsigned char fnEnable = 0;
175:           //unsigned char swChecked = 0;
176:           struct KeyReport keyReport;
177:           
178:           /******************************************************************************/
179:           /* User Functions                                                             */
180:           /******************************************************************************/
181:           
182:           /* <Initialize variables in user.h and insert code for user algorithms.> */
183:           void InitUiBoardIO(void) {
184:           	unsigned char c;
185:           
186:           	TRISD |= 0x03;
11550  0E03     MOVLW 0x3
11552  1284     IORWF TRISD, F, ACCESS
187:           	TRISB = 0xff;
11554  6882     SETF TRISB, ACCESS
188:           	TRISC = 0x00;
11556  0E00     MOVLW 0x0
11558  6E83     MOVWF TRISC, ACCESS
189:           	TRISE = 0xf0;
1155A  0EF0     MOVLW 0xF0
1155C  6E85     MOVWF TRISE, ACCESS
190:           
191:           	WPUB = 0xff;
1155E  010E     MOVLB 0xE
11560  6999     SETF 0x99, BANKED
192:           	WPUC = 0x00;
11562  0E00     MOVLW 0x0
11564  6FA1     MOVWF 0xA1, BANKED
193:           	WPUE = 0xf0;
11566  0EF0     MOVLW 0xF0
11568  6FAE     MOVWF 0xAE, BANKED
194:           
195:           	//	IOCBP = IOCBN = 0xff;
196:           	//	IOCEP = IOCEN = 0xf0;
197:           	//
198:           	//	IOCBF = 0x00;
199:           	//	IOCEF = 0x00;
200:           	//	PIE0bits.IOCIE = 1;
201:           	//	IPR0bits.IOCIP = 0;
202:           
203:           	for (c = 0; c < N_ROW; c++) {
1156A  0E00     MOVLW 0x0
1156C  0101     MOVLB 0x1
1156E  6FD2     MOVWF 0xD2, BANKED
11570  0E05     MOVLW 0x5
11572  65D2     CPFSGT 0xD2, BANKED
11574  D001     BRA 0x1578
11576  D00E     BRA 0x1594
11590  2BD2     INCF 0xD2, F, BANKED
11592  D7EE     BRA 0x1570
204:           		sw[c] = 0;
11578  51D2     MOVF 0xD2, W, BANKED
1157A  0D02     MULLW 0x2
1157C  0E60     MOVLW 0x60
1157E  24F3     ADDWF PROD, W, ACCESS
11580  6ED9     MOVWF FSR2, ACCESS
11582  0E00     MOVLW 0x0
11584  20F4     ADDWFC PRODH, W, ACCESS
11586  6EDA     MOVWF FSR2H, ACCESS
11588  0E00     MOVLW 0x0
1158A  6EDE     MOVWF POSTINC2, ACCESS
1158C  0E00     MOVLW 0x0
1158E  6EDD     MOVWF POSTDEC2, ACCESS
205:           	}
206:           	for (c = 0; c < N_PUSHABLE; c++) {
11594  0E00     MOVLW 0x0
11596  6FD2     MOVWF 0xD2, BANKED
11598  0E09     MOVLW 0x9
1159A  65D2     CPFSGT 0xD2, BANKED
1159C  D001     BRA 0x15A0
1159E  0012     RETURN 0
115D0  2BD2     INCF 0xD2, F, BANKED
207:           		mSw[c].count = 0;
115A0  51D2     MOVF 0xD2, W, BANKED
115A2  0D05     MULLW 0x5
115A4  0E00     MOVLW 0x0
115A6  24F3     ADDWF PROD, W, ACCESS
115A8  6ED9     MOVWF FSR2, ACCESS
115AA  0E01     MOVLW 0x1
115AC  20F4     ADDWFC PRODH, W, ACCESS
115AE  6EDA     MOVWF FSR2H, ACCESS
115B0  0E00     MOVLW 0x0
115B2  6EDF     MOVWF INDF2, ACCESS
208:           		mSw[c].num = 0xff;
115B4  51D2     MOVF 0xD2, W, BANKED
115B6  0D05     MULLW 0x5
115B8  0E02     MOVLW 0x2
115BA  26F3     ADDWF PROD, F, ACCESS
115BC  0E00     MOVLW 0x0
115BE  22F4     ADDWFC PRODH, F, ACCESS
115C0  0E00     MOVLW 0x0
115C2  24F3     ADDWF PROD, W, ACCESS
115C4  6ED9     MOVWF FSR2, ACCESS
115C6  0E01     MOVLW 0x1
115C8  20F4     ADDWFC PRODH, W, ACCESS
115CA  6EDA     MOVWF FSR2H, ACCESS
115CC  0EFF     MOVLW 0xFF
115CE  6EDF     MOVWF INDF2, ACCESS
115D0  2BD2     INCF 0xD2, F, BANKED
115D2  D7E2     BRA 0x1598
209:           	}
210:           }
211:           
212:           void StandbyUiBoardIO(void) {
213:           	//Set to lowest power consumption state!
214:           
215:           #ifdef MicroQWERTY
216:           	LATB = 0xff; //SWs
11C6A  687A     SETF LATB, ACCESS
217:           	LATC = 0x00; //SWs common
11C6C  0E00     MOVLW 0x0
11C6E  6E7B     MOVWF LATC, ACCESS
218:           	LATE = 0xf0; //SWs & LEDs
11C70  0EF0     MOVLW 0xF0
11C72  6E7D     MOVWF LATE, ACCESS
219:           	
220:           	TRISB = 0xff;
11C74  6882     SETF TRISB, ACCESS
221:           	TRISC = 0x00;
11C76  0E00     MOVLW 0x0
11C78  6E83     MOVWF TRISC, ACCESS
222:           	TRISE = 0xf0;
11C7A  0EF0     MOVLW 0xF0
11C7C  6E85     MOVWF TRISE, ACCESS
223:           
224:           	ANSELB = 0x00;
11C7E  0E00     MOVLW 0x0
11C80  010E     MOVLB 0xE
11C82  6F9A     MOVWF 0x9A, BANKED
225:           	ANSELE = 0x00;
11C84  0E00     MOVLW 0x0
11C86  6FAF     MOVWF bufU2_main, BANKED
226:           
227:           	WPUB = 0xff;
11C88  6999     SETF 0x99, BANKED
228:           	WPUC = 0x00;
11C8A  0E00     MOVLW 0x0
11C8C  6FA1     MOVWF 0xA1, BANKED
229:           	WPUE = 0xf0;
11C8E  0EF0     MOVLW 0xF0
11C90  6FAE     MOVWF 0xAE, BANKED
230:           #else
231:           	LATB = 0xf8; //SWs
232:           	LATC = 0x00; //SWs common
233:           	LATE = 0x00;
234:           		
235:           	TRISB = 0xf8;
236:           	TRISC = 0x00;
237:           	TRISE = 0x00;
238:           
239:           	ANSELB = 0x00;
240:           	ANSELE = 0x00;
241:           
242:           	WPUB = 0xf8;
243:           	WPUC = 0x00;
244:           	WPUE = 0x00;
245:           #endif
246:           	
247:           	INLVLB = 0xff;
11C92  6996     SETF 0x96, BANKED
248:           	INLVLC = 0xff;
11C94  699E     SETF 0x9E, BANKED
249:           	INLVLE = 0xff;
11C96  69AB     SETF 0xAB, BANKED
250:           
251:           	SLRCONB = 0xff;
11C98  6997     SETF 0x97, BANKED
252:           	SLRCONC = 0xff;
11C9A  699F     SETF 0x9F, BANKED
253:           	SLRCONE = 0xff;
11C9C  69AC     SETF 0xAC, BANKED
254:           
255:           	ODCONB = 0x00;
11C9E  0E00     MOVLW 0x0
11CA0  6F98     MOVWF 0x98, BANKED
256:           	ODCONC = 0xff;
11CA2  69A0     SETF 0xA0, BANKED
257:           	ODCONE = 0x00;
11CA4  0E00     MOVLW 0x0
11CA6  6FAD     MOVWF 0xAD, BANKED
258:           }
11CA8  0012     RETURN 0
259:           
260:           void swUnregister(unsigned char n) {
10CB6  0100     MOVLB 0x0
10CB8  6FC3     MOVWF n, BANKED
261:           	swRelease(mSw[n].num);
10CBA  0100     MOVLB 0x0
10CBC  51C3     MOVF n, W, BANKED
10CBE  0D05     MULLW 0x5
10CC0  0E02     MOVLW 0x2
10CC2  26F3     ADDWF PROD, F, ACCESS
10CC4  0E00     MOVLW 0x0
10CC6  22F4     ADDWFC PRODH, F, ACCESS
10CC8  0E00     MOVLW 0x0
10CCA  24F3     ADDWF PROD, W, ACCESS
10CCC  6ED9     MOVWF FSR2, ACCESS
10CCE  0E01     MOVLW 0x1
10CD0  20F4     ADDWFC PRODH, W, ACCESS
10CD2  6EDA     MOVWF FSR2H, ACCESS
10CD4  50DF     MOVF INDF2, W, ACCESS
10CD6  ECBE     CALL 0x1117C, 0
10CD8  F088     NOP
262:           	mSw[n].state = 0;
10CDA  0100     MOVLB 0x0
10CDC  51C3     MOVF n, W, BANKED
10CDE  0D05     MULLW 0x5
10CE0  0E01     MOVLW 0x1
10CE2  26F3     ADDWF PROD, F, ACCESS
10CE4  0E00     MOVLW 0x0
10CE6  22F4     ADDWFC PRODH, F, ACCESS
10CE8  0E00     MOVLW 0x0
10CEA  24F3     ADDWF PROD, W, ACCESS
10CEC  6ED9     MOVWF FSR2, ACCESS
10CEE  0E01     MOVLW 0x1
10CF0  20F4     ADDWFC PRODH, W, ACCESS
10CF2  6EDA     MOVWF FSR2H, ACCESS
10CF4  0E00     MOVLW 0x0
10CF6  6EDF     MOVWF INDF2, ACCESS
263:           	mSw[n].num = 0xff;
10CF8  51C3     MOVF n, W, BANKED
10CFA  0D05     MULLW 0x5
10CFC  0E02     MOVLW 0x2
10CFE  26F3     ADDWF PROD, F, ACCESS
10D00  0E00     MOVLW 0x0
10D02  22F4     ADDWFC PRODH, F, ACCESS
10D04  0E00     MOVLW 0x0
10D06  24F3     ADDWF PROD, W, ACCESS
10D08  6ED9     MOVWF FSR2, ACCESS
10D0A  0E01     MOVLW 0x1
10D0C  20F4     ADDWFC PRODH, W, ACCESS
10D0E  6EDA     MOVWF FSR2H, ACCESS
10D10  0EFF     MOVLW 0xFF
10D12  6EDF     MOVWF INDF2, ACCESS
264:           
265:           	if (mSw[n].next == 0xff) {
10D14  51C3     MOVF n, W, BANKED
10D16  0D05     MULLW 0x5
10D18  0E04     MOVLW 0x4
10D1A  26F3     ADDWF PROD, F, ACCESS
10D1C  0E00     MOVLW 0x0
10D1E  22F4     ADDWFC PRODH, F, ACCESS
10D20  0E00     MOVLW 0x0
10D22  24F3     ADDWF PROD, W, ACCESS
10D24  6ED9     MOVWF FSR2, ACCESS
10D26  0E01     MOVLW 0x1
10D28  20F4     ADDWFC PRODH, W, ACCESS
10D2A  6EDA     MOVWF FSR2H, ACCESS
10D2C  28DE     INCF POSTINC2, W, ACCESS
10D2E  A4D8     BTFSS STATUS, 2, ACCESS
10D30  D020     BRA 0xD72
266:           		lastPush = mSw[n].pre;
10D32  51C3     MOVF n, W, BANKED
10D34  0D05     MULLW 0x5
10D36  0E03     MOVLW 0x3
10D38  26F3     ADDWF PROD, F, ACCESS
10D3A  0E00     MOVLW 0x0
10D3C  22F4     ADDWFC PRODH, F, ACCESS
10D3E  0E00     MOVLW 0x0
10D40  24F3     ADDWF PROD, W, ACCESS
10D42  6ED9     MOVWF FSR2, ACCESS
10D44  0E01     MOVLW 0x1
10D46  20F4     ADDWFC PRODH, W, ACCESS
10D48  6EDA     MOVWF FSR2H, ACCESS
10D4A  50DF     MOVF INDF2, W, ACCESS
10D4C  6E42     MOVWF lastPush, ACCESS
267:           		if (lastPush != 0xff) {
10D4E  2842     INCF lastPush, W, ACCESS
10D50  B4D8     BTFSC STATUS, 2, ACCESS
10D52  D037     BRA 0xDC2
268:           			mSw[lastPush].next = 0xff;
10D54  5042     MOVF lastPush, W, ACCESS
10D56  0D05     MULLW 0x5
10D58  0E04     MOVLW 0x4
10D5A  26F3     ADDWF PROD, F, ACCESS
10D5C  0E00     MOVLW 0x0
10D5E  22F4     ADDWFC PRODH, F, ACCESS
10D60  0E00     MOVLW 0x0
10D62  24F3     ADDWF PROD, W, ACCESS
10D64  6ED9     MOVWF FSR2, ACCESS
10D66  0E01     MOVLW 0x1
10D68  20F4     ADDWFC PRODH, W, ACCESS
10D6A  6EDA     MOVWF FSR2H, ACCESS
10D6C  0EFF     MOVLW 0xFF
10D6E  6EDF     MOVWF INDF2, ACCESS
269:           		}
270:           	} else {
10D70  D028     BRA 0xDC2
271:           		mSw[mSw[n].next].pre = mSw[n].pre;
10D72  51C3     MOVF n, W, BANKED
10D74  0D05     MULLW 0x5
10D76  0E03     MOVLW 0x3
10D78  26F3     ADDWF PROD, F, ACCESS
10D7A  0E00     MOVLW 0x0
10D7C  22F4     ADDWFC PRODH, F, ACCESS
10D7E  0E00     MOVLW 0x0
10D80  24F3     ADDWF PROD, W, ACCESS
10D82  6ED9     MOVWF FSR2, ACCESS
10D84  0E01     MOVLW 0x1
10D86  20F4     ADDWFC PRODH, W, ACCESS
10D88  6EDA     MOVWF FSR2H, ACCESS
10D8A  51C3     MOVF n, W, BANKED
10D8C  0D05     MULLW 0x5
10D8E  0E04     MOVLW 0x4
10D90  26F3     ADDWF PROD, F, ACCESS
10D92  0E00     MOVLW 0x0
10D94  22F4     ADDWFC PRODH, F, ACCESS
10D96  0E00     MOVLW 0x0
10D98  24F3     ADDWF PROD, W, ACCESS
10D9A  6EE1     MOVWF FSR1, ACCESS
10D9C  0E01     MOVLW 0x1
10D9E  20F4     ADDWFC PRODH, W, ACCESS
10DA0  6EE2     MOVWF FSR1H, ACCESS
10DA2  50E7     MOVF INDF1, W, ACCESS
10DA4  6FC2     MOVWF 0xC2, BANKED
10DA6  51C2     MOVF 0xC2, W, BANKED
10DA8  0D05     MULLW 0x5
10DAA  0E03     MOVLW 0x3
10DAC  26F3     ADDWF PROD, F, ACCESS
10DAE  0E00     MOVLW 0x0
10DB0  22F4     ADDWFC PRODH, F, ACCESS
10DB2  0E00     MOVLW 0x0
10DB4  24F3     ADDWF PROD, W, ACCESS
10DB6  6EE1     MOVWF FSR1, ACCESS
10DB8  0E01     MOVLW 0x1
10DBA  20F4     ADDWFC PRODH, W, ACCESS
10DBC  6EE2     MOVWF FSR1H, ACCESS
10DBE  CFDF     MOVFF INDF2, INDF1
10DC0  FFE7     NOP
272:           	}
273:           
274:           	if (mSw[n].pre == 0xff) {
10DC2  51C3     MOVF n, W, BANKED
10DC4  0D05     MULLW 0x5
10DC6  0E03     MOVLW 0x3
10DC8  26F3     ADDWF PROD, F, ACCESS
10DCA  0E00     MOVLW 0x0
10DCC  22F4     ADDWFC PRODH, F, ACCESS
10DCE  0E00     MOVLW 0x0
10DD0  24F3     ADDWF PROD, W, ACCESS
10DD2  6ED9     MOVWF FSR2, ACCESS
10DD4  0E01     MOVLW 0x1
10DD6  20F4     ADDWFC PRODH, W, ACCESS
10DD8  6EDA     MOVWF FSR2H, ACCESS
10DDA  28DE     INCF POSTINC2, W, ACCESS
10DDC  A4D8     BTFSS STATUS, 2, ACCESS
10DDE  D020     BRA 0xE20
275:           		firstPush = mSw[n].next;
10DE0  51C3     MOVF n, W, BANKED
10DE2  0D05     MULLW 0x5
10DE4  0E04     MOVLW 0x4
10DE6  26F3     ADDWF PROD, F, ACCESS
10DE8  0E00     MOVLW 0x0
10DEA  22F4     ADDWFC PRODH, F, ACCESS
10DEC  0E00     MOVLW 0x0
10DEE  24F3     ADDWF PROD, W, ACCESS
10DF0  6ED9     MOVWF FSR2, ACCESS
10DF2  0E01     MOVLW 0x1
10DF4  20F4     ADDWFC PRODH, W, ACCESS
10DF6  6EDA     MOVWF FSR2H, ACCESS
10DF8  50DF     MOVF INDF2, W, ACCESS
10DFA  6E43     MOVWF firstPush, ACCESS
276:           		if (firstPush != 0xff) {
10DFC  2843     INCF firstPush, W, ACCESS
10DFE  B4D8     BTFSC STATUS, 2, ACCESS
10E00  0012     RETURN 0
277:           			mSw[firstPush].pre = 0xff;
10E02  5043     MOVF firstPush, W, ACCESS
10E04  0D05     MULLW 0x5
10E06  0E03     MOVLW 0x3
10E08  26F3     ADDWF PROD, F, ACCESS
10E0A  0E00     MOVLW 0x0
10E0C  22F4     ADDWFC PRODH, F, ACCESS
10E0E  0E00     MOVLW 0x0
10E10  24F3     ADDWF PROD, W, ACCESS
10E12  6ED9     MOVWF FSR2, ACCESS
10E14  0E01     MOVLW 0x1
10E16  20F4     ADDWFC PRODH, W, ACCESS
10E18  6EDA     MOVWF FSR2H, ACCESS
10E1A  0EFF     MOVLW 0xFF
10E1C  6EDF     MOVWF INDF2, ACCESS
278:           		}
279:           	} else {
10E1E  0012     RETURN 0
280:           		mSw[mSw[n].pre].next = mSw[n].next;
10E20  51C3     MOVF n, W, BANKED
10E22  0D05     MULLW 0x5
10E24  0E04     MOVLW 0x4
10E26  26F3     ADDWF PROD, F, ACCESS
10E28  0E00     MOVLW 0x0
10E2A  22F4     ADDWFC PRODH, F, ACCESS
10E2C  0E00     MOVLW 0x0
10E2E  24F3     ADDWF PROD, W, ACCESS
10E30  6ED9     MOVWF FSR2, ACCESS
10E32  0E01     MOVLW 0x1
10E34  20F4     ADDWFC PRODH, W, ACCESS
10E36  6EDA     MOVWF FSR2H, ACCESS
10E38  51C3     MOVF n, W, BANKED
10E3A  0D05     MULLW 0x5
10E3C  0E03     MOVLW 0x3
10E3E  26F3     ADDWF PROD, F, ACCESS
10E40  0E00     MOVLW 0x0
10E42  22F4     ADDWFC PRODH, F, ACCESS
10E44  0E00     MOVLW 0x0
10E46  24F3     ADDWF PROD, W, ACCESS
10E48  6EE1     MOVWF FSR1, ACCESS
10E4A  0E01     MOVLW 0x1
10E4C  20F4     ADDWFC PRODH, W, ACCESS
10E4E  6EE2     MOVWF FSR1H, ACCESS
10E50  50E7     MOVF INDF1, W, ACCESS
10E52  6FC2     MOVWF 0xC2, BANKED
10E54  51C2     MOVF 0xC2, W, BANKED
10E56  0D05     MULLW 0x5
10E58  0E04     MOVLW 0x4
10E5A  26F3     ADDWF PROD, F, ACCESS
10E5C  0E00     MOVLW 0x0
10E5E  22F4     ADDWFC PRODH, F, ACCESS
10E60  0E00     MOVLW 0x0
10E62  24F3     ADDWF PROD, W, ACCESS
10E64  6EE1     MOVWF FSR1, ACCESS
10E66  0E01     MOVLW 0x1
10E68  20F4     ADDWFC PRODH, W, ACCESS
10E6A  6EE2     MOVWF FSR1H, ACCESS
10E6C  CFDF     MOVFF INDF2, INDF1
10E6E  FFE7     NOP
281:           	}
10E70  0012     RETURN 0
282:           	return;
283:           }
284:           
285:           void swRegister(unsigned char n) {
10A74  0100     MOVLB 0x0
10A76  6FBD     MOVWF n, BANKED
286:           	unsigned char c;
287:           #ifdef NO_DIODE
288:           	unsigned char sameCol = 0;
10A78  0E00     MOVLW 0x0
10A7A  0100     MOVLB 0x0
10A7C  6FBB     MOVWF sameCol, BANKED
289:           	unsigned char sameRow = 0;
10A7E  0E00     MOVLW 0x0
10A80  6FBC     MOVWF sameRow, BANKED
290:           #endif
291:           	for (c = 0; c < N_PUSHABLE; c++) {
10A82  0E00     MOVLW 0x0
10A84  6FC0     MOVWF ttt, BANKED
10A86  0E09     MOVLW 0x9
10A88  65C0     CPFSGT ttt, BANKED
10A8A  D001     BRA 0xA8E
10A8C  D012     BRA 0xAB2
10AAE  2BC0     INCF ttt, F, BANKED
10AB0  D7EA     BRA 0xA86
292:           		if (mSw[c].num == n) {
10A8E  51C0     MOVF ttt, W, BANKED
10A90  0D05     MULLW 0x5
10A92  0E02     MOVLW 0x2
10A94  26F3     ADDWF PROD, F, ACCESS
10A96  0E00     MOVLW 0x0
10A98  22F4     ADDWFC PRODH, F, ACCESS
10A9A  0E00     MOVLW 0x0
10A9C  24F3     ADDWF PROD, W, ACCESS
10A9E  6ED9     MOVWF FSR2, ACCESS
10AA0  0E01     MOVLW 0x1
10AA2  20F4     ADDWFC PRODH, W, ACCESS
10AA4  6EDA     MOVWF FSR2H, ACCESS
10AA6  51BD     MOVF n, W, BANKED
10AA8  18DE     XORWF POSTINC2, W, ACCESS
10AAA  B4D8     BTFSC STATUS, 2, ACCESS
10AAC  0012     RETURN 0
293:           			return; //Already registered
294:           		}
295:           	}
296:           #ifdef NO_DIODE
297:           	for (c = 0; c < N_PUSHABLE; c++) {
10AB2  0E00     MOVLW 0x0
10AB4  6FC0     MOVWF ttt, BANKED
10AB6  0E09     MOVLW 0x9
10AB8  65C0     CPFSGT ttt, BANKED
10ABA  D001     BRA 0xABE
10ABC  D086     BRA 0xBCA
10BC6  2BC0     INCF ttt, F, BANKED
10BC8  D776     BRA 0xAB6
298:           		if (((mSw[c].num ^ n) & 0x0f) == 0) {
10ABE  51C0     MOVF ttt, W, BANKED
10AC0  0D05     MULLW 0x5
10AC2  0E02     MOVLW 0x2
10AC4  26F3     ADDWF PROD, F, ACCESS
10AC6  0E00     MOVLW 0x0
10AC8  22F4     ADDWFC PRODH, F, ACCESS
10ACA  0E00     MOVLW 0x0
10ACC  24F3     ADDWF PROD, W, ACCESS
10ACE  6ED9     MOVWF FSR2, ACCESS
10AD0  0E01     MOVLW 0x1
10AD2  20F4     ADDWFC PRODH, W, ACCESS
10AD4  6EDA     MOVWF FSR2H, ACCESS
10AD6  50DF     MOVF INDF2, W, ACCESS
10AD8  19BD     XORWF n, W, BANKED
10ADA  6FB9     MOVWF __pcstackBANK0, BANKED
10ADC  0E0F     MOVLW 0xF
10ADE  17B9     ANDWF __pcstackBANK0, F, BANKED
10AE0  A4D8     BTFSS STATUS, 2, ACCESS
10AE2  D02F     BRA 0xB42
299:           			unsigned char d;
300:           			sameCol = 1;
10AE4  0E01     MOVLW 0x1
10AE6  6FBB     MOVWF sameCol, BANKED
301:           			for (d = 0; d < N_PUSHABLE; d++) {
10AE8  0E00     MOVLW 0x0
10AEA  6FBE     MOVWF d, BANKED
10AEC  0E09     MOVLW 0x9
10AEE  65BE     CPFSGT d, BANKED
10AF0  D001     BRA 0xAF4
10AF2  D069     BRA 0xBC6
302:           				if (((mSw[c].num ^ mSw[d].num) & 0xf0) == 0) {
10AF4  51BE     MOVF d, W, BANKED
10AF6  0D05     MULLW 0x5
10AF8  0E02     MOVLW 0x2
10AFA  26F3     ADDWF PROD, F, ACCESS
10AFC  0E00     MOVLW 0x0
10AFE  22F4     ADDWFC PRODH, F, ACCESS
10B00  0E00     MOVLW 0x0
10B02  24F3     ADDWF PROD, W, ACCESS
10B04  6ED9     MOVWF FSR2, ACCESS
10B06  0E01     MOVLW 0x1
10B08  20F4     ADDWFC PRODH, W, ACCESS
10B0A  6EDA     MOVWF FSR2H, ACCESS
10B0C  50DF     MOVF INDF2, W, ACCESS
10B0E  6FB9     MOVWF __pcstackBANK0, BANKED
10B10  51C0     MOVF ttt, W, BANKED
10B12  0D05     MULLW 0x5
10B14  0E02     MOVLW 0x2
10B16  26F3     ADDWF PROD, F, ACCESS
10B18  0E00     MOVLW 0x0
10B1A  22F4     ADDWFC PRODH, F, ACCESS
10B1C  0E00     MOVLW 0x0
10B1E  24F3     ADDWF PROD, W, ACCESS
10B20  6ED9     MOVWF FSR2, ACCESS
10B22  0E01     MOVLW 0x1
10B24  20F4     ADDWFC PRODH, W, ACCESS
10B26  6EDA     MOVWF FSR2H, ACCESS
10B28  50DF     MOVF INDF2, W, ACCESS
10B2A  19B9     XORWF __pcstackBANK0, W, BANKED
10B2C  6FBA     MOVWF 0xBA, BANKED
10B2E  0EF0     MOVLW 0xF0
10B30  17BA     ANDWF 0xBA, F, BANKED
10B32  A4D8     BTFSS STATUS, 2, ACCESS
10B34  D004     BRA 0xB3E
303:           					if (d != c) {
10B36  51C0     MOVF ttt, W, BANKED
10B38  19BE     XORWF d, W, BANKED
10B3A  A4D8     BTFSS STATUS, 2, ACCESS
10B3C  0012     RETURN 0
304:           						return; //Ghost
305:           					}
10B3E  2BBE     INCF d, F, BANKED
10B40  D7D5     BRA 0xAEC
306:           				}
307:           			}
308:           		} else if (((mSw[c].num ^ n) & 0xf0) == 0) {
10B42  51C0     MOVF ttt, W, BANKED
10B44  0D05     MULLW 0x5
10B46  0E02     MOVLW 0x2
10B48  26F3     ADDWF PROD, F, ACCESS
10B4A  0E00     MOVLW 0x0
10B4C  22F4     ADDWFC PRODH, F, ACCESS
10B4E  0E00     MOVLW 0x0
10B50  24F3     ADDWF PROD, W, ACCESS
10B52  6ED9     MOVWF FSR2, ACCESS
10B54  0E01     MOVLW 0x1
10B56  20F4     ADDWFC PRODH, W, ACCESS
10B58  6EDA     MOVWF FSR2H, ACCESS
10B5A  50DF     MOVF INDF2, W, ACCESS
10B5C  19BD     XORWF n, W, BANKED
10B5E  6FB9     MOVWF __pcstackBANK0, BANKED
10B60  0EF0     MOVLW 0xF0
10B62  17B9     ANDWF __pcstackBANK0, F, BANKED
10B64  A4D8     BTFSS STATUS, 2, ACCESS
10B66  D02F     BRA 0xBC6
309:           			unsigned char d;
310:           			sameRow = 1;
10B68  0E01     MOVLW 0x1
10B6A  6FBC     MOVWF sameRow, BANKED
311:           			for (d = 0; d < N_PUSHABLE; d++) {
10B6C  0E00     MOVLW 0x0
10B6E  6FBF     MOVWF n, BANKED
10B70  0E09     MOVLW 0x9
10B72  65BF     CPFSGT n, BANKED
10B74  D001     BRA 0xB78
10B76  D027     BRA 0xBC6
312:           				if (((mSw[c].num ^ mSw[d].num) & 0x0f) == 0) {
10B78  51BF     MOVF n, W, BANKED
10B7A  0D05     MULLW 0x5
10B7C  0E02     MOVLW 0x2
10B7E  26F3     ADDWF PROD, F, ACCESS
10B80  0E00     MOVLW 0x0
10B82  22F4     ADDWFC PRODH, F, ACCESS
10B84  0E00     MOVLW 0x0
10B86  24F3     ADDWF PROD, W, ACCESS
10B88  6ED9     MOVWF FSR2, ACCESS
10B8A  0E01     MOVLW 0x1
10B8C  20F4     ADDWFC PRODH, W, ACCESS
10B8E  6EDA     MOVWF FSR2H, ACCESS
10B90  50DF     MOVF INDF2, W, ACCESS
10B92  6FB9     MOVWF __pcstackBANK0, BANKED
10B94  51C0     MOVF ttt, W, BANKED
10B96  0D05     MULLW 0x5
10B98  0E02     MOVLW 0x2
10B9A  26F3     ADDWF PROD, F, ACCESS
10B9C  0E00     MOVLW 0x0
10B9E  22F4     ADDWFC PRODH, F, ACCESS
10BA0  0E00     MOVLW 0x0
10BA2  24F3     ADDWF PROD, W, ACCESS
10BA4  6ED9     MOVWF FSR2, ACCESS
10BA6  0E01     MOVLW 0x1
10BA8  20F4     ADDWFC PRODH, W, ACCESS
10BAA  6EDA     MOVWF FSR2H, ACCESS
10BAC  50DF     MOVF INDF2, W, ACCESS
10BAE  19B9     XORWF __pcstackBANK0, W, BANKED
10BB0  6FBA     MOVWF 0xBA, BANKED
10BB2  0E0F     MOVLW 0xF
10BB4  17BA     ANDWF 0xBA, F, BANKED
10BB6  A4D8     BTFSS STATUS, 2, ACCESS
10BB8  D004     BRA 0xBC2
313:           					if (d != c) {
10BBA  51C0     MOVF ttt, W, BANKED
10BBC  19BF     XORWF n, W, BANKED
10BBE  A4D8     BTFSS STATUS, 2, ACCESS
10BC0  0012     RETURN 0
314:           						return; //Ghost
315:           					}
10BC2  2BBF     INCF n, F, BANKED
10BC4  D7D5     BRA 0xB70
316:           				}
317:           			}
318:           		}
319:           #endif
320:           	}
321:           #ifdef NO_DIODE
322:           	if (sameCol && sameRow) {
10BCA  51BB     MOVF sameCol, W, BANKED
10BCC  B4D8     BTFSC STATUS, 2, ACCESS
10BCE  D003     BRA 0xBD6
10BD0  51BC     MOVF sameRow, W, BANKED
10BD2  A4D8     BTFSS STATUS, 2, ACCESS
10BD4  0012     RETURN 0
323:           		return; //Ghost
324:           	}
325:           #endif
326:           	for (c = 0; c < N_PUSHABLE; c++) {
10BD6  0E00     MOVLW 0x0
10BD8  6FC0     MOVWF ttt, BANKED
10BDA  0E09     MOVLW 0x9
10BDC  65C0     CPFSGT ttt, BANKED
10BDE  D001     BRA 0xBE2
10BE0  0012     RETURN 0
327:           		if (mSw[c].num == 0xff) {
10BE2  51C0     MOVF ttt, W, BANKED
10BE4  0D05     MULLW 0x5
10BE6  0E02     MOVLW 0x2
10BE8  26F3     ADDWF PROD, F, ACCESS
10BEA  0E00     MOVLW 0x0
10BEC  22F4     ADDWFC PRODH, F, ACCESS
10BEE  0E00     MOVLW 0x0
10BF0  24F3     ADDWF PROD, W, ACCESS
10BF2  6ED9     MOVWF FSR2, ACCESS
10BF4  0E01     MOVLW 0x1
10BF6  20F4     ADDWFC PRODH, W, ACCESS
10BF8  6EDA     MOVWF FSR2H, ACCESS
10BFA  28DE     INCF POSTINC2, W, ACCESS
10BFC  A4D8     BTFSS STATUS, 2, ACCESS
10BFE  D059     BRA 0xCB2
328:           			mSw[c].num = n;
10C00  51C0     MOVF ttt, W, BANKED
10C02  0D05     MULLW 0x5
10C04  0E02     MOVLW 0x2
10C06  26F3     ADDWF PROD, F, ACCESS
10C08  0E00     MOVLW 0x0
10C0A  22F4     ADDWFC PRODH, F, ACCESS
10C0C  0E00     MOVLW 0x0
10C0E  24F3     ADDWF PROD, W, ACCESS
10C10  6ED9     MOVWF FSR2, ACCESS
10C12  0E01     MOVLW 0x1
10C14  20F4     ADDWFC PRODH, W, ACCESS
10C16  6EDA     MOVWF FSR2H, ACCESS
10C18  C0BD     MOVFF n, INDF2
10C1A  FFDF     NOP
329:           			mSw[c].count = 1;
10C1C  51C0     MOVF ttt, W, BANKED
10C1E  0D05     MULLW 0x5
10C20  0E00     MOVLW 0x0
10C22  24F3     ADDWF PROD, W, ACCESS
10C24  6ED9     MOVWF FSR2, ACCESS
10C26  0E01     MOVLW 0x1
10C28  20F4     ADDWFC PRODH, W, ACCESS
10C2A  6EDA     MOVWF FSR2H, ACCESS
10C2C  0E01     MOVLW 0x1
10C2E  6EDF     MOVWF INDF2, ACCESS
330:           			mSw[c].next = 0xff;
10C30  51C0     MOVF ttt, W, BANKED
10C32  0D05     MULLW 0x5
10C34  0E04     MOVLW 0x4
10C36  26F3     ADDWF PROD, F, ACCESS
10C38  0E00     MOVLW 0x0
10C3A  22F4     ADDWFC PRODH, F, ACCESS
10C3C  0E00     MOVLW 0x0
10C3E  24F3     ADDWF PROD, W, ACCESS
10C40  6ED9     MOVWF FSR2, ACCESS
10C42  0E01     MOVLW 0x1
10C44  20F4     ADDWFC PRODH, W, ACCESS
10C46  6EDA     MOVWF FSR2H, ACCESS
10C48  0EFF     MOVLW 0xFF
10C4A  6EDF     MOVWF INDF2, ACCESS
331:           			if (firstPush == 0xff) {
10C4C  2843     INCF firstPush, W, ACCESS
10C4E  A4D8     BTFSS STATUS, 2, ACCESS
10C50  D011     BRA 0xC74
332:           				firstPush = c;
10C52  C0C0     MOVFF ttt, firstPush
10C54  F043     NOP
333:           				mSw[c].pre = 0xff;
10C56  51C0     MOVF ttt, W, BANKED
10C58  0D05     MULLW 0x5
10C5A  0E03     MOVLW 0x3
10C5C  26F3     ADDWF PROD, F, ACCESS
10C5E  0E00     MOVLW 0x0
10C60  22F4     ADDWFC PRODH, F, ACCESS
10C62  0E00     MOVLW 0x0
10C64  24F3     ADDWF PROD, W, ACCESS
10C66  6ED9     MOVWF FSR2, ACCESS
10C68  0E01     MOVLW 0x1
10C6A  20F4     ADDWFC PRODH, W, ACCESS
10C6C  6EDA     MOVWF FSR2H, ACCESS
10C6E  0EFF     MOVLW 0xFF
10C70  6EDF     MOVWF INDF2, ACCESS
334:           			} else {
10C72  D01C     BRA 0xCAC
335:           				mSw[lastPush].next = c;
10C74  5042     MOVF lastPush, W, ACCESS
10C76  0D05     MULLW 0x5
10C78  0E04     MOVLW 0x4
10C7A  26F3     ADDWF PROD, F, ACCESS
10C7C  0E00     MOVLW 0x0
10C7E  22F4     ADDWFC PRODH, F, ACCESS
10C80  0E00     MOVLW 0x0
10C82  24F3     ADDWF PROD, W, ACCESS
10C84  6ED9     MOVWF FSR2, ACCESS
10C86  0E01     MOVLW 0x1
10C88  20F4     ADDWFC PRODH, W, ACCESS
10C8A  6EDA     MOVWF FSR2H, ACCESS
10C8C  C0C0     MOVFF ttt, INDF2
10C8E  FFDF     NOP
336:           				mSw[c].pre = lastPush;
10C90  51C0     MOVF ttt, W, BANKED
10C92  0D05     MULLW 0x5
10C94  0E03     MOVLW 0x3
10C96  26F3     ADDWF PROD, F, ACCESS
10C98  0E00     MOVLW 0x0
10C9A  22F4     ADDWFC PRODH, F, ACCESS
10C9C  0E00     MOVLW 0x0
10C9E  24F3     ADDWF PROD, W, ACCESS
10CA0  6ED9     MOVWF FSR2, ACCESS
10CA2  0E01     MOVLW 0x1
10CA4  20F4     ADDWFC PRODH, W, ACCESS
10CA6  6EDA     MOVWF FSR2H, ACCESS
10CA8  C042     MOVFF lastPush, INDF2
10CAA  FFDF     NOP
337:           			}
338:           			lastPush = c;
10CAC  C0C0     MOVFF ttt, lastPush
10CAE  F042     NOP
339:           			return;
10CB0  0012     RETURN 0
340:           		}
10CB2  2BC0     INCF ttt, F, BANKED
10CB4  D792     BRA 0xBDA
341:           	}
342:           }
343:           
344:           void swPush(unsigned char n) {
107AE  0100     MOVLB 0x0
107B0  6FBF     MOVWF n, BANKED
345:           	unsigned short ttt = getKeyCode(n);
107B2  0100     MOVLB 0x0
107B4  51BF     MOVF n, W, BANKED
107B6  0D02     MULLW 0x2
107B8  5188     MOVF keyMode, W, BANKED
107BA  6FB9     MOVWF __pcstackBANK0, BANKED
107BC  6BBA     CLRF 0xBA, BANKED
107BE  90D8     BCF STATUS, 0, ACCESS
107C0  37B9     RLCF __pcstackBANK0, F, BANKED
107C2  37BA     RLCF 0xBA, F, BANKED
107C4  5189     MOVF fnEnable, W, BANKED
107C6  6FBB     MOVWF sameCol, BANKED
107C8  6BBC     CLRF sameRow, BANKED
107CA  51B9     MOVF __pcstackBANK0, W, BANKED
107CC  27BB     ADDWF sameCol, F, BANKED
107CE  51BA     MOVF 0xBA, W, BANKED
107D0  23BC     ADDWFC sameRow, F, BANKED
107D2  90D8     BCF STATUS, 0, ACCESS
107D4  37BB     RLCF sameCol, F, BANKED
107D6  37BC     RLCF sameRow, F, BANKED
107D8  0EE6     MOVLW 0xE6
107DA  25BB     ADDWF sameCol, W, BANKED
107DC  6ED9     MOVWF FSR2, ACCESS
107DE  0E00     MOVLW 0x0
107E0  21BC     ADDWFC sameRow, W, BANKED
107E2  6EDA     MOVWF FSR2H, ACCESS
107E4  CFDE     MOVFF POSTINC2, n
107E6  F0BD     NOP
107E8  CFDD     MOVFF POSTDEC2, d
107EA  F0BE     NOP
107EC  50F3     MOVF PROD, W, ACCESS
107EE  27BD     ADDWF n, F, BANKED
107F0  50F4     MOVF PRODH, W, ACCESS
107F2  23BE     ADDWFC d, F, BANKED
107F4  C0BD     MOVFF n, TBLPTR
107F6  FFF6     NOP
107F8  C0BE     MOVFF d, TBLPTRH
107FA  FFF7     NOP
107FC  0E00     MOVLW 0x0
107FE  6EF8     MOVWF TBLPTRU, ACCESS
10800  0009     TBLRD*+
10802  CFF5     MOVFF TABLAT, ttt
10804  F0C0     NOP
10806  000A     TBLRD*-
10808  CFF5     MOVFF TABLAT, 0xC1
1080A  F0C1     NOP
346:           	switch (ttt >> 12) {
1080C  D113     BRA 0xA34
10A34  C0C0     MOVFF ttt, __pcstackBANK0
10A36  F0B9     NOP
10A38  C0C1     MOVFF 0xC1, 0xBA
10A3A  F0BA     NOP
10A3C  0E0C     MOVLW 0xC
10A3E  6FBB     MOVWF sameCol, BANKED
10A40  90D8     BCF STATUS, 0, ACCESS
10A42  33BA     RRCF 0xBA, F, BANKED
10A44  33B9     RRCF __pcstackBANK0, F, BANKED
10A46  2FBB     DECFSZ sameCol, F, BANKED
10A48  D7FB     BRA 0xA40
10A4A  51BA     MOVF 0xBA, W, BANKED
10A4C  0A00     XORLW 0x0
10A4E  A4D8     BTFSS STATUS, 2, ACCESS
10A50  0012     RETURN 0
10A52  51B9     MOVF __pcstackBANK0, W, BANKED
10A54  0A00     XORLW 0x0
10A56  B4D8     BTFSC STATUS, 2, ACCESS
10A58  D6DA     BRA 0x80E
10A5A  0A01     XORLW 0x1
10A5C  B4D8     BTFSC STATUS, 2, ACCESS
10A5E  D6D9     BRA 0x812
10A60  0A03     XORLW 0x3
10A62  B4D8     BTFSC STATUS, 2, ACCESS
10A64  D6FA     BRA 0x85A
10A66  0A01     XORLW 0x1
10A68  B4D8     BTFSC STATUS, 2, ACCESS
10A6A  D74F     BRA 0x90A
10A6C  0A0C     XORLW 0xC
10A6E  A4D8     BTFSS STATUS, 2, ACCESS
10A70  0012     RETURN 0
10A72  D7AF     BRA 0x9D2
347:           		case 0x0: //Normal keys
348:           			mainFlags.sendKeyReport = 1;
1080E  8611     BSF mainFlags, 3, ACCESS
349:           			break;
10810  0012     RETURN 0
350:           		case 0x1: //Modifier keys
351:           			if ((ttt) == SH_L && keyReport.modifier.bits.ShiftR) {
10812  05C0     DECF ttt, W, BANKED
10814  E107     BNZ 0x824
10816  0E10     MOVLW 0x10
10818  19C1     XORWF 0xC1, W, BANKED
1081A  B4D8     BTFSC STATUS, 2, ACCESS
1081C  AB78     BTFSS keyReport, 5, BANKED
1081E  D002     BRA 0x824
352:           				keyReport.modifier.bits.ShiftR = 0;
10820  9B78     BCF keyReport, 5, BANKED
353:           			} else if (ttt == SH_R && keyReport.modifier.bits.ShiftL) {
10822  D019     BRA 0x856
10824  0E05     MOVLW 0x5
10826  19C0     XORWF ttt, W, BANKED
10828  E107     BNZ 0x838
1082A  0E10     MOVLW 0x10
1082C  19C1     XORWF 0xC1, W, BANKED
1082E  B4D8     BTFSC STATUS, 2, ACCESS
10830  A378     BTFSS keyReport, 1, BANKED
10832  D002     BRA 0x838
354:           				keyReport.modifier.bits.ShiftL = 0;
10834  9378     BCF keyReport, 1, BANKED
355:           			} else {
10836  D00F     BRA 0x856
356:           				keyReport.modifier.byte ^= 1 << (ttt & 0x07);
10838  C0C0     MOVFF ttt, __pcstackBANK0
1083A  F0B9     NOP
1083C  0E07     MOVLW 0x7
1083E  17B9     ANDWF __pcstackBANK0, F, BANKED
10840  0E01     MOVLW 0x1
10842  6FBA     MOVWF 0xBA, BANKED
10844  2BB9     INCF __pcstackBANK0, F, BANKED
10846  D002     BRA 0x84C
10848  90D8     BCF STATUS, 0, ACCESS
1084A  37BA     RLCF 0xBA, F, BANKED
1084C  2FB9     DECFSZ __pcstackBANK0, F, BANKED
1084E  D7FC     BRA 0x848
10850  0100     MOVLB 0x0
10852  51BA     MOVF 0xBA, W, BANKED
10854  1B78     XORWF keyReport, F, BANKED
357:           			}
358:           			mainFlags.sendKeyReport = 1;
10856  8611     BSF mainFlags, 3, ACCESS
359:           			break;
10858  0012     RETURN 0
360:           		case 0x2: //Consumer report keys
361:           			consumerKey |= 0x01 << (unsigned char) ttt;
1085A  C0C0     MOVFF ttt, __pcstackBANK0
1085C  F0B9     NOP
1085E  0E01     MOVLW 0x1
10860  6FBA     MOVWF 0xBA, BANKED
10862  0E00     MOVLW 0x0
10864  6FBB     MOVWF sameCol, BANKED
10866  2BB9     INCF __pcstackBANK0, F, BANKED
10868  D003     BRA 0x870
1086A  90D8     BCF STATUS, 0, ACCESS
1086C  37BA     RLCF 0xBA, F, BANKED
1086E  37BB     RLCF sameCol, F, BANKED
10870  2FB9     DECFSZ __pcstackBANK0, F, BANKED
10872  D7FB     BRA 0x86A
10874  0100     MOVLB 0x0
10876  51BA     MOVF 0xBA, W, BANKED
10878  1385     IORWF consumerKey, F, BANKED
1087A  51BB     MOVF sameCol, W, BANKED
1087C  1386     IORWF 0x86, F, BANKED
362:           			mainFlags.sendComsumerKeyReport = 1;
1087E  8411     BSF mainFlags, 2, ACCESS
363:           			break;
10880  0012     RETURN 0
364:           		case 0x3: //Mouse keys
365:           			switch (ttt) {
1090A  C0C0     MOVFF ttt, __pcstackBANK0
1090C  F0B9     NOP
1090E  C0C1     MOVFF 0xC1, 0xBA
10910  F0BA     NOP
10912  51BA     MOVF 0xBA, W, BANKED
10914  0A30     XORLW 0x30
10916  B4D8     BTFSC STATUS, 2, ACCESS
10918  D00A     BRA 0x92E
1091A  0A01     XORLW 0x1
1091C  B4D8     BTFSC STATUS, 2, ACCESS
1091E  D021     BRA 0x962
10920  0A03     XORLW 0x3
10922  B4D8     BTFSC STATUS, 2, ACCESS
10924  D029     BRA 0x978
10926  0A01     XORLW 0x1
10928  B4D8     BTFSC STATUS, 2, ACCESS
1092A  D02E     BRA 0x988
1092C  D034     BRA 0x996
1092E  51B9     MOVF __pcstackBANK0, W, BANKED
10930  0A00     XORLW 0x0
10932  B4D8     BTFSC STATUS, 2, ACCESS
10934  D7A6     BRA 0x882
10936  0A01     XORLW 0x1
10938  B4D8     BTFSC STATUS, 2, ACCESS
1093A  D7AB     BRA 0x892
1093C  0A03     XORLW 0x3
1093E  B4D8     BTFSC STATUS, 2, ACCESS
10940  D7AE     BRA 0x89E
10942  0A01     XORLW 0x1
10944  B4D8     BTFSC STATUS, 2, ACCESS
10946  D7B1     BRA 0x8AA
10948  0A07     XORLW 0x7
1094A  B4D8     BTFSC STATUS, 2, ACCESS
1094C  D7B3     BRA 0x8B4
1094E  0A01     XORLW 0x1
10950  B4D8     BTFSC STATUS, 2, ACCESS
10952  D7B3     BRA 0x8BA
10954  0A03     XORLW 0x3
10956  B4D8     BTFSC STATUS, 2, ACCESS
10958  D7B9     BRA 0x8CC
1095A  0A01     XORLW 0x1
1095C  B4D8     BTFSC STATUS, 2, ACCESS
1095E  D7BC     BRA 0x8D8
10960  D01A     BRA 0x996
10962  51B9     MOVF __pcstackBANK0, W, BANKED
10964  0A01     XORLW 0x1
10966  B4D8     BTFSC STATUS, 2, ACCESS
10968  D7BC     BRA 0x8E2
1096A  0A03     XORLW 0x3
1096C  B4D8     BTFSC STATUS, 2, ACCESS
1096E  D7BB     BRA 0x8E6
10970  0A01     XORLW 0x1
10972  B4D8     BTFSC STATUS, 2, ACCESS
10974  D7BA     BRA 0x8EA
10976  D00F     BRA 0x996
10978  51B9     MOVF __pcstackBANK0, W, BANKED
1097A  0A00     XORLW 0x0
1097C  B4D8     BTFSC STATUS, 2, ACCESS
1097E  D7B7     BRA 0x8EE
10980  0A01     XORLW 0x1
10982  B4D8     BTFSC STATUS, 2, ACCESS
10984  D7B7     BRA 0x8F4
10986  D007     BRA 0x996
10988  51B9     MOVF __pcstackBANK0, W, BANKED
1098A  0A00     XORLW 0x0
1098C  B4D8     BTFSC STATUS, 2, ACCESS
1098E  D7B4     BRA 0x8F8
10990  0A01     XORLW 0x1
10992  B4D8     BTFSC STATUS, 2, ACCESS
10994  D7B5     BRA 0x900
366:           				case M_UU:
367:           					mouseReport.X = 0;
10882  0E00     MOVLW 0x0
10884  D00A     BRA 0x89A
368:           					mouseReport.Y = -1 * mouseSpeed;
10886  5044     MOVF mouseSpeed, W, ACCESS
10888  0D01     MULLW 0x1
1088A  50F3     MOVF PROD, W, ACCESS
1088C  0800     SUBLW 0x0
1088E  6E03     MOVWF 0x3, ACCESS
369:           					break;
10890  D082     BRA 0x996
370:           				case M_UL:
371:           					mouseReport.X = -1 * mouseSpeed;
10892  5044     MOVF mouseSpeed, W, ACCESS
10894  0D01     MULLW 0x1
10896  50F3     MOVF PROD, W, ACCESS
10898  0800     SUBLW 0x0
1089A  6E02     MOVWF 0x2, ACCESS
1089C  D7F4     BRA 0x886
372:           					mouseReport.Y = -1 * mouseSpeed;
373:           					break;
374:           				case M_LL:
375:           					mouseReport.X = -1 * mouseSpeed;
1089E  5044     MOVF mouseSpeed, W, ACCESS
108A0  0D01     MULLW 0x1
108A2  50F3     MOVF PROD, W, ACCESS
108A4  0800     SUBLW 0x0
108A6  6E02     MOVWF 0x2, ACCESS
376:           					mouseReport.Y = 0;
108A8  D015     BRA 0x8D4
377:           					break;
378:           				case M_DL:
379:           					mouseReport.X = -1 * mouseSpeed;
108AA  5044     MOVF mouseSpeed, W, ACCESS
108AC  0D01     MULLW 0x1
108AE  50F3     MOVF PROD, W, ACCESS
108B0  0800     SUBLW 0x0
108B2  D001     BRA 0x8B6
380:           					mouseReport.Y = 1 * mouseSpeed;
381:           					break;
382:           				case M_DD:
383:           					mouseReport.X = 0;
108B4  0E00     MOVLW 0x0
108B6  6E02     MOVWF 0x2, ACCESS
384:           					mouseReport.Y = 1 * mouseSpeed;
108B8  D004     BRA 0x8C2
385:           					break;
386:           				case M_DR:
387:           					mouseReport.X = 1 * mouseSpeed;
108BA  5044     MOVF mouseSpeed, W, ACCESS
108BC  0D01     MULLW 0x1
108BE  CFF3     MOVFF PROD, 0x2
108C0  F002     NOP
388:           					mouseReport.Y = 1 * mouseSpeed;
108C2  5044     MOVF mouseSpeed, W, ACCESS
108C4  0D01     MULLW 0x1
108C6  CFF3     MOVFF PROD, 0x3
108C8  F003     NOP
389:           					break;
108CA  D065     BRA 0x996
390:           				case M_RR:
391:           					mouseReport.X = 1 * mouseSpeed;
108CC  5044     MOVF mouseSpeed, W, ACCESS
108CE  0D01     MULLW 0x1
108D0  CFF3     MOVFF PROD, 0x2
108D2  F002     NOP
392:           					mouseReport.Y = 0;
108D4  0E00     MOVLW 0x0
108D6  D7DB     BRA 0x88E
393:           					break;
394:           				case M_UR:
395:           					mouseReport.X = 1 * mouseSpeed;
108D8  5044     MOVF mouseSpeed, W, ACCESS
108DA  0D01     MULLW 0x1
108DC  CFF3     MOVFF PROD, 0x2
108DE  F002     NOP
108E0  D7D2     BRA 0x886
396:           					mouseReport.Y = -1 * mouseSpeed;
397:           					break;
398:           				case CL_L:
399:           					mouseReport.mouseButton.bits.Left = 1;
108E2  8001     BSF mouseReport, 0, ACCESS
400:           					break;
108E4  D058     BRA 0x996
401:           				case CL_M:
402:           					mouseReport.mouseButton.bits.Middle = 1;
108E6  8401     BSF mouseReport, 2, ACCESS
403:           					break;
108E8  D056     BRA 0x996
404:           				case CL_R:
405:           					mouseReport.mouseButton.bits.Right = 1;
108EA  8201     BSF mouseReport, 1, ACCESS
406:           					break;
108EC  D054     BRA 0x996
407:           				case S_UP:
408:           					mouseReport.W = 1;
108EE  0E01     MOVLW 0x1
108F0  6E04     MOVWF 0x4, ACCESS
409:           					break;
108F2  D051     BRA 0x996
410:           				case S_DN:
411:           					mouseReport.W = -1;
108F4  6804     SETF 0x4, ACCESS
412:           					break;
108F6  D04F     BRA 0x996
413:           				case M_FT:
414:           					mouseSpeed = ((mouseSpeed << 1) | 1) & 0x7f;
108F8  80D8     BSF STATUS, 0, ACCESS
108FA  3444     RLCF mouseSpeed, W, ACCESS
108FC  0B7F     ANDLW 0x7F
108FE  D003     BRA 0x906
415:           					break;
416:           				case M_SW:
417:           					mouseSpeed = (mouseSpeed >> 1) | 1;
10900  3444     RLCF mouseSpeed, W, ACCESS
10902  3044     RRCF mouseSpeed, W, ACCESS
10904  0901     IORLW 0x1
10906  6E44     MOVWF mouseSpeed, ACCESS
418:           					break;
419:           			}
10908  D046     BRA 0x996
420:           			mainFlags.sendMouseReport = 1;
10996  8A11     BSF mainFlags, 5, ACCESS
421:           			break;
10998  0012     RETURN 0
422:           		case 0xf: //Special keyboard keys
423:           			switch (ttt) {
109D2  C0C0     MOVFF ttt, __pcstackBANK0
109D4  F0B9     NOP
109D6  C0C1     MOVFF 0xC1, 0xBA
109D8  F0BA     NOP
109DA  51BA     MOVF 0xBA, W, BANKED
109DC  0AF0     XORLW 0xF0
109DE  B4D8     BTFSC STATUS, 2, ACCESS
109E0  D004     BRA 0x9EA
109E2  0A0F     XORLW 0xF
109E4  A4D8     BTFSS STATUS, 2, ACCESS
109E6  0012     RETURN 0
109E8  D020     BRA 0xA2A
109EA  51B9     MOVF __pcstackBANK0, W, BANKED
109EC  0A00     XORLW 0x0
109EE  B4D8     BTFSC STATUS, 2, ACCESS
109F0  D7D4     BRA 0x99A
109F2  0A01     XORLW 0x1
109F4  B4D8     BTFSC STATUS, 2, ACCESS
109F6  D7D1     BRA 0x99A
109F8  0A03     XORLW 0x3
109FA  B4D8     BTFSC STATUS, 2, ACCESS
109FC  D7D6     BRA 0x9AA
109FE  0A01     XORLW 0x1
10A00  B4D8     BTFSC STATUS, 2, ACCESS
10A02  D7D6     BRA 0x9B0
10A04  0A07     XORLW 0x7
10A06  B4D8     BTFSC STATUS, 2, ACCESS
10A08  D7D6     BRA 0x9B6
10A0A  0A01     XORLW 0x1
10A0C  B4D8     BTFSC STATUS, 2, ACCESS
10A0E  D7D8     BRA 0x9C0
10A10  0A02     XORLW 0x2
10A12  B4D8     BTFSC STATUS, 2, ACCESS
10A14  D7CA     BRA 0x9AA
10A16  0A0F     XORLW 0xF
10A18  B4D8     BTFSC STATUS, 2, ACCESS
10A1A  D7C7     BRA 0x9AA
10A1C  0A01     XORLW 0x1
10A1E  B4D8     BTFSC STATUS, 2, ACCESS
10A20  D7C4     BRA 0x9AA
10A22  0A03     XORLW 0x3
10A24  A4D8     BTFSS STATUS, 2, ACCESS
10A26  0012     RETURN 0
10A28  D7D2     BRA 0x9CE
10A2A  51B9     MOVF __pcstackBANK0, W, BANKED
10A2C  0AFF     XORLW 0xFF
10A2E  A4D8     BTFSS STATUS, 2, ACCESS
10A32  D7C4     BRA 0x9BC
424:           				case FN_L:
425:           				case FN_R:
426:           					fnEnable = !fnEnable;
1099A  5189     MOVF fnEnable, W, BANKED
1099C  A4D8     BTFSS STATUS, 2, ACCESS
1099E  D002     BRA 0x9A4
109A0  0E01     MOVLW 0x1
109A2  D001     BRA 0x9A6
109A4  0E00     MOVLW 0x0
109A6  6F89     MOVWF fnEnable, BANKED
427:           					break;
109A8  0012     RETURN 0
428:           				case MEM1:
429:           				case MEM2:
430:           				case MEM3:
431:           				case MD_1:
432:           					keyMode = 0;
109AA  0E00     MOVLW 0x0
109AC  6F88     MOVWF keyMode, BANKED
433:           					break;
109AE  0012     RETURN 0
434:           				case MD_2:
435:           					keyMode = 1;
109B0  0E01     MOVLW 0x1
109B2  6F88     MOVWF keyMode, BANKED
436:           					break;
109B4  0012     RETURN 0
437:           				case MD_3:
438:           					keyMode = 2;
109B6  0E02     MOVLW 0x2
109B8  6F88     MOVWF keyMode, BANKED
439:           					break;
109BA  0012     RETURN 0
440:           				case BATT:
441:           					mainFlags.showBattery = 1;
109BC  8612     BSF 0x12, 3, ACCESS
442:           					break;
109BE  0012     RETURN 0
443:           				case CONN:
444:           					if (BtConnected) {
109C0  5187     MOVF BtConnected, W, BANKED
109C2  B4D8     BTFSC STATUS, 2, ACCESS
109C4  D002     BRA 0x9CA
445:           						mainFlags.disconnect = 1;
109C6  8212     BSF 0x12, 1, ACCESS
446:           					} else {
109C8  0012     RETURN 0
447:           						mainFlags.connect = 1;
109CA  8E11     BSF mainFlags, 7, ACCESS
448:           					}
449:           					break;
109CC  0012     RETURN 0
450:           				case SHDN:
451:           					mainFlags.shutdown = 1;
109CE  8C11     BSF mainFlags, 6, ACCESS
452:           					break;
453:           			}
109D0  0012     RETURN 0
454:           			break;
455:           	}
10A30  0012     RETURN 0
10A32  D7C4     BRA 0x9BC
10A34  C0C0     MOVFF ttt, __pcstackBANK0
10A36  F0B9     NOP
10A38  C0C1     MOVFF 0xC1, 0xBA
10A3A  F0BA     NOP
10A3C  0E0C     MOVLW 0xC
10A3E  6FBB     MOVWF sameCol, BANKED
10A40  90D8     BCF STATUS, 0, ACCESS
10A42  33BA     RRCF 0xBA, F, BANKED
10A44  33B9     RRCF __pcstackBANK0, F, BANKED
10A46  2FBB     DECFSZ sameCol, F, BANKED
10A48  D7FB     BRA 0xA40
10A4A  51BA     MOVF 0xBA, W, BANKED
10A4C  0A00     XORLW 0x0
10A4E  A4D8     BTFSS STATUS, 2, ACCESS
10A50  0012     RETURN 0
10A52  51B9     MOVF __pcstackBANK0, W, BANKED
10A54  0A00     XORLW 0x0
10A56  B4D8     BTFSC STATUS, 2, ACCESS
10A58  D6DA     BRA 0x80E
10A5A  0A01     XORLW 0x1
10A5C  B4D8     BTFSC STATUS, 2, ACCESS
10A5E  D6D9     BRA 0x812
10A60  0A03     XORLW 0x3
10A62  B4D8     BTFSC STATUS, 2, ACCESS
10A64  D6FA     BRA 0x85A
10A66  0A01     XORLW 0x1
10A68  B4D8     BTFSC STATUS, 2, ACCESS
10A6A  D74F     BRA 0x90A
10A6C  0A0C     XORLW 0xC
10A6E  A4D8     BTFSS STATUS, 2, ACCESS
10A70  0012     RETURN 0
10A72  D7AF     BRA 0x9D2
456:           }
457:           
458:           void swRelease(unsigned char n) {
1117C  0100     MOVLB 0x0
1117E  6FBF     MOVWF n, BANKED
459:           	unsigned short ttt = getKeyCode(n);
11180  0100     MOVLB 0x0
11182  51BF     MOVF n, W, BANKED
11184  0D02     MULLW 0x2
11186  5188     MOVF keyMode, W, BANKED
11188  6FB9     MOVWF __pcstackBANK0, BANKED
1118A  6BBA     CLRF 0xBA, BANKED
1118C  90D8     BCF STATUS, 0, ACCESS
1118E  37B9     RLCF __pcstackBANK0, F, BANKED
11190  37BA     RLCF 0xBA, F, BANKED
11192  5189     MOVF fnEnable, W, BANKED
11194  6FBB     MOVWF sameCol, BANKED
11196  6BBC     CLRF sameRow, BANKED
11198  51B9     MOVF __pcstackBANK0, W, BANKED
1119A  27BB     ADDWF sameCol, F, BANKED
1119C  51BA     MOVF 0xBA, W, BANKED
1119E  23BC     ADDWFC sameRow, F, BANKED
111A0  90D8     BCF STATUS, 0, ACCESS
111A2  37BB     RLCF sameCol, F, BANKED
111A4  37BC     RLCF sameRow, F, BANKED
111A6  0EE6     MOVLW 0xE6
111A8  25BB     ADDWF sameCol, W, BANKED
111AA  6ED9     MOVWF FSR2, ACCESS
111AC  0E00     MOVLW 0x0
111AE  21BC     ADDWFC sameRow, W, BANKED
111B0  6EDA     MOVWF FSR2H, ACCESS
111B2  CFDE     MOVFF POSTINC2, n
111B4  F0BD     NOP
111B6  CFDD     MOVFF POSTDEC2, d
111B8  F0BE     NOP
111BA  50F3     MOVF PROD, W, ACCESS
111BC  27BD     ADDWF n, F, BANKED
111BE  50F4     MOVF PRODH, W, ACCESS
111C0  23BE     ADDWFC d, F, BANKED
111C2  C0BD     MOVFF n, TBLPTR
111C4  FFF6     NOP
111C6  C0BE     MOVFF d, TBLPTRH
111C8  FFF7     NOP
111CA  0E00     MOVLW 0x0
111CC  6EF8     MOVWF TBLPTRU, ACCESS
111CE  0009     TBLRD*+
111D0  CFF5     MOVFF TABLAT, ttt
111D2  F0C0     NOP
111D4  000A     TBLRD*-
111D6  CFF5     MOVFF TABLAT, 0xC1
111D8  F0C1     NOP
460:           	switch (ttt >> 12) {
111DA  D067     BRA 0x12AA
112AA  C0C0     MOVFF ttt, __pcstackBANK0
461:           		case 0x0: //Normal keys
462:           			mainFlags.sendKeyReport = 1;
111DC  8611     BSF mainFlags, 3, ACCESS
463:           			break;
111DE  0012     RETURN 0
464:           		case 0x1: //Modifier keys
465:           			mainFlags.sendKeyReport = 1;
111E0  8611     BSF mainFlags, 3, ACCESS
466:           			break;
111E2  0012     RETURN 0
467:           		case 0x2: //Consumer report keys
468:           			consumerKey &= ~(0x01 << (unsigned char) ttt);
111E4  C0C0     MOVFF ttt, __pcstackBANK0
111E6  F0B9     NOP
111E8  0E01     MOVLW 0x1
111EA  6FBA     MOVWF 0xBA, BANKED
111EC  0E00     MOVLW 0x0
111EE  6FBB     MOVWF sameCol, BANKED
111F0  2BB9     INCF __pcstackBANK0, F, BANKED
111F2  D003     BRA 0x11FA
111F4  90D8     BCF STATUS, 0, ACCESS
111F6  37BA     RLCF 0xBA, F, BANKED
111F8  37BB     RLCF sameCol, F, BANKED
111FA  2FB9     DECFSZ __pcstackBANK0, F, BANKED
111FC  D7FB     BRA 0x11F4
111FE  0100     MOVLB 0x0
11200  1DBA     COMF 0xBA, W, BANKED
11202  6FBC     MOVWF sameRow, BANKED
11204  1DBB     COMF sameCol, W, BANKED
11206  6FBD     MOVWF n, BANKED
11208  51BC     MOVF sameRow, W, BANKED
1120A  1785     ANDWF consumerKey, F, BANKED
1120C  51BD     MOVF n, W, BANKED
1120E  1786     ANDWF 0x86, F, BANKED
469:           			//		consumerKey = 0;
470:           			mainFlags.sendComsumerKeyReport = 1;
11210  8411     BSF mainFlags, 2, ACCESS
471:           			break;
11212  0012     RETURN 0
472:           		case 0x3: //Mouse keys
473:           			switch (ttt) {
11230  C0C0     MOVFF ttt, __pcstackBANK0
11232  F0B9     NOP
11234  C0C1     MOVFF 0xC1, 0xBA
11236  F0BA     NOP
11238  51BA     MOVF 0xBA, W, BANKED
1123A  0A30     XORLW 0x30
1123C  B4D8     BTFSC STATUS, 2, ACCESS
1123E  D007     BRA 0x124E
11240  0A01     XORLW 0x1
11242  B4D8     BTFSC STATUS, 2, ACCESS
11244  D01E     BRA 0x1282
11246  0A03     XORLW 0x3
11248  B4D8     BTFSC STATUS, 2, ACCESS
1124A  D026     BRA 0x1298
1124C  D02C     BRA 0x12A6
1124E  51B9     MOVF __pcstackBANK0, W, BANKED
11250  0A00     XORLW 0x0
11252  B4D8     BTFSC STATUS, 2, ACCESS
11254  D7DF     BRA 0x1214
11256  0A01     XORLW 0x1
11258  B4D8     BTFSC STATUS, 2, ACCESS
1125A  D7DC     BRA 0x1214
1125C  0A03     XORLW 0x3
1125E  B4D8     BTFSC STATUS, 2, ACCESS
11260  D7D9     BRA 0x1214
11262  0A01     XORLW 0x1
11264  B4D8     BTFSC STATUS, 2, ACCESS
11266  D7D6     BRA 0x1214
11268  0A07     XORLW 0x7
1126A  B4D8     BTFSC STATUS, 2, ACCESS
1126C  D7D3     BRA 0x1214
1126E  0A01     XORLW 0x1
11270  B4D8     BTFSC STATUS, 2, ACCESS
11272  D7D0     BRA 0x1214
11274  0A03     XORLW 0x3
11276  B4D8     BTFSC STATUS, 2, ACCESS
11278  D7CD     BRA 0x1214
1127A  0A01     XORLW 0x1
1127C  B4D8     BTFSC STATUS, 2, ACCESS
1127E  D7CA     BRA 0x1214
11280  D012     BRA 0x12A6
11282  51B9     MOVF __pcstackBANK0, W, BANKED
11284  0A01     XORLW 0x1
11286  B4D8     BTFSC STATUS, 2, ACCESS
11288  D7CA     BRA 0x121E
1128A  0A03     XORLW 0x3
1128C  B4D8     BTFSC STATUS, 2, ACCESS
1128E  D7C9     BRA 0x1222
11290  0A01     XORLW 0x1
11292  B4D8     BTFSC STATUS, 2, ACCESS
11294  D7C8     BRA 0x1226
11296  D007     BRA 0x12A6
11298  51B9     MOVF __pcstackBANK0, W, BANKED
1129A  0A00     XORLW 0x0
1129C  B4D8     BTFSC STATUS, 2, ACCESS
1129E  D7C5     BRA 0x122A
112A0  0A01     XORLW 0x1
112A2  B4D8     BTFSC STATUS, 2, ACCESS
112A4  D7C2     BRA 0x122A
474:           				case M_UU:
475:           				case M_UL:
476:           				case M_LL:
477:           				case M_DL:
478:           				case M_DD:
479:           				case M_DR:
480:           				case M_RR:
481:           				case M_UR:
482:           					mouseReport.X = 0;
11214  0E00     MOVLW 0x0
11216  6E02     MOVWF 0x2, ACCESS
483:           					mouseReport.Y = 0;
11218  0E00     MOVLW 0x0
1121A  6E03     MOVWF 0x3, ACCESS
484:           					break;
1121C  D044     BRA 0x12A6
485:           				case CL_L:
486:           					mouseReport.mouseButton.bits.Left = 0;
1121E  9001     BCF mouseReport, 0, ACCESS
487:           					break;
11220  D042     BRA 0x12A6
488:           				case CL_M:
489:           					mouseReport.mouseButton.bits.Middle = 0;
11222  9401     BCF mouseReport, 2, ACCESS
490:           					break;
11224  D040     BRA 0x12A6
491:           				case CL_R:
492:           					mouseReport.mouseButton.bits.Right = 0;
11226  9201     BCF mouseReport, 1, ACCESS
493:           					break;
11228  D03E     BRA 0x12A6
494:           				case S_UP:
495:           				case S_DN:
496:           					mouseReport.W = 0;
1122A  0E00     MOVLW 0x0
1122C  6E04     MOVWF 0x4, ACCESS
497:           					break;
498:           			}
1122E  D03B     BRA 0x12A6
499:           			mainFlags.sendMouseReport = 1;
112A6  8A11     BSF mainFlags, 5, ACCESS
500:           			break;
501:           	}
112A8  0012     RETURN 0
112AA  C0C0     MOVFF ttt, __pcstackBANK0
112AC  F0B9     NOP
112AE  C0C1     MOVFF 0xC1, 0xBA
112B0  F0BA     NOP
112B2  0E0C     MOVLW 0xC
112B4  6FBB     MOVWF sameCol, BANKED
112B6  90D8     BCF STATUS, 0, ACCESS
112B8  33BA     RRCF 0xBA, F, BANKED
112BA  33B9     RRCF __pcstackBANK0, F, BANKED
112BC  2FBB     DECFSZ sameCol, F, BANKED
112BE  D7FB     BRA 0x12B6
112C0  51BA     MOVF 0xBA, W, BANKED
112C2  0A00     XORLW 0x0
112C4  A4D8     BTFSS STATUS, 2, ACCESS
112C6  0012     RETURN 0
112C8  51B9     MOVF __pcstackBANK0, W, BANKED
112CA  0A00     XORLW 0x0
112CC  B4D8     BTFSC STATUS, 2, ACCESS
112CE  D786     BRA 0x11DC
112D0  0A01     XORLW 0x1
112D2  B4D8     BTFSC STATUS, 2, ACCESS
112D4  D785     BRA 0x11E0
112D6  0A03     XORLW 0x3
112D8  B4D8     BTFSC STATUS, 2, ACCESS
112DA  D784     BRA 0x11E4
112DC  0A01     XORLW 0x1
112DE  A4D8     BTFSS STATUS, 2, ACCESS
112E0  0012     RETURN 0
112E2  D7A6     BRA 0x1230
502:           }
503:           
504:           void setScanCodes(void) {
505:           	unsigned char c = firstPush;
10E72  C043     MOVFF firstPush, c
10E74  F1DC     NOP
506:           	unsigned char d = 0;
10E76  0E00     MOVLW 0x0
10E78  0101     MOVLB 0x1
10E7A  6FDD     MOVWF 0xDD, BANKED
507:           
508:           	while (c != 0xff && d < 6) {
10E7C  D0AA     BRA 0xFD2
509:           		if (mSw[c].state) {
10E7E  51DC     MOVF 0xDC, W, BANKED
10E80  0D05     MULLW 0x5
10E82  0E01     MOVLW 0x1
10E84  26F3     ADDWF PROD, F, ACCESS
10E86  0E00     MOVLW 0x0
10E88  22F4     ADDWFC PRODH, F, ACCESS
10E8A  0E00     MOVLW 0x0
10E8C  24F3     ADDWF PROD, W, ACCESS
10E8E  6ED9     MOVWF FSR2, ACCESS
10E90  0E01     MOVLW 0x1
10E92  20F4     ADDWFC PRODH, W, ACCESS
10E94  6EDA     MOVWF FSR2H, ACCESS
10E96  50DF     MOVF INDF2, W, ACCESS
10E98  B4D8     BTFSC STATUS, 2, ACCESS
10E9A  D08D     BRA 0xFB6
510:           			if ((getKeyCode(mSw[c].num) >> 12) == 0x0) {
10E9C  51DC     MOVF 0xDC, W, BANKED
10E9E  0D05     MULLW 0x5
10EA0  0E02     MOVLW 0x2
10EA2  26F3     ADDWF PROD, F, ACCESS
10EA4  0E00     MOVLW 0x0
10EA6  22F4     ADDWFC PRODH, F, ACCESS
10EA8  0E00     MOVLW 0x0
10EAA  24F3     ADDWF PROD, W, ACCESS
10EAC  6ED9     MOVWF FSR2, ACCESS
10EAE  0E01     MOVLW 0x1
10EB0  20F4     ADDWFC PRODH, W, ACCESS
10EB2  6EDA     MOVWF FSR2H, ACCESS
10EB4  50DF     MOVF INDF2, W, ACCESS
10EB6  6FD2     MOVWF 0xD2, BANKED
10EB8  51D2     MOVF 0xD2, W, BANKED
10EBA  0D02     MULLW 0x2
10EBC  0100     MOVLB 0x0
10EBE  5188     MOVF keyMode, W, BANKED
10EC0  0101     MOVLB 0x1
10EC2  6FD3     MOVWF 0xD3, BANKED
10EC4  6BD4     CLRF 0xD4, BANKED
10EC6  90D8     BCF STATUS, 0, ACCESS
10EC8  37D3     RLCF 0xD3, F, BANKED
10ECA  37D4     RLCF 0xD4, F, BANKED
10ECC  0100     MOVLB 0x0
10ECE  5189     MOVF fnEnable, W, BANKED
10ED0  0101     MOVLB 0x1
10ED2  6FD5     MOVWF 0xD5, BANKED
10ED4  6BD6     CLRF 0xD6, BANKED
10ED6  51D3     MOVF 0xD3, W, BANKED
10ED8  27D5     ADDWF 0xD5, F, BANKED
10EDA  51D4     MOVF 0xD4, W, BANKED
10EDC  23D6     ADDWFC 0xD6, F, BANKED
10EDE  90D8     BCF STATUS, 0, ACCESS
10EE0  37D5     RLCF 0xD5, F, BANKED
10EE2  37D6     RLCF 0xD6, F, BANKED
10EE4  0EE6     MOVLW 0xE6
10EE6  25D5     ADDWF 0xD5, W, BANKED
10EE8  6ED9     MOVWF FSR2, ACCESS
10EEA  0E00     MOVLW 0x0
10EEC  21D6     ADDWFC 0xD6, W, BANKED
10EEE  6EDA     MOVWF FSR2H, ACCESS
10EF0  CFDE     MOVFF POSTINC2, d
10EF2  F1D7     NOP
10EF4  CFDD     MOVFF POSTDEC2, d
10EF6  F1D8     NOP
10EF8  50F3     MOVF PROD, W, ACCESS
10EFA  27D7     ADDWF 0xD7, F, BANKED
10EFC  50F4     MOVF PRODH, W, ACCESS
10EFE  23D8     ADDWFC 0xD8, F, BANKED
10F00  C1D7     MOVFF d, TBLPTR
10F02  FFF6     NOP
10F04  C1D8     MOVFF d, TBLPTRH
10F06  FFF7     NOP
10F08  0E00     MOVLW 0x0
10F0A  6EF8     MOVWF TBLPTRU, ACCESS
10F0C  0009     TBLRD*+
10F0E  CFF5     MOVFF TABLAT, 0x1D9
10F10  F1D9     NOP
10F12  0009     TBLRD*+
10F14  CFF5     MOVFF TABLAT, product
10F16  F1DA     NOP
10F18  0E0C     MOVLW 0xC
10F1A  6FDB     MOVWF 0xDB, BANKED
10F1C  90D8     BCF STATUS, 0, ACCESS
10F1E  33DA     RRCF 0xDA, F, BANKED
10F20  33D9     RRCF 0xD9, F, BANKED
10F22  2FDB     DECFSZ 0xDB, F, BANKED
10F24  D7FB     BRA 0xF1C
10F26  51D9     MOVF 0xD9, W, BANKED
10F28  11DA     IORWF 0xDA, W, BANKED
10F2A  A4D8     BTFSS STATUS, 2, ACCESS
10F2C  D044     BRA 0xFB6
511:           				keyReport.scanCodes[d] = getKeyCode(mSw[c].num);
10F2E  51DC     MOVF 0xDC, W, BANKED
10F30  0D05     MULLW 0x5
10F32  0E02     MOVLW 0x2
10F34  26F3     ADDWF PROD, F, ACCESS
10F36  0E00     MOVLW 0x0
10F38  22F4     ADDWFC PRODH, F, ACCESS
10F3A  0E00     MOVLW 0x0
10F3C  24F3     ADDWF PROD, W, ACCESS
10F3E  6ED9     MOVWF FSR2, ACCESS
10F40  0E01     MOVLW 0x1
10F42  20F4     ADDWFC PRODH, W, ACCESS
10F44  6EDA     MOVWF FSR2H, ACCESS
10F46  50DF     MOVF INDF2, W, ACCESS
10F48  6FD2     MOVWF 0xD2, BANKED
10F4A  51D2     MOVF 0xD2, W, BANKED
10F4C  0D02     MULLW 0x2
10F4E  0100     MOVLB 0x0
10F50  5188     MOVF keyMode, W, BANKED
10F52  0101     MOVLB 0x1
10F54  6FD3     MOVWF 0xD3, BANKED
10F56  6BD4     CLRF 0xD4, BANKED
10F58  90D8     BCF STATUS, 0, ACCESS
10F5A  37D3     RLCF 0xD3, F, BANKED
10F5C  37D4     RLCF 0xD4, F, BANKED
10F5E  0100     MOVLB 0x0
10F60  5189     MOVF fnEnable, W, BANKED
10F62  0101     MOVLB 0x1
10F64  6FD5     MOVWF 0xD5, BANKED
10F66  6BD6     CLRF 0xD6, BANKED
10F68  51D3     MOVF 0xD3, W, BANKED
10F6A  27D5     ADDWF 0xD5, F, BANKED
10F6C  51D4     MOVF 0xD4, W, BANKED
10F6E  23D6     ADDWFC 0xD6, F, BANKED
10F70  90D8     BCF STATUS, 0, ACCESS
10F72  37D5     RLCF 0xD5, F, BANKED
10F74  37D6     RLCF 0xD6, F, BANKED
10F76  0EE6     MOVLW 0xE6
10F78  25D5     ADDWF 0xD5, W, BANKED
10F7A  6ED9     MOVWF FSR2, ACCESS
10F7C  0E00     MOVLW 0x0
10F7E  21D6     ADDWFC 0xD6, W, BANKED
10F80  6EDA     MOVWF FSR2H, ACCESS
10F82  CFDE     MOVFF POSTINC2, d
10F84  F1D7     NOP
10F86  CFDD     MOVFF POSTDEC2, d
10F88  F1D8     NOP
10F8A  50F3     MOVF PROD, W, ACCESS
10F8C  27D7     ADDWF 0xD7, F, BANKED
10F8E  50F4     MOVF PRODH, W, ACCESS
10F90  23D8     ADDWFC 0xD8, F, BANKED
10F92  C1D7     MOVFF d, TBLPTR
10F94  FFF6     NOP
10F96  C1D8     MOVFF d, TBLPTRH
10F98  FFF7     NOP
10F9A  0E00     MOVLW 0x0
10F9C  6EF8     MOVWF TBLPTRU, ACCESS
10F9E  51DD     MOVF 0xDD, W, BANKED
10FA0  0D01     MULLW 0x1
10FA2  0E79     MOVLW 0x79
10FA4  24F3     ADDWF PROD, W, ACCESS
10FA6  6ED9     MOVWF FSR2, ACCESS
10FA8  0E00     MOVLW 0x0
10FAA  20F4     ADDWFC PRODH, W, ACCESS
10FAC  6EDA     MOVWF FSR2H, ACCESS
10FAE  0008     TBLRD*
10FB0  CFF5     MOVFF TABLAT, INDF2
10FB2  FFDF     NOP
512:           				d++;
10FB4  2BDD     INCF 0xDD, F, BANKED
513:           			}
514:           		}
515:           		c = mSw[c].next;
10FB6  51DC     MOVF 0xDC, W, BANKED
10FB8  0D05     MULLW 0x5
10FBA  0E04     MOVLW 0x4
10FBC  26F3     ADDWF PROD, F, ACCESS
10FBE  0E00     MOVLW 0x0
10FC0  22F4     ADDWFC PRODH, F, ACCESS
10FC2  0E00     MOVLW 0x0
10FC4  24F3     ADDWF PROD, W, ACCESS
10FC6  6ED9     MOVWF FSR2, ACCESS
10FC8  0E01     MOVLW 0x1
10FCA  20F4     ADDWFC PRODH, W, ACCESS
10FCC  6EDA     MOVWF FSR2H, ACCESS
10FCE  50DF     MOVF INDF2, W, ACCESS
10FD0  6FDC     MOVWF 0xDC, BANKED
516:           	}
10FD2  29DC     INCF 0xDC, W, BANKED
10FD4  B4D8     BTFSC STATUS, 2, ACCESS
10FD6  D003     BRA 0xFDE
10FD8  0E05     MOVLW 0x5
10FDA  65DD     CPFSGT 0xDD, BANKED
10FDC  D750     BRA 0xE7E
517:           
518:           	//0 fill
519:           	for (; d < 6; d++) {
10FDE  0E05     MOVLW 0x5
10FE0  65DD     CPFSGT 0xDD, BANKED
10FE2  D001     BRA 0xFE6
10FE4  0012     RETURN 0
10FFA  2BDD     INCF 0xDD, F, BANKED
520:           		keyReport.scanCodes[d] = 0;
10FE6  51DD     MOVF 0xDD, W, BANKED
10FE8  0D01     MULLW 0x1
10FEA  0E79     MOVLW 0x79
10FEC  24F3     ADDWF PROD, W, ACCESS
10FEE  6ED9     MOVWF FSR2, ACCESS
10FF0  0E00     MOVLW 0x0
10FF2  20F4     ADDWFC PRODH, W, ACCESS
10FF4  6EDA     MOVWF FSR2H, ACCESS
10FF6  0E00     MOVLW 0x0
10FF8  6EDF     MOVWF INDF2, ACCESS
10FFA  2BDD     INCF 0xDD, F, BANKED
10FFC  D7F0     BRA 0xFDE
521:           	}
522:           }
523:           
524:           void swProcess(void) {
525:           	//call this function from high_isr interrupts
526:           	unsigned char c;
527:           	unsigned char row;
528:           	//	unsigned char countOfPushing = 0;
529:           
530:           	LATC = 0x00;
104C2  0E00     MOVLW 0x0
104C4  6E7B     MOVWF LATC, ACCESS
531:           	Nop();
104C6  F000     NOP
532:           
533:           	if (swInput) {
104C8  0EFF     MOVLW 0xFF
104CA  0100     MOVLB 0x0
104CC  6FC4     MOVWF 0xC4, BANKED
104CE  0E0F     MOVLW 0xF
104D0  6FC5     MOVWF 0xC5, BANKED
104D2  508D     MOVF PORTE, W, ACCESS
104D4  0D01     MULLW 0x1
104D6  0E3B     MOVLW 0x3B
104D8  24F3     ADDWF PROD, W, ACCESS
104DA  6EF6     MOVWF TBLPTR, ACCESS
104DC  0EFA     MOVLW 0xFA
104DE  20F4     ADDWFC PRODH, W, ACCESS
104E0  6EF7     MOVWF TBLPTRH, ACCESS
104E2  6AF8     CLRF TBLPTRU, ACCESS
104E4  0E00     MOVLW 0x0
104E6  22F8     ADDWFC TBLPTRU, F, ACCESS
104E8  0008     TBLRD*
104EA  50F5     MOVF TABLAT, W, ACCESS
104EC  6FC7     MOVWF 0xC7, BANKED
104EE  6BC6     CLRF 0xC6, BANKED
104F0  508A     MOVF PORTB, W, ACCESS
104F2  0D01     MULLW 0x1
104F4  0E3B     MOVLW 0x3B
104F6  24F3     ADDWF PROD, W, ACCESS
104F8  6EF6     MOVWF TBLPTR, ACCESS
104FA  0EFA     MOVLW 0xFA
104FC  20F4     ADDWFC PRODH, W, ACCESS
104FE  6EF7     MOVWF TBLPTRH, ACCESS
10500  6AF8     CLRF TBLPTRU, ACCESS
10502  0E00     MOVLW 0x0
10504  22F8     ADDWFC TBLPTRU, F, ACCESS
10506  0008     TBLRD*
10508  50F5     MOVF TABLAT, W, ACCESS
1050A  13C6     IORWF 0xC6, F, BANKED
1050C  0E00     MOVLW 0x0
1050E  13C7     IORWF 0xC7, F, BANKED
10510  1DC6     COMF 0xC6, W, BANKED
10512  6FC8     MOVWF 0xC8, BANKED
10514  1DC7     COMF 0xC7, W, BANKED
10516  6FC9     MOVWF 0xC9, BANKED
10518  51C4     MOVF 0xC4, W, BANKED
1051A  17C8     ANDWF 0xC8, F, BANKED
1051C  51C5     MOVF 0xC5, W, BANKED
1051E  17C9     ANDWF 0xC9, F, BANKED
10520  51C8     MOVF 0xC8, W, BANKED
10522  11C9     IORWF 0xC9, W, BANKED
10524  B4D8     BTFSC STATUS, 2, ACCESS
10526  D081     BRA 0x62A
534:           		//switch(es) is(are) ON
535:           		for (row = 0; row < N_ROW; row++) {
10528  0E00     MOVLW 0x0
1052A  6FCD     MOVWF row, BANKED
1052C  0E05     MOVLW 0x5
1052E  65CD     CPFSGT row, BANKED
10530  D001     BRA 0x534
10532  D051     BRA 0x5D6
105D2  2BCD     INCF row, F, BANKED
105D4  D7AB     BRA 0x52C
536:           			LATC = 0xff;
10534  687B     SETF LATC, ACCESS
537:           			
538:           #ifdef MicroQWERTY
539:           			TRISB &= 0x00;
10536  0E00     MOVLW 0x0
10538  6E82     MOVWF TRISB, ACCESS
540:           			TRISE &= 0x0f;
1053A  0E0F     MOVLW 0xF
1053C  1685     ANDWF TRISE, F, ACCESS
541:           			TRISB |= 0xff;
1053E  6882     SETF TRISB, ACCESS
542:           			TRISE |= 0xf0;
10540  0EF0     MOVLW 0xF0
10542  1285     IORWF TRISE, F, ACCESS
543:           #else
544:           			TRISE &= 0x07;
545:           			TRISB |= 0xf8;
546:           #endif
547:           			LATC = rowTable[row];
10544  51CD     MOVF row, W, BANKED
10546  0D01     MULLW 0x1
10548  0E63     MOVLW 0x63
1054A  24F3     ADDWF PROD, W, ACCESS
1054C  6EF6     MOVWF TBLPTR, ACCESS
1054E  0EFB     MOVLW 0xFB
10550  20F4     ADDWFC PRODH, W, ACCESS
10552  6EF7     MOVWF TBLPTRH, ACCESS
10554  6AF8     CLRF TBLPTRU, ACCESS
10556  0E00     MOVLW 0x0
10558  22F8     ADDWFC TBLPTRU, F, ACCESS
1055A  0008     TBLRD*
1055C  CFF5     MOVFF TABLAT, LATC
1055E  FF7B     NOP
548:           			Nop();
10560  F000     NOP
549:           			sw[row] = swInput;
10562  0EFF     MOVLW 0xFF
10564  0100     MOVLB 0x0
10566  6FC4     MOVWF 0xC4, BANKED
10568  0E0F     MOVLW 0xF
1056A  6FC5     MOVWF 0xC5, BANKED
1056C  508D     MOVF PORTE, W, ACCESS
1056E  0D01     MULLW 0x1
10570  0E3B     MOVLW 0x3B
10572  24F3     ADDWF PROD, W, ACCESS
10574  6EF6     MOVWF TBLPTR, ACCESS
10576  0EFA     MOVLW 0xFA
10578  20F4     ADDWFC PRODH, W, ACCESS
1057A  6EF7     MOVWF TBLPTRH, ACCESS
1057C  6AF8     CLRF TBLPTRU, ACCESS
1057E  0E00     MOVLW 0x0
10580  22F8     ADDWFC TBLPTRU, F, ACCESS
10582  0008     TBLRD*
10584  50F5     MOVF TABLAT, W, ACCESS
10586  6FC7     MOVWF 0xC7, BANKED
10588  6BC6     CLRF 0xC6, BANKED
1058A  508A     MOVF PORTB, W, ACCESS
1058C  0D01     MULLW 0x1
1058E  0E3B     MOVLW 0x3B
10590  24F3     ADDWF PROD, W, ACCESS
10592  6EF6     MOVWF TBLPTR, ACCESS
10594  0EFA     MOVLW 0xFA
10596  20F4     ADDWFC PRODH, W, ACCESS
10598  6EF7     MOVWF TBLPTRH, ACCESS
1059A  6AF8     CLRF TBLPTRU, ACCESS
1059C  0E00     MOVLW 0x0
1059E  22F8     ADDWFC TBLPTRU, F, ACCESS
105A0  0008     TBLRD*
105A2  50F5     MOVF TABLAT, W, ACCESS
105A4  13C6     IORWF 0xC6, F, BANKED
105A6  0E00     MOVLW 0x0
105A8  13C7     IORWF 0xC7, F, BANKED
105AA  1DC6     COMF 0xC6, W, BANKED
105AC  6FC8     MOVWF 0xC8, BANKED
105AE  1DC7     COMF 0xC7, W, BANKED
105B0  6FC9     MOVWF 0xC9, BANKED
105B2  51C4     MOVF 0xC4, W, BANKED
105B4  17C8     ANDWF 0xC8, F, BANKED
105B6  51C5     MOVF 0xC5, W, BANKED
105B8  17C9     ANDWF 0xC9, F, BANKED
105BA  51CD     MOVF row, W, BANKED
105BC  0D02     MULLW 0x2
105BE  0E60     MOVLW 0x60
105C0  24F3     ADDWF PROD, W, ACCESS
105C2  6ED9     MOVWF FSR2, ACCESS
105C4  0E00     MOVLW 0x0
105C6  20F4     ADDWFC PRODH, W, ACCESS
105C8  6EDA     MOVWF FSR2H, ACCESS
105CA  C0C8     MOVFF 0xC8, POSTINC2
105CC  FFDE     NOP
105CE  C0C9     MOVFF 0xC9, POSTDEC2
105D0  FFDD     NOP
550:           		}
551:           
552:           		LATC = 0x00;
105D6  0E00     MOVLW 0x0
105D8  6E7B     MOVWF LATC, ACCESS
553:           		//		IOCBF = 0x00;
554:           		//		IOCEF = 0x00;
555:           
556:           		for (row = 0; row < N_ROW; row++) {
105DA  0E00     MOVLW 0x0
105DC  6FCD     MOVWF row, BANKED
105DE  0E05     MOVLW 0x5
105E0  65CD     CPFSGT row, BANKED
105E2  D001     BRA 0x5E6
105E4  D036     BRA 0x652
10626  2BCD     INCF row, F, BANKED
10628  D7DA     BRA 0x5DE
557:           			unsigned short sw2 = sw[row];
105E6  51CD     MOVF row, W, BANKED
105E8  0D02     MULLW 0x2
105EA  0E60     MOVLW 0x60
105EC  24F3     ADDWF PROD, W, ACCESS
105EE  6ED9     MOVWF FSR2, ACCESS
105F0  0E00     MOVLW 0x0
105F2  20F4     ADDWFC PRODH, W, ACCESS
105F4  6EDA     MOVWF FSR2H, ACCESS
105F6  CFDE     MOVFF POSTINC2, sw2
105F8  F0CB     NOP
105FA  CFDD     MOVFF POSTDEC2, 0xCC
105FC  F0CC     NOP
558:           			unsigned char col = 0;
105FE  0E00     MOVLW 0x0
10600  6FCA     MOVWF col, BANKED
559:           			while (sw2) {
10602  D00D     BRA 0x61E
560:           				if (sw2 & 1) {
10604  A1CB     BTFSS sw2, 0, BANKED
10606  D006     BRA 0x614
561:           					swRegister(row * 16 + col);
10608  51CD     MOVF row, W, BANKED
1060A  0D10     MULLW 0x10
1060C  50F3     MOVF PROD, W, ACCESS
1060E  25CA     ADDWF col, W, BANKED
10610  EC3A     CALL 0x10A74, 0
10612  F085     NOP
562:           				}
563:           				sw2 >>= 1;
10614  0100     MOVLB 0x0
10616  90D8     BCF STATUS, 0, ACCESS
10618  33CC     RRCF 0xCC, F, BANKED
1061A  33CB     RRCF sw2, F, BANKED
564:           				col++;
1061C  2BCA     INCF col, F, BANKED
565:           			}
1061E  51CB     MOVF sw2, W, BANKED
10620  11CC     IORWF 0xCC, W, BANKED
10622  A4D8     BTFSS STATUS, 2, ACCESS
10624  D7EF     BRA 0x604
566:           		}
567:           	} else {
568:           		//all switches are OFF
569:           		for (row = 0; row < N_ROW; row++) {
1062A  0E00     MOVLW 0x0
1062C  6FCD     MOVWF row, BANKED
1062E  0E05     MOVLW 0x5
10630  65CD     CPFSGT row, BANKED
10632  D001     BRA 0x636
10634  D00E     BRA 0x652
1064E  2BCD     INCF row, F, BANKED
10650  D7EE     BRA 0x62E
570:           			sw[row] = 0x0000;
10636  51CD     MOVF row, W, BANKED
10638  0D02     MULLW 0x2
1063A  0E60     MOVLW 0x60
1063C  24F3     ADDWF PROD, W, ACCESS
1063E  6ED9     MOVWF FSR2, ACCESS
10640  0E00     MOVLW 0x0
10642  20F4     ADDWFC PRODH, W, ACCESS
10644  6EDA     MOVWF FSR2H, ACCESS
10646  0E00     MOVLW 0x0
10648  6EDE     MOVWF POSTINC2, ACCESS
1064A  0E00     MOVLW 0x0
1064C  6EDD     MOVWF POSTDEC2, ACCESS
571:           		}
572:           	}
573:           
574:           	for (c = 0; c < N_PUSHABLE; c++) {
10652  0E00     MOVLW 0x0
10654  6FCE     MOVWF c, BANKED
10656  0E09     MOVLW 0x9
10658  65CE     CPFSGT c, BANKED
1065A  D001     BRA 0x65E
1065C  0012     RETURN 0
575:           		if (mSw[c].num != 0xff) {
1065E  51CE     MOVF c, W, BANKED
10660  0D05     MULLW 0x5
10662  0E02     MOVLW 0x2
10664  26F3     ADDWF PROD, F, ACCESS
10666  0E00     MOVLW 0x0
10668  22F4     ADDWFC PRODH, F, ACCESS
1066A  0E00     MOVLW 0x0
1066C  24F3     ADDWF PROD, W, ACCESS
1066E  6ED9     MOVWF FSR2, ACCESS
10670  0E01     MOVLW 0x1
10672  20F4     ADDWFC PRODH, W, ACCESS
10674  6EDA     MOVWF FSR2H, ACCESS
10676  28DE     INCF POSTINC2, W, ACCESS
10678  B4D8     BTFSC STATUS, 2, ACCESS
1067A  D096     BRA 0x7A8
576:           			if ((sw[mSw[c].num >> 4] >> (mSw[c].num & 0x0f))& 1) //ON
1067C  51CE     MOVF c, W, BANKED
1067E  0D05     MULLW 0x5
10680  0E02     MOVLW 0x2
10682  26F3     ADDWF PROD, F, ACCESS
10684  0E00     MOVLW 0x0
10686  22F4     ADDWFC PRODH, F, ACCESS
10688  0E00     MOVLW 0x0
1068A  24F3     ADDWF PROD, W, ACCESS
1068C  6ED9     MOVWF FSR2, ACCESS
1068E  0E01     MOVLW 0x1
10690  20F4     ADDWFC PRODH, W, ACCESS
10692  6EDA     MOVWF FSR2H, ACCESS
10694  50DF     MOVF INDF2, W, ACCESS
10696  6FC4     MOVWF 0xC4, BANKED
10698  0E0F     MOVLW 0xF
1069A  17C4     ANDWF 0xC4, F, BANKED
1069C  51CE     MOVF c, W, BANKED
1069E  0D05     MULLW 0x5
106A0  0E02     MOVLW 0x2
106A2  26F3     ADDWF PROD, F, ACCESS
106A4  0E00     MOVLW 0x0
106A6  22F4     ADDWFC PRODH, F, ACCESS
106A8  0E00     MOVLW 0x0
106AA  24F3     ADDWF PROD, W, ACCESS
106AC  6ED9     MOVWF FSR2, ACCESS
106AE  0E01     MOVLW 0x1
106B0  20F4     ADDWFC PRODH, W, ACCESS
106B2  6EDA     MOVWF FSR2H, ACCESS
106B4  50DF     MOVF INDF2, W, ACCESS
106B6  6FC5     MOVWF 0xC5, BANKED
106B8  39C5     SWAPF 0xC5, W, BANKED
106BA  0B0F     ANDLW 0xF
106BC  6FC6     MOVWF 0xC6, BANKED
106BE  6BC7     CLRF 0xC7, BANKED
106C0  90D8     BCF STATUS, 0, ACCESS
106C2  37C6     RLCF 0xC6, F, BANKED
106C4  37C7     RLCF 0xC7, F, BANKED
106C6  0E60     MOVLW 0x60
106C8  25C6     ADDWF 0xC6, W, BANKED
106CA  6ED9     MOVWF FSR2, ACCESS
106CC  0E00     MOVLW 0x0
106CE  21C7     ADDWFC 0xC7, W, BANKED
106D0  6EDA     MOVWF FSR2H, ACCESS
106D2  CFDE     MOVFF POSTINC2, 0xC8
106D4  F0C8     NOP
106D6  CFDD     MOVFF POSTDEC2, 0xC9
106D8  F0C9     NOP
106DA  2BC4     INCF 0xC4, F, BANKED
106DC  D003     BRA 0x6E4
106DE  90D8     BCF STATUS, 0, ACCESS
106E0  33C9     RRCF 0xC9, F, BANKED
106E2  33C8     RRCF 0xC8, F, BANKED
106E4  2FC4     DECFSZ 0xC4, F, BANKED
106E6  D7FB     BRA 0x6DE
106E8  0100     MOVLB 0x0
106EA  A1C8     BTFSS 0xC8, 0, BANKED
106EC  D044     BRA 0x776
577:           			{
578:           				if (mSw[c].count == ON_COUNT) {
106EE  51CE     MOVF c, W, BANKED
106F0  0D05     MULLW 0x5
106F2  0E00     MOVLW 0x0
106F4  24F3     ADDWF PROD, W, ACCESS
106F6  6ED9     MOVWF FSR2, ACCESS
106F8  0E01     MOVLW 0x1
106FA  20F4     ADDWFC PRODH, W, ACCESS
106FC  6EDA     MOVWF FSR2H, ACCESS
106FE  0E05     MOVLW 0x5
10700  18DE     XORWF POSTINC2, W, ACCESS
10702  A4D8     BTFSS STATUS, 2, ACCESS
10704  D02D     BRA 0x760
579:           					if (!mSw[c].state) {
10706  51CE     MOVF c, W, BANKED
10708  0D05     MULLW 0x5
1070A  0E01     MOVLW 0x1
1070C  26F3     ADDWF PROD, F, ACCESS
1070E  0E00     MOVLW 0x0
10710  22F4     ADDWFC PRODH, F, ACCESS
10712  0E00     MOVLW 0x0
10714  24F3     ADDWF PROD, W, ACCESS
10716  6ED9     MOVWF FSR2, ACCESS
10718  0E01     MOVLW 0x1
1071A  20F4     ADDWFC PRODH, W, ACCESS
1071C  6EDA     MOVWF FSR2H, ACCESS
1071E  50DF     MOVF INDF2, W, ACCESS
10720  A4D8     BTFSS STATUS, 2, ACCESS
10722  D042     BRA 0x7A8
580:           						mSw[c].state = 1;
10724  51CE     MOVF c, W, BANKED
10726  0D05     MULLW 0x5
10728  0E01     MOVLW 0x1
1072A  26F3     ADDWF PROD, F, ACCESS
1072C  0E00     MOVLW 0x0
1072E  22F4     ADDWFC PRODH, F, ACCESS
10730  0E00     MOVLW 0x0
10732  24F3     ADDWF PROD, W, ACCESS
10734  6ED9     MOVWF FSR2, ACCESS
10736  0E01     MOVLW 0x1
10738  20F4     ADDWFC PRODH, W, ACCESS
1073A  6EDA     MOVWF FSR2H, ACCESS
1073C  0E01     MOVLW 0x1
1073E  6EDF     MOVWF INDF2, ACCESS
581:           						swPush(mSw[c].num);
10740  51CE     MOVF c, W, BANKED
10742  0D05     MULLW 0x5
10744  0E02     MOVLW 0x2
10746  26F3     ADDWF PROD, F, ACCESS
10748  0E00     MOVLW 0x0
1074A  22F4     ADDWFC PRODH, F, ACCESS
1074C  0E00     MOVLW 0x0
1074E  24F3     ADDWF PROD, W, ACCESS
10750  6ED9     MOVWF FSR2, ACCESS
10752  0E01     MOVLW 0x1
10754  20F4     ADDWFC PRODH, W, ACCESS
10756  6EDA     MOVWF FSR2H, ACCESS
10758  50DF     MOVF INDF2, W, ACCESS
1075A  ECD7     CALL 0x107AE, 0
1075C  F083     NOP
582:           					}
583:           				} else {
1075E  D024     BRA 0x7A8
584:           					mSw[c].count++;
10760  0100     MOVLB 0x0
10762  51CE     MOVF c, W, BANKED
10764  0D05     MULLW 0x5
10766  0E00     MOVLW 0x0
10768  24F3     ADDWF PROD, W, ACCESS
1076A  6ED9     MOVWF FSR2, ACCESS
1076C  0E01     MOVLW 0x1
1076E  20F4     ADDWFC PRODH, W, ACCESS
10770  6EDA     MOVWF FSR2H, ACCESS
10772  2ADF     INCF INDF2, F, ACCESS
585:           				}
586:           			} else //OFF
10774  D019     BRA 0x7A8
587:           			{
588:           				if (mSw[c].count == 0) {
10776  51CE     MOVF c, W, BANKED
10778  0D05     MULLW 0x5
1077A  0E00     MOVLW 0x0
1077C  24F3     ADDWF PROD, W, ACCESS
1077E  6ED9     MOVWF FSR2, ACCESS
10780  0E01     MOVLW 0x1
10782  20F4     ADDWFC PRODH, W, ACCESS
10784  6EDA     MOVWF FSR2H, ACCESS
10786  50DF     MOVF INDF2, W, ACCESS
10788  A4D8     BTFSS STATUS, 2, ACCESS
1078A  D004     BRA 0x794
589:           					swUnregister(c);
1078C  51CE     MOVF c, W, BANKED
1078E  EC5B     CALL 0x10CB6, 0
10790  F086     NOP
590:           				} else {
10792  D00A     BRA 0x7A8
591:           					mSw[c].count--;
10794  0100     MOVLB 0x0
10796  51CE     MOVF c, W, BANKED
10798  0D05     MULLW 0x5
1079A  0E00     MOVLW 0x0
1079C  24F3     ADDWF PROD, W, ACCESS
1079E  6ED9     MOVWF FSR2, ACCESS
107A0  0E01     MOVLW 0x1
107A2  20F4     ADDWFC PRODH, W, ACCESS
107A4  6EDA     MOVWF FSR2H, ACCESS
107A6  06DF     DECF INDF2, F, ACCESS
592:           				}
107A8  0100     MOVLB 0x0
107AA  2BCE     INCF c, F, BANKED
107AC  D754     BRA 0x656
593:           			}
594:           		}
595:           	}
596:           }
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/ringBuffer.c  -------------------------------
1:             /*
2:              * File:   ringBuffer.c
3:              * Author: imada
4:              *
5:              * Created on April 16, 2018, 9:33 PM
6:              */
7:             
8:             #include <xc.h>
9:             #include "ringBuffer.h"
10:            
11:            void bufWrite(struct ringBuf *b, unsigned char d) {
12:            	b->buffer[b->readIndex] = d;
1164C  0101     MOVLB 0x1
1164E  EE20     LFSR 2, 0x3
11650  F003     NOP
11652  51D2     MOVF 0xD2, W, BANKED
11654  26D9     ADDWF FSR2, F, ACCESS
11656  51D3     MOVF 0xD3, W, BANKED
11658  22DA     ADDWFC FSR2H, F, ACCESS
1165A  50DF     MOVF INDF2, W, ACCESS
1165C  6FD5     MOVWF 0xD5, BANKED
1165E  51D5     MOVF 0xD5, W, BANKED
11660  0D01     MULLW 0x1
11662  C1D2     MOVFF __pcstackBANK1, FSR2
11664  FFD9     NOP
11666  C1D3     MOVFF d, FSR2H
11668  FFDA     NOP
1166A  CFDE     MOVFF POSTINC2, multiplicand
1166C  F1D6     NOP
1166E  CFDD     MOVFF POSTDEC2, d
11670  F1D7     NOP
11672  50F3     MOVF PROD, W, ACCESS
11674  25D6     ADDWF 0xD6, W, BANKED
11676  6ED9     MOVWF FSR2, ACCESS
11678  50F4     MOVF PRODH, W, ACCESS
1167A  21D7     ADDWFC 0xD7, W, BANKED
1167C  6EDA     MOVWF FSR2H, ACCESS
1167E  C1D4     MOVFF multiplicand, INDF2
11680  FFDF     NOP
116C2  0100     MOVLB 0x0
11820  EE20     LFSR 2, 0x3
13:            
14:            	b->writeIndex++;
11682  EE20     LFSR 2, 0x2
11684  F002     NOP
11686  51D2     MOVF 0xD2, W, BANKED
11688  26D9     ADDWF FSR2, F, ACCESS
1168A  51D3     MOVF 0xD3, W, BANKED
1168C  22DA     ADDWFC FSR2H, F, ACCESS
1168E  2ADF     INCF INDF2, F, ACCESS
116F8  EE20     LFSR 2, 0x2
116FA  F002     NOP
116FC  51B9     MOVF __pcstackBANK0, W, BANKED
116FE  26D9     ADDWF FSR2, F, ACCESS
11700  51BA     MOVF 0xBA, W, BANKED
11702  22DA     ADDWFC FSR2H, F, ACCESS
11704  2ADF     INCF INDF2, F, ACCESS
11854  EE20     LFSR 2, 0x2
11856  F002     NOP
11858  5027     MOVF __pcstackCOMRAM, W, ACCESS
1185A  26D9     ADDWF FSR2, F, ACCESS
1185C  5028     MOVF 0x28, W, ACCESS
1185E  22DA     ADDWFC FSR2H, F, ACCESS
11860  2ADF     INCF INDF2, F, ACCESS
15:            	if (b->writeIndex == b->size) {
11690  EE20     LFSR 2, 0x4
11692  F004     NOP
11694  51D2     MOVF 0xD2, W, BANKED
11696  26D9     ADDWF FSR2, F, ACCESS
11698  51D3     MOVF 0xD3, W, BANKED
1169A  22DA     ADDWFC FSR2H, F, ACCESS
1169C  EE10     LFSR 1, 0x2
1169E  F002     NOP
116A0  51D2     MOVF 0xD2, W, BANKED
116A2  26E1     ADDWF FSR1, F, ACCESS
116A4  51D3     MOVF 0xD3, W, BANKED
116A6  22E2     ADDWFC FSR1H, F, ACCESS
116A8  50DE     MOVF POSTINC2, W, ACCESS
116AA  18E6     XORWF POSTINC1, W, ACCESS
116AC  A4D8     BTFSS STATUS, 2, ACCESS
116AE  0012     RETURN 0
11706  EE20     LFSR 2, 0x4
11708  F004     NOP
1170A  51B9     MOVF __pcstackBANK0, W, BANKED
1170C  26D9     ADDWF FSR2, F, ACCESS
1170E  51BA     MOVF 0xBA, W, BANKED
11710  22DA     ADDWFC FSR2H, F, ACCESS
11712  EE10     LFSR 1, 0x2
11714  F002     NOP
11716  51B9     MOVF __pcstackBANK0, W, BANKED
11718  26E1     ADDWF FSR1, F, ACCESS
1171A  51BA     MOVF 0xBA, W, BANKED
1171C  22E2     ADDWFC FSR1H, F, ACCESS
1171E  50DE     MOVF POSTINC2, W, ACCESS
11720  18E6     XORWF POSTINC1, W, ACCESS
11722  A4D8     BTFSS STATUS, 2, ACCESS
11724  0012     RETURN 0
11862  EE20     LFSR 2, 0x4
11864  F004     NOP
11866  5027     MOVF __pcstackCOMRAM, W, ACCESS
11868  26D9     ADDWF FSR2, F, ACCESS
1186A  5028     MOVF 0x28, W, ACCESS
1186C  22DA     ADDWFC FSR2H, F, ACCESS
1186E  EE10     LFSR 1, 0x2
11870  F002     NOP
11872  5027     MOVF __pcstackCOMRAM, W, ACCESS
11874  26E1     ADDWF FSR1, F, ACCESS
11876  5028     MOVF 0x28, W, ACCESS
11878  22E2     ADDWFC FSR1H, F, ACCESS
1187A  50DE     MOVF POSTINC2, W, ACCESS
1187C  18E6     XORWF POSTINC1, W, ACCESS
1187E  A4D8     BTFSS STATUS, 2, ACCESS
11880  0012     RETURN 0
16:            		b->writeIndex = 0;
116B0  EE20     LFSR 2, 0x2
116B2  F002     NOP
116B4  51D2     MOVF 0xD2, W, BANKED
116B6  26D9     ADDWF FSR2, F, ACCESS
116B8  51D3     MOVF 0xD3, W, BANKED
116BA  22DA     ADDWFC FSR2H, F, ACCESS
116BC  0E00     MOVLW 0x0
116BE  6EDF     MOVWF INDF2, ACCESS
116C0  0012     RETURN 0
11726  EE20     LFSR 2, 0x2
11882  EE20     LFSR 2, 0x2
11884  F002     NOP
11886  5027     MOVF __pcstackCOMRAM, W, ACCESS
11888  26D9     ADDWF FSR2, F, ACCESS
1188A  5028     MOVF 0x28, W, ACCESS
1188C  22DA     ADDWFC FSR2H, F, ACCESS
1188E  0E00     MOVLW 0x0
11890  6EDF     MOVWF INDF2, ACCESS
11892  0012     RETURN 0
17:            	}
18:            }
19:            
20:            unsigned char bufRead(struct ringBuf *b) {
21:            	unsigned char d;
22:            
23:            	d = b->buffer[b->readIndex];
115D4  0101     MOVLB 0x1
115D6  EE20     LFSR 2, 0x3
115D8  F003     NOP
115DA  51D2     MOVF 0xD2, W, BANKED
115DC  26D9     ADDWF FSR2, F, ACCESS
115DE  51D3     MOVF 0xD3, W, BANKED
115E0  22DA     ADDWFC FSR2H, F, ACCESS
115E2  50DF     MOVF INDF2, W, ACCESS
115E4  6FD4     MOVWF 0xD4, BANKED
115E6  51D4     MOVF 0xD4, W, BANKED
115E8  0D01     MULLW 0x1
115EA  C1D2     MOVFF __pcstackBANK1, FSR2
115EC  FFD9     NOP
115EE  C1D3     MOVFF d, FSR2H
115F0  FFDA     NOP
115F2  CFDE     MOVFF POSTINC2, 0x1D5
115F4  F1D5     NOP
115F6  CFDD     MOVFF POSTDEC2, multiplicand
115F8  F1D6     NOP
115FA  50F3     MOVF PROD, W, ACCESS
115FC  25D5     ADDWF 0xD5, W, BANKED
115FE  6ED9     MOVWF FSR2, ACCESS
11600  50F4     MOVF PRODH, W, ACCESS
11602  21D6     ADDWFC 0xD6, W, BANKED
11604  6EDA     MOVWF FSR2H, ACCESS
11606  50DF     MOVF INDF2, W, ACCESS
11608  6FD7     MOVWF 0xD7, BANKED
24:            
25:            	b->readIndex++;
1160A  EE20     LFSR 2, 0x3
1160C  F003     NOP
1160E  51D2     MOVF 0xD2, W, BANKED
11610  26D9     ADDWF FSR2, F, ACCESS
11612  51D3     MOVF 0xD3, W, BANKED
11614  22DA     ADDWFC FSR2H, F, ACCESS
11616  2ADF     INCF INDF2, F, ACCESS
26:            	if (b->readIndex == b->size) {
11618  EE20     LFSR 2, 0x4
1161A  F004     NOP
1161C  51D2     MOVF 0xD2, W, BANKED
1161E  26D9     ADDWF FSR2, F, ACCESS
11620  51D3     MOVF 0xD3, W, BANKED
11622  22DA     ADDWFC FSR2H, F, ACCESS
11624  EE10     LFSR 1, 0x3
11626  F003     NOP
11628  51D2     MOVF 0xD2, W, BANKED
1162A  26E1     ADDWF FSR1, F, ACCESS
1162C  51D3     MOVF 0xD3, W, BANKED
1162E  22E2     ADDWFC FSR1H, F, ACCESS
11630  50DE     MOVF POSTINC2, W, ACCESS
11632  18E6     XORWF POSTINC1, W, ACCESS
11634  A4D8     BTFSS STATUS, 2, ACCESS
11636  D008     BRA 0x1648
27:            		b->readIndex = 0;
11638  EE20     LFSR 2, 0x3
1163A  F003     NOP
1163C  51D2     MOVF 0xD2, W, BANKED
1163E  26D9     ADDWF FSR2, F, ACCESS
11640  51D3     MOVF 0xD3, W, BANKED
11642  22DA     ADDWFC FSR2H, F, ACCESS
11644  0E00     MOVLW 0x0
11646  6EDF     MOVWF INDF2, ACCESS
28:            	}
29:            
30:            	return d;
11648  51D7     MOVF 0xD7, W, BANKED
1164A  0012     RETURN 0
31:            }
32:            
33:            unsigned char bufDataExist(struct ringBuf *b) {
34:            	return (unsigned char)(b->writeIndex != b->readIndex);
11D08  0101     MOVLB 0x1
11D0A  EE20     LFSR 2, 0x3
11D0C  F003     NOP
11D0E  51D2     MOVF 0xD2, W, BANKED
11D10  26D9     ADDWF FSR2, F, ACCESS
11D12  51D3     MOVF 0xD3, W, BANKED
11D14  22DA     ADDWFC FSR2H, F, ACCESS
11D16  EE10     LFSR 1, 0x2
11D18  F002     NOP
11D1A  51D2     MOVF 0xD2, W, BANKED
11D1C  26E1     ADDWF FSR1, F, ACCESS
11D1E  51D3     MOVF 0xD3, W, BANKED
11D20  22E2     ADDWFC FSR1H, F, ACCESS
11D22  50DE     MOVF POSTINC2, W, ACCESS
11D24  18E6     XORWF POSTINC1, W, ACCESS
11D26  B4D8     BTFSC STATUS, 2, ACCESS
11D28  D002     BRA 0x1D2E
11D2A  0E01     MOVLW 0x1
11D2C  0012     RETURN 0
11D2E  0E00     MOVLW 0x0
11D30  0012     RETURN 0
35:            }
36:            
37:            void bufInit(struct ringBuf *b, unsigned char *buf, unsigned char size) {
38:            	b->buffer = buf;
11BE4  C1D2     MOVFF __pcstackBANK1, FSR2
11BE6  FFD9     NOP
11BE8  C1D3     MOVFF d, FSR2H
11BEA  FFDA     NOP
11BEC  C1D4     MOVFF multiplicand, POSTINC2
11BEE  FFDE     NOP
11BF0  C1D5     MOVFF 0x1D5, POSTDEC2
11BF2  FFDD     NOP
39:            	b->writeIndex = 0;
11BF4  0101     MOVLB 0x1
11BF6  EE20     LFSR 2, 0x2
11BF8  F002     NOP
11BFA  51D2     MOVF 0xD2, W, BANKED
11BFC  26D9     ADDWF FSR2, F, ACCESS
11BFE  51D3     MOVF 0xD3, W, BANKED
11C00  22DA     ADDWFC FSR2H, F, ACCESS
11C02  0E00     MOVLW 0x0
11C04  6EDF     MOVWF INDF2, ACCESS
40:            	b->readIndex = 0;
11C06  EE20     LFSR 2, 0x3
11C08  F003     NOP
11C0A  51D2     MOVF 0xD2, W, BANKED
11C0C  26D9     ADDWF FSR2, F, ACCESS
11C0E  51D3     MOVF 0xD3, W, BANKED
11C10  22DA     ADDWFC FSR2H, F, ACCESS
11C12  0E00     MOVLW 0x0
11C14  6EDF     MOVWF INDF2, ACCESS
41:            	b->size = size;
11C16  EE20     LFSR 2, 0x4
11C18  F004     NOP
11C1A  51D2     MOVF 0xD2, W, BANKED
11C1C  26D9     ADDWF FSR2, F, ACCESS
11C1E  51D3     MOVF 0xD3, W, BANKED
11C20  22DA     ADDWFC FSR2H, F, ACCESS
11C22  C1D6     MOVFF multiplicand, INDF2
11C24  FFDF     NOP
42:            }
11C26  0012     RETURN 0
43:            
44:            
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/main.c  -------------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             #include <xc.h>        /* XC8 General Include File */
5:             
6:             #include <stdint.h>        /* For uint8_t definition */
7:             #include <stdbool.h>       /* For true/false definition */
8:             
9:             #include "system.h"        /* System funct/params, like osc/peripheral config */
10:            #include "user.h"          /* User funct/params, such as InitApp */
11:            #include "eusart2.h"
12:            #include "eusart5.h"
13:            #include "adcc.h"
14:            #include "RN42.h"
15:            #include "FT230X.h"
16:            #include "main.h"
17:            #include "sw.h"
18:            #include "ringBuffer.h"
19:            
20:            //#define __OPTIMIZE_SPEED__
21:            
22:            #if defined(__OPTIMIZE_SPEED__)
23:            kkk
24:            #endif
25:            void setSleepDelay(unsigned short second);
26:            
27:            /******************************************************************************/
28:            /* User Global Variable Declaration                                           */
29:            /******************************************************************************/
30:            
31:            unsigned long time = 0;
32:            unsigned long sleepCountDown = 0;
33:            
34:            //unsigned char sw1Flag = 0;
35:            //unsigned char sw1FlagLong = 0;
36:            
37:            //unsigned char FlagU2Send = 0;
38:            //unsigned char FlagU5Send = 0;
39:            //unsigned char FlagCheckSwMatrix = 0;
40:            
41:            //unsigned char FlagShowBatteryState = 0;
42:            
43:            union MainFlags mainFlags;
44:            
45:            struct ringBuf bufU2_intH;
46:            struct ringBuf bufU2_intL;
47:            struct ringBuf bufU2_main;
48:            struct ringBuf bufU5_intH;
49:            struct ringBuf bufU5_intL;
50:            struct ringBuf bufU5_main;
51:            
52:            unsigned char b1[32];
53:            unsigned char b2[32];
54:            unsigned char b3[32];
55:            unsigned char b4[32];
56:            unsigned char b5[32];
57:            unsigned char b6[32];
58:            unsigned short aaa;
59:            unsigned short bbb;
60:            unsigned short ccc;
61:            
62:            /******************************************************************************/
63:            /* Main Program                                                               */
64:            
65:            /******************************************************************************/
66:            void main(void) {	
67:            	aaa =bbb *ccc;
10000  C00F     MOVFF bbb, __pcstackBANK1
10002  F1D2     NOP
10004  C010     MOVFF 0x10, d
10006  F1D3     NOP
10008  C00D     MOVFF ccc, multiplicand
1000A  F1D4     NOP
1000C  C00E     MOVFF 0xE, 0x1D5
1000E  F1D5     NOP
10010  EC99     CALL 0x11D32, 0
10012  F08E     NOP
10014  C1D2     MOVFF __pcstackBANK1, aaa
10016  F0F2     NOP
10018  C1D3     MOVFF d, 0xF3
1001A  F0F3     NOP
68:            	/* Configure the oscillator for the device */
69:            
70:            	/* Initialize I/O and Peripherals for application */
71:            	InitApp();
1001C  EC34     CALL 0x11E68, 0
1001E  F08F     NOP
72:            	waitBootTrigger();
10020  EC81     CALL 0x11B02, 0
10022  F08D     NOP
73:            	InitApp2();
10024  ECD6     CALL 0x117AC, 0
10026  F08B     NOP
74:            
75:            	setSleepDelay(300);
10028  0E01     MOVLW 0x1
1002A  0101     MOVLB 0x1
1002C  6FDF     MOVWF 0xDF, BANKED
1002E  0E2C     MOVLW 0x2C
10030  6FDE     MOVWF 0xDE, BANKED
10032  EC28     CALL 0x11A50, 0
10034  F08D     NOP
76:            	INTCONbits.GIE = 1;
10036  8EF2     BSF INTCON, 7, ACCESS
77:            	//	mainFlags.connect = 1;
78:            	connect();
10038  ECE6     CALL 0x11DCC, 0
1003A  F08E     NOP
79:            	
80:            	bufInit(&bufU2_intH,b1,sizeof(b1));
1003C  0EB4     MOVLW 0xB4
1003E  0101     MOVLB 0x1
10040  6FD2     MOVWF 0xD2, BANKED
10042  0E00     MOVLW 0x0
10044  6FD3     MOVWF 0xD3, BANKED
10046  0E8A     MOVLW 0x8A
10048  6FD4     MOVWF 0xD4, BANKED
1004A  0E00     MOVLW 0x0
1004C  6FD5     MOVWF 0xD5, BANKED
1004E  0E20     MOVLW 0x20
10050  6FD6     MOVWF 0xD6, BANKED
10052  ECF2     CALL 0x11BE4, 0
10054  F08D     NOP
81:            	bufInit(&bufU2_intL,b2,sizeof(b2));
10056  0E18     MOVLW 0x18
10058  0101     MOVLB 0x1
1005A  6FD2     MOVWF 0xD2, BANKED
1005C  0E00     MOVLW 0x0
1005E  6FD3     MOVWF 0xD3, BANKED
10060  0EB2     MOVLW 0xB2
10062  6FD4     MOVWF 0xD4, BANKED
10064  0E01     MOVLW 0x1
10066  6FD5     MOVWF 0xD5, BANKED
10068  0E20     MOVLW 0x20
1006A  6FD6     MOVWF 0xD6, BANKED
1006C  ECF2     CALL 0x11BE4, 0
1006E  F08D     NOP
82:            	bufInit(&bufU2_main,b3,sizeof(b3));
10070  0EAF     MOVLW 0xAF
10072  0101     MOVLB 0x1
10074  6FD2     MOVWF 0xD2, BANKED
10076  0E00     MOVLW 0x0
10078  6FD3     MOVWF 0xD3, BANKED
1007A  0E92     MOVLW 0x92
1007C  6FD4     MOVWF 0xD4, BANKED
1007E  0E01     MOVLW 0x1
10080  6FD5     MOVWF 0xD5, BANKED
10082  0E20     MOVLW 0x20
10084  6FD6     MOVWF 0xD6, BANKED
10086  ECF2     CALL 0x11BE4, 0
10088  F08D     NOP
83:            	bufInit(&bufU5_intH,b4,sizeof(b4));
1008A  0E22     MOVLW 0x22
1008C  0101     MOVLB 0x1
1008E  6FD2     MOVWF 0xD2, BANKED
10090  0E00     MOVLW 0x0
10092  6FD3     MOVWF 0xD3, BANKED
10094  0E72     MOVLW 0x72
10096  6FD4     MOVWF 0xD4, BANKED
10098  0E01     MOVLW 0x1
1009A  6FD5     MOVWF 0xD5, BANKED
1009C  0E20     MOVLW 0x20
1009E  6FD6     MOVWF 0xD6, BANKED
100A0  ECF2     CALL 0x11BE4, 0
100A2  F08D     NOP
84:            	bufInit(&bufU5_intL,b5,sizeof(b5));
100A4  0E1D     MOVLW 0x1D
100A6  0101     MOVLB 0x1
100A8  6FD2     MOVWF 0xD2, BANKED
100AA  0E00     MOVLW 0x0
100AC  6FD3     MOVWF 0xD3, BANKED
100AE  0E52     MOVLW 0x52
100B0  6FD4     MOVWF 0xD4, BANKED
100B2  0E01     MOVLW 0x1
100B4  6FD5     MOVWF 0xD5, BANKED
100B6  0E20     MOVLW 0x20
100B8  6FD6     MOVWF 0xD6, BANKED
100BA  ECF2     CALL 0x11BE4, 0
100BC  F08D     NOP
85:            	bufInit(&bufU5_main,b6,sizeof(b6));
100BE  0EAA     MOVLW 0xAA
100C0  0101     MOVLB 0x1
100C2  6FD2     MOVWF 0xD2, BANKED
100C4  0E00     MOVLW 0x0
100C6  6FD3     MOVWF 0xD3, BANKED
100C8  0E32     MOVLW 0x32
100CA  6FD4     MOVWF 0xD4, BANKED
100CC  0E01     MOVLW 0x1
100CE  6FD5     MOVWF 0xD5, BANKED
100D0  0E20     MOVLW 0x20
100D2  6FD6     MOVWF 0xD6, BANKED
100D4  ECF2     CALL 0x11BE4, 0
100D6  F08D     NOP
86:            
87:            	for (unsigned char c = 0; c < LEDNUM; c++) {
100D8  0E00     MOVLW 0x0
100DA  0101     MOVLB 0x1
100DC  6FE5     MOVWF c, BANKED
100DE  0E0B     MOVLW 0xB
100E0  65E5     CPFSGT c, BANKED
100E2  D001     BRA 0xE6
100E4  D00C     BRA 0xFE
100FA  2BE5     INCF c, F, BANKED
100FC  D7F0     BRA 0xDE
88:            		led[c] = 0;
100E6  51E5     MOVF c, W, BANKED
100E8  0D01     MULLW 0x1
100EA  0E6C     MOVLW 0x6C
100EC  24F3     ADDWF PROD, W, ACCESS
100EE  6ED9     MOVWF FSR2, ACCESS
100F0  0E00     MOVLW 0x0
100F2  20F4     ADDWFC PRODH, W, ACCESS
100F4  6EDA     MOVWF FSR2H, ACCESS
100F6  0E00     MOVLW 0x0
100F8  6EDF     MOVWF INDF2, ACCESS
89:            	}
90:            	waitMs(200);
100FE  0EC8     MOVLW 0xC8
10100  6FD2     MOVWF 0xD2, BANKED
10102  0E00     MOVLW 0x0
10104  6FD3     MOVWF 0xD3, BANKED
10106  0E00     MOVLW 0x0
10108  6FD4     MOVWF 0xD4, BANKED
1010A  0E00     MOVLW 0x0
1010C  6FD5     MOVWF 0xD5, BANKED
1010E  ECD0     CALL 0x11BA0, 0
10110  F08D     NOP
91:            	for (unsigned char c = 0; c < LEDNUM; c++) {
10112  0E00     MOVLW 0x0
10114  0101     MOVLB 0x1
10116  6FE6     MOVWF keyMapList, BANKED
10118  0E0B     MOVLW 0xB
1011A  65E6     CPFSGT keyMapList, BANKED
1011C  D001     BRA 0x120
1011E  D017     BRA 0x14E
10148  0101     MOVLB 0x1
1014A  2BE6     INCF keyMapList, F, BANKED
1014C  D7E5     BRA 0x118
92:            		led[c] = 1;
10120  51E6     MOVF keyMapList, W, BANKED
10122  0D01     MULLW 0x1
10124  0E6C     MOVLW 0x6C
10126  24F3     ADDWF PROD, W, ACCESS
10128  6ED9     MOVWF FSR2, ACCESS
1012A  0E00     MOVLW 0x0
1012C  20F4     ADDWFC PRODH, W, ACCESS
1012E  6EDA     MOVWF FSR2H, ACCESS
10130  0E01     MOVLW 0x1
10132  6EDF     MOVWF INDF2, ACCESS
93:            		waitMs(100);
10134  0E64     MOVLW 0x64
10136  6FD2     MOVWF 0xD2, BANKED
10138  0E00     MOVLW 0x0
1013A  6FD3     MOVWF 0xD3, BANKED
1013C  0E00     MOVLW 0x0
1013E  6FD4     MOVWF 0xD4, BANKED
10140  0E00     MOVLW 0x0
10142  6FD5     MOVWF 0xD5, BANKED
10144  ECD0     CALL 0x11BA0, 0
10146  F08D     NOP
94:            	}
95:            	waitMs(200);
1014E  0EC8     MOVLW 0xC8
10150  6FD2     MOVWF 0xD2, BANKED
10152  0E00     MOVLW 0x0
10154  6FD3     MOVWF 0xD3, BANKED
10156  0E00     MOVLW 0x0
10158  6FD4     MOVWF 0xD4, BANKED
1015A  0E00     MOVLW 0x0
1015C  6FD5     MOVWF 0xD5, BANKED
1015E  ECD0     CALL 0x11BA0, 0
10160  F08D     NOP
96:            	for (unsigned char c = 0; c < LEDNUM; c++) {
10162  0E00     MOVLW 0x0
10164  0101     MOVLB 0x1
10166  6FE7     MOVWF 0xE7, BANKED
10168  0E0B     MOVLW 0xB
1016A  65E7     CPFSGT 0xE7, BANKED
1016C  D001     BRA 0x170
1016E  D017     BRA 0x19E
10198  0101     MOVLB 0x1
1019A  2BE7     INCF 0xE7, F, BANKED
1019C  D7E5     BRA 0x168
97:            		led[c] = 0;
10170  51E7     MOVF 0xE7, W, BANKED
10172  0D01     MULLW 0x1
10174  0E6C     MOVLW 0x6C
10176  24F3     ADDWF PROD, W, ACCESS
10178  6ED9     MOVWF FSR2, ACCESS
1017A  0E00     MOVLW 0x0
1017C  20F4     ADDWFC PRODH, W, ACCESS
1017E  6EDA     MOVWF FSR2H, ACCESS
10180  0E00     MOVLW 0x0
10182  6EDF     MOVWF INDF2, ACCESS
98:            		waitMs(100);
10184  0E64     MOVLW 0x64
10186  6FD2     MOVWF 0xD2, BANKED
10188  0E00     MOVLW 0x0
1018A  6FD3     MOVWF 0xD3, BANKED
1018C  0E00     MOVLW 0x0
1018E  6FD4     MOVWF 0xD4, BANKED
10190  0E00     MOVLW 0x0
10192  6FD5     MOVWF 0xD5, BANKED
10194  ECD0     CALL 0x11BA0, 0
10196  F08D     NOP
99:            	}
100:           	waitMs(200);
1019E  0EC8     MOVLW 0xC8
101A0  6FD2     MOVWF 0xD2, BANKED
101A2  0E00     MOVLW 0x0
101A4  6FD3     MOVWF 0xD3, BANKED
101A6  0E00     MOVLW 0x0
101A8  6FD4     MOVWF 0xD4, BANKED
101AA  0E00     MOVLW 0x0
101AC  6FD5     MOVWF 0xD5, BANKED
101AE  ECD0     CALL 0x11BA0, 0
101B0  F08D     NOP
101:           	showText("Hello!!!!!!");
101B2  0EF3     MOVLW 0xF3
101B4  0101     MOVLB 0x1
101B6  6FD4     MOVWF 0xD4, BANKED
101B8  0EFF     MOVLW 0xFF
101BA  6FD5     MOVWF 0xD5, BANKED
101BC  EC55     CALL 0x11CAA, 0
101BE  F08E     NOP
102:           
103:           	while (1) {
104:           		LED1 = BT_GPIO5;
101C0  A28E     BTFSS PORTF, 1, ACCESS
101C2  D002     BRA 0x1C8
101C4  8E8C     BSF PORTD, 7, ACCESS
101C6  D001     BRA 0x1CA
101C8  9E8C     BCF PORTD, 7, ACCESS
105:           		led[LED_FNL] = fnEnable;
101CA  C089     MOVFF fnEnable, 0x6F
101CC  F06F     NOP
106:           		led[LED_ALT] = keyReport.modifier.bits.AltL;
101CE  0100     MOVLB 0x0
101D0  0E00     MOVLW 0x0
101D2  B578     BTFSC keyReport, 2, BANKED
101D4  0E01     MOVLW 0x1
101D6  6F72     MOVWF 0x72, BANKED
107:           		led[LED_GUI] = keyReport.modifier.bits.GuiL;
101D8  0E00     MOVLW 0x0
101DA  B778     BTFSC keyReport, 3, BANKED
101DC  0E01     MOVLW 0x1
101DE  6F73     MOVWF 0x73, BANKED
108:           		led[LED_CTL] = keyReport.modifier.bits.CtrlL;
101E0  0E00     MOVLW 0x0
101E2  B178     BTFSC keyReport, 0, BANKED
101E4  0E01     MOVLW 0x1
101E6  6F71     MOVWF 0x71, BANKED
109:           		led[LED_FNR] = fnEnable;
101E8  C089     MOVFF fnEnable, 0x70
101EA  F070     NOP
110:           		led[LED_SHL] = led[LED_SHR] = keyReport.modifier.bits.ShiftL | keyReport.modifier.bits.ShiftR;
101EC  AB78     BTFSS keyReport, 5, BANKED
101EE  D004     BRA 0x1F8
101F0  0101     MOVLB 0x1
101F2  6BE4     CLRF 0xE4, BANKED
101F4  2BE4     INCF 0xE4, F, BANKED
101F6  D002     BRA 0x1FC
101F8  0101     MOVLB 0x1
101FA  6BE4     CLRF 0xE4, BANKED
101FC  0100     MOVLB 0x0
101FE  A378     BTFSS keyReport, 1, BANKED
10200  D002     BRA 0x206
10202  0E01     MOVLW 0x1
10204  D001     BRA 0x208
10206  0E00     MOVLW 0x0
10208  0101     MOVLB 0x1
1020A  11E4     IORWF 0xE4, W, BANKED
1020C  0100     MOVLB 0x0
1020E  6F75     MOVWF 0x75, BANKED
10210  C075     MOVFF 0x75, 0x74
10212  F074     NOP
111:           		led[LED_M1] = keyMode == 0;
10214  5188     MOVF keyMode, W, BANKED
10216  A4D8     BTFSS STATUS, 2, ACCESS
10218  D002     BRA 0x21E
1021A  0E01     MOVLW 0x1
1021C  D001     BRA 0x220
1021E  0E00     MOVLW 0x0
10220  6F6C     MOVWF led, BANKED
112:           		led[LED_M2] = keyMode == 1;
10222  0588     DECF keyMode, W, BANKED
10224  A4D8     BTFSS STATUS, 2, ACCESS
10226  D002     BRA 0x22C
10228  0E01     MOVLW 0x1
1022A  D001     BRA 0x22E
1022C  0E00     MOVLW 0x0
1022E  6F6D     MOVWF 0x6D, BANKED
113:           		led[LED_M3] = keyMode == 2;
10230  0E02     MOVLW 0x2
10232  1988     XORWF keyMode, W, BANKED
10234  A4D8     BTFSS STATUS, 2, ACCESS
10236  D002     BRA 0x23C
10238  0E01     MOVLW 0x1
1023A  D001     BRA 0x23E
1023C  0E00     MOVLW 0x0
1023E  6F6E     MOVWF 0x6E, BANKED
114:           		led[LED_CUL] = BT_GPIO5;
10240  0E00     MOVLW 0x0
10242  B28E     BTFSC PORTF, 1, ACCESS
10244  0E01     MOVLW 0x1
10246  6F76     MOVWF 0x76, BANKED
115:           		led[LED_CUR] = BtConnected;
10248  C087     MOVFF BtConnected, 0x77
1024A  F077     NOP
116:           
117:           		//		while (mainFlags.all)
118:           		//		{
119:           		if (mainFlags.sw1Pushed) {
1024C  A011     BTFSS mainFlags, 0, ACCESS
1024E  D008     BRA 0x260
120:           			//			LED1 = 1;
121:           			//TODO: start pairing
122:           			setSleepDelay(300);
10250  0E01     MOVLW 0x1
10252  0101     MOVLB 0x1
10254  6FDF     MOVWF 0xDF, BANKED
10256  0E2C     MOVLW 0x2C
10258  6FDE     MOVWF 0xDE, BANKED
1025A  EC28     CALL 0x11A50, 0
1025C  F08D     NOP
123:           			mainFlags.sw1Pushed = 0;
1025E  9011     BCF mainFlags, 0, ACCESS
124:           		}
125:           		if (mainFlags.sw1LongPushing) {
10260  A211     BTFSS mainFlags, 1, ACCESS
10262  D008     BRA 0x274
126:           			setSleepDelay(300);
10264  0E01     MOVLW 0x1
10266  0101     MOVLB 0x1
10268  6FDF     MOVWF 0xDF, BANKED
1026A  0E2C     MOVLW 0x2C
1026C  6FDE     MOVWF 0xDE, BANKED
1026E  EC28     CALL 0x11A50, 0
10270  F08D     NOP
127:           			mainFlags.sw1LongPushing = 0;
10272  9211     BCF mainFlags, 1, ACCESS
128:           		}
129:           		if (mainFlags.showBattery) {
10274  A612     BTFSS 0x12, 3, ACCESS
10276  D00A     BRA 0x28C
130:           			showBatteryState();
10278  EC66     CALL 0x114CC, 0
1027A  F08A     NOP
131:           			setSleepDelay(300);
1027C  0E01     MOVLW 0x1
1027E  0101     MOVLB 0x1
10280  6FDF     MOVWF 0xDF, BANKED
10282  0E2C     MOVLW 0x2C
10284  6FDE     MOVWF 0xDE, BANKED
10286  EC28     CALL 0x11A50, 0
10288  F08D     NOP
132:           			mainFlags.showBattery = 0;
1028A  9612     BCF 0x12, 3, ACCESS
133:           		}
134:           		if (mainFlags.sendComsumerKeyReport) {
1028C  A411     BTFSS mainFlags, 2, ACCESS
1028E  D00A     BRA 0x2A4
135:           			sendConsumerReport();
10290  ECF4     CALL 0x119E8, 0
10292  F08C     NOP
136:           			setSleepDelay(300);
10294  0E01     MOVLW 0x1
10296  0101     MOVLB 0x1
10298  6FDF     MOVWF 0xDF, BANKED
1029A  0E2C     MOVLW 0x2C
1029C  6FDE     MOVWF 0xDE, BANKED
1029E  EC28     CALL 0x11A50, 0
102A0  F08D     NOP
137:           			mainFlags.sendComsumerKeyReport = 0;
102A2  9411     BCF mainFlags, 2, ACCESS
138:           		}
139:           		if (mainFlags.sendKeyReport) {
102A4  A611     BTFSS mainFlags, 3, ACCESS
102A6  D00C     BRA 0x2C0
140:           			setScanCodes();
102A8  EC39     CALL 0x10E72, 0
102AA  F087     NOP
141:           			sendKey();
102AC  EC72     CALL 0x112E4, 0
102AE  F089     NOP
142:           			setSleepDelay(300);
102B0  0E01     MOVLW 0x1
102B2  0101     MOVLB 0x1
102B4  6FDF     MOVWF 0xDF, BANKED
102B6  0E2C     MOVLW 0x2C
102B8  6FDE     MOVWF 0xDE, BANKED
102BA  EC28     CALL 0x11A50, 0
102BC  F08D     NOP
143:           			mainFlags.sendKeyReport = 0;
102BE  9611     BCF mainFlags, 3, ACCESS
144:           		}
145:           		if (mainFlags.sendMouseReport) {
102C0  AA11     BTFSS mainFlags, 5, ACCESS
102C2  D00A     BRA 0x2D8
146:           			sendMouse();
102C4  EC22     CALL 0x11444, 0
102C6  F08A     NOP
147:           			setSleepDelay(300);
102C8  0E01     MOVLW 0x1
102CA  0101     MOVLB 0x1
102CC  6FDF     MOVWF 0xDF, BANKED
102CE  0E2C     MOVLW 0x2C
102D0  6FDE     MOVWF 0xDE, BANKED
102D2  EC28     CALL 0x11A50, 0
102D4  F08D     NOP
148:           			mainFlags.sendMouseReport = 0;
102D6  9A11     BCF mainFlags, 5, ACCESS
149:           		}
150:           		if (mainFlags.shutdown) {
102D8  AC11     BTFSS mainFlags, 6, ACCESS
102DA  D04C     BRA 0x374
151:           			for (unsigned char c = 0; c < LEDNUM; c++) {
102DC  0E00     MOVLW 0x0
102DE  0101     MOVLB 0x1
102E0  6FE8     MOVWF 0xE8, BANKED
102E2  0E0B     MOVLW 0xB
102E4  65E8     CPFSGT 0xE8, BANKED
102E6  D001     BRA 0x2EA
102E8  D017     BRA 0x318
10312  0101     MOVLB 0x1
10314  2BE8     INCF 0xE8, F, BANKED
10316  D7E5     BRA 0x2E2
152:           				led[c] = 1;
102EA  51E8     MOVF 0xE8, W, BANKED
102EC  0D01     MULLW 0x1
102EE  0E6C     MOVLW 0x6C
102F0  24F3     ADDWF PROD, W, ACCESS
102F2  6ED9     MOVWF FSR2, ACCESS
102F4  0E00     MOVLW 0x0
102F6  20F4     ADDWFC PRODH, W, ACCESS
102F8  6EDA     MOVWF FSR2H, ACCESS
102FA  0E01     MOVLW 0x1
102FC  6EDF     MOVWF INDF2, ACCESS
153:           				waitMs(300);
102FE  0E2C     MOVLW 0x2C
10300  6FD2     MOVWF 0xD2, BANKED
10302  0E01     MOVLW 0x1
10304  6FD3     MOVWF 0xD3, BANKED
10306  0E00     MOVLW 0x0
10308  6FD4     MOVWF 0xD4, BANKED
1030A  0E00     MOVLW 0x0
1030C  6FD5     MOVWF 0xD5, BANKED
1030E  ECD0     CALL 0x11BA0, 0
10310  F08D     NOP
154:           			}
155:           			waitMs(500);
10318  0EF4     MOVLW 0xF4
1031A  6FD2     MOVWF 0xD2, BANKED
1031C  0E01     MOVLW 0x1
1031E  6FD3     MOVWF 0xD3, BANKED
10320  0E00     MOVLW 0x0
10322  6FD4     MOVWF 0xD4, BANKED
10324  0E00     MOVLW 0x0
10326  6FD5     MOVWF 0xD5, BANKED
10328  ECD0     CALL 0x11BA0, 0
1032A  F08D     NOP
156:           			for (unsigned char c = 0; c < LEDNUM; c++) {
1032C  0E00     MOVLW 0x0
1032E  0101     MOVLB 0x1
10330  6FE9     MOVWF 0xE9, BANKED
10332  0E0B     MOVLW 0xB
10334  65E9     CPFSGT 0xE9, BANKED
10336  D001     BRA 0x33A
10338  D019     BRA 0x36C
10362  0101     MOVLB 0x1
10364  2BE9     INCF 0xE9, F, BANKED
10366  D7E5     BRA 0x332
157:           				led[c] = 0;
1033A  51E9     MOVF 0xE9, W, BANKED
1033C  0D01     MULLW 0x1
1033E  0E6C     MOVLW 0x6C
10340  24F3     ADDWF PROD, W, ACCESS
10342  6ED9     MOVWF FSR2, ACCESS
10344  0E00     MOVLW 0x0
10346  20F4     ADDWFC PRODH, W, ACCESS
10348  6EDA     MOVWF FSR2H, ACCESS
1034A  0E00     MOVLW 0x0
1034C  6EDF     MOVWF INDF2, ACCESS
158:           				waitMs(300);
1034E  0E2C     MOVLW 0x2C
10350  6FD2     MOVWF 0xD2, BANKED
10352  0E01     MOVLW 0x1
10354  6FD3     MOVWF 0xD3, BANKED
10356  0E00     MOVLW 0x0
10358  6FD4     MOVWF 0xD4, BANKED
1035A  0E00     MOVLW 0x0
1035C  6FD5     MOVWF 0xD5, BANKED
1035E  ECD0     CALL 0x11BA0, 0
10360  F08D     NOP
159:           			}
160:           			while (!USB_SLEEP) {
161:           				showBatteryState();
10368  EC66     CALL 0x114CC, 0
1036A  F08A     NOP
162:           			}
1036C  BE8E     BTFSC PORTF, 7, ACCESS
1036E  D7FC     BRA 0x368
163:           			Reset();
10370  00FF     RESET
164:           			mainFlags.shutdown = 0;
10372  9C11     BCF mainFlags, 6, ACCESS
165:           		}
166:           		if (mainFlags.connect) {
10374  AE11     BTFSS mainFlags, 7, ACCESS
10376  D00A     BRA 0x38C
167:           			connect();
10378  ECE6     CALL 0x11DCC, 0
1037A  F08E     NOP
168:           			setSleepDelay(300);
1037C  0E01     MOVLW 0x1
1037E  0101     MOVLB 0x1
10380  6FDF     MOVWF 0xDF, BANKED
10382  0E2C     MOVLW 0x2C
10384  6FDE     MOVWF 0xDE, BANKED
10386  EC28     CALL 0x11A50, 0
10388  F08D     NOP
169:           			mainFlags.connect = 0;
1038A  9E11     BCF mainFlags, 7, ACCESS
170:           		}
171:           		if (mainFlags.connected) {
1038C  A012     BTFSS 0x12, 0, ACCESS
1038E  D00A     BRA 0x3A4
172:           			connected();
10390  EC72     CALL 0x11EE4, 0
10392  F08F     NOP
173:           			setSleepDelay(300);
10394  0E01     MOVLW 0x1
10396  0101     MOVLB 0x1
10398  6FDF     MOVWF 0xDF, BANKED
1039A  0E2C     MOVLW 0x2C
1039C  6FDE     MOVWF 0xDE, BANKED
1039E  EC28     CALL 0x11A50, 0
103A0  F08D     NOP
174:           			mainFlags.connected = 0;
103A2  9012     BCF 0x12, 0, ACCESS
175:           		}
176:           		if (mainFlags.disconnect) {
103A4  A212     BTFSS 0x12, 1, ACCESS
103A6  D00A     BRA 0x3BC
177:           			disconnect();
103A8  EC6F     CALL 0x11CDE, 0
103AA  F08E     NOP
178:           			setSleepDelay(300);
103AC  0E01     MOVLW 0x1
103AE  0101     MOVLB 0x1
103B0  6FDF     MOVWF 0xDF, BANKED
103B2  0E2C     MOVLW 0x2C
103B4  6FDE     MOVWF 0xDE, BANKED
103B6  EC28     CALL 0x11A50, 0
103B8  F08D     NOP
179:           			mainFlags.disconnect = 0;
103BA  9212     BCF 0x12, 1, ACCESS
180:           		}
181:           
182:           		if (!mainFlags.all && TX5STAbits.TRMT && TX2STAbits.TRMT) {
103BC  5011     MOVF mainFlags, W, ACCESS
103BE  1012     IORWF 0x12, W, ACCESS
103C0  A4D8     BTFSS STATUS, 2, ACCESS
103C2  D010     BRA 0x3E4
103C4  010E     MOVLB 0xE
103C6  B3E1     BTFSC 0xE1, 1, BANKED
103C8  A3F6     BTFSS 0xF6, 1, BANKED
103CA  D00C     BRA 0x3E4
183:           			IDLEN = 1;
103CC  8F42     BSF lastPush, 7, BANKED
184:           			Sleep();
103CE  0003     SLEEP
185:           		}
186:           		
187:           		while(bufDataExist(&bufU2_intH))			SendCharBT(bufRead(&bufU2_intH));
103D0  D009     BRA 0x3E4
103D2  0EB4     MOVLW 0xB4
103D4  0101     MOVLB 0x1
103D6  6FD2     MOVWF 0xD2, BANKED
103D8  0E00     MOVLW 0x0
103DA  6FD3     MOVWF 0xD3, BANKED
103DC  ECEA     CALL 0x115D4, 0
103DE  F08A     NOP
103E0  ECD4     CALL 0x11DA8, 0
103E2  F08E     NOP
103E4  0EB4     MOVLW 0xB4
103E6  0101     MOVLB 0x1
103E8  6FD2     MOVWF 0xD2, BANKED
103EA  0E00     MOVLW 0x0
103EC  6FD3     MOVWF 0xD3, BANKED
103EE  EC84     CALL 0x11D08, 0
103F0  F08E     NOP
103F2  0900     IORLW 0x0
103F4  B4D8     BTFSC STATUS, 2, ACCESS
103F6  D00A     BRA 0x40C
103F8  D7EC     BRA 0x3D2
188:           		while(bufDataExist(&bufU2_intL))			SendCharBT(bufRead(&bufU2_intL));
103FA  0E18     MOVLW 0x18
103FC  0101     MOVLB 0x1
103FE  6FD2     MOVWF 0xD2, BANKED
10400  0E00     MOVLW 0x0
10402  6FD3     MOVWF 0xD3, BANKED
10404  ECEA     CALL 0x115D4, 0
10406  F08A     NOP
10408  ECD4     CALL 0x11DA8, 0
1040A  F08E     NOP
1040C  0E18     MOVLW 0x18
1040E  0101     MOVLB 0x1
10410  6FD2     MOVWF 0xD2, BANKED
10412  0E00     MOVLW 0x0
10414  6FD3     MOVWF 0xD3, BANKED
10416  EC84     CALL 0x11D08, 0
10418  F08E     NOP
1041A  0900     IORLW 0x0
1041C  B4D8     BTFSC STATUS, 2, ACCESS
1041E  D00A     BRA 0x434
10420  D7EC     BRA 0x3FA
189:           		while(bufDataExist(&bufU2_main))			SendCharBT(bufRead(&bufU2_main));
10422  0EAF     MOVLW 0xAF
10424  0101     MOVLB 0x1
10426  6FD2     MOVWF 0xD2, BANKED
10428  0E00     MOVLW 0x0
1042A  6FD3     MOVWF 0xD3, BANKED
1042C  ECEA     CALL 0x115D4, 0
1042E  F08A     NOP
10430  ECD4     CALL 0x11DA8, 0
10432  F08E     NOP
10434  0EAF     MOVLW 0xAF
10436  0101     MOVLB 0x1
10438  6FD2     MOVWF 0xD2, BANKED
1043A  0E00     MOVLW 0x0
1043C  6FD3     MOVWF 0xD3, BANKED
1043E  EC84     CALL 0x11D08, 0
10440  F08E     NOP
10442  0900     IORLW 0x0
10444  B4D8     BTFSC STATUS, 2, ACCESS
10446  D00A     BRA 0x45C
10448  D7EC     BRA 0x422
190:           		while(bufDataExist(&bufU5_intH))			SendCharUSB(bufRead(&bufU5_intH));
1044A  0E22     MOVLW 0x22
1044C  0101     MOVLB 0x1
1044E  6FD2     MOVWF 0xD2, BANKED
10450  0E00     MOVLW 0x0
10452  6FD3     MOVWF 0xD3, BANKED
10454  ECEA     CALL 0x115D4, 0
10456  F08A     NOP
10458  ECF5     CALL 0x11DEA, 0
1045A  F08E     NOP
1045C  0E22     MOVLW 0x22
1045E  0101     MOVLB 0x1
10460  6FD2     MOVWF 0xD2, BANKED
10462  0E00     MOVLW 0x0
10464  6FD3     MOVWF 0xD3, BANKED
10466  EC84     CALL 0x11D08, 0
10468  F08E     NOP
1046A  0900     IORLW 0x0
1046C  B4D8     BTFSC STATUS, 2, ACCESS
1046E  D00A     BRA 0x484
10470  D7EC     BRA 0x44A
191:           		while(bufDataExist(&bufU5_intL))			SendCharUSB(bufRead(&bufU5_intL));
10472  0E1D     MOVLW 0x1D
10474  0101     MOVLB 0x1
10476  6FD2     MOVWF 0xD2, BANKED
10478  0E00     MOVLW 0x0
1047A  6FD3     MOVWF 0xD3, BANKED
1047C  ECEA     CALL 0x115D4, 0
1047E  F08A     NOP
10480  ECF5     CALL 0x11DEA, 0
10482  F08E     NOP
10484  0E1D     MOVLW 0x1D
10486  0101     MOVLB 0x1
10488  6FD2     MOVWF 0xD2, BANKED
1048A  0E00     MOVLW 0x0
1048C  6FD3     MOVWF 0xD3, BANKED
1048E  EC84     CALL 0x11D08, 0
10490  F08E     NOP
10492  0900     IORLW 0x0
10494  B4D8     BTFSC STATUS, 2, ACCESS
10496  D00A     BRA 0x4AC
10498  D7EC     BRA 0x472
192:           		while(bufDataExist(&bufU5_main))			SendCharUSB(bufRead(&bufU5_main));
1049A  0EAA     MOVLW 0xAA
1049C  0101     MOVLB 0x1
1049E  6FD2     MOVWF 0xD2, BANKED
104A0  0E00     MOVLW 0x0
104A2  6FD3     MOVWF 0xD3, BANKED
104A4  ECEA     CALL 0x115D4, 0
104A6  F08A     NOP
104A8  ECF5     CALL 0x11DEA, 0
104AA  F08E     NOP
104AC  0EAA     MOVLW 0xAA
104AE  0101     MOVLB 0x1
104B0  6FD2     MOVWF 0xD2, BANKED
104B2  0E00     MOVLW 0x0
104B4  6FD3     MOVWF 0xD3, BANKED
104B6  EC84     CALL 0x11D08, 0
104B8  F08E     NOP
104BA  0900     IORLW 0x0
104BC  B4D8     BTFSC STATUS, 2, ACCESS
104BE  D680     BRA 0x1C0
104C0  D7EC     BRA 0x49A
193:           	}
194:           }
195:           
196:           void setSleepDelay(unsigned short second) {
197:           	unsigned long t = (unsigned long) second * 1953;
11A50  C1DE     MOVFF second, __pcstackBANK1
11A52  F1D2     NOP
11A54  C1DF     MOVFF c, d
11A56  F1D3     NOP
11A58  0101     MOVLB 0x1
11A5A  6BD4     CLRF 0xD4, BANKED
11A5C  6BD5     CLRF 0xD5, BANKED
11A5E  0EA1     MOVLW 0xA1
11A60  6FD6     MOVWF 0xD6, BANKED
11A62  0E07     MOVLW 0x7
11A64  6FD7     MOVWF 0xD7, BANKED
11A66  0E00     MOVLW 0x0
11A68  6FD8     MOVWF 0xD8, BANKED
11A6A  0E00     MOVLW 0x0
11A6C  6FD9     MOVWF 0xD9, BANKED
11A6E  EC55     CALL 0x11AAA, 0
11A70  F08D     NOP
11A72  C1D2     MOVFF __pcstackBANK1, t
11A74  F1E0     NOP
11A76  C1D3     MOVFF d, 0x1E1
11A78  F1E1     NOP
11A7A  C1D4     MOVFF multiplicand, 0x1E2
11A7C  F1E2     NOP
11A7E  C1D5     MOVFF 0x1D5, 0x1E3
11A80  F1E3     NOP
198:           	if (sleepCountDown < t) {
11A82  0101     MOVLB 0x1
11A84  51E0     MOVF 0xE0, W, BANKED
11A86  5C05     SUBWF sleepCountDown, W, ACCESS
11A88  51E1     MOVF 0xE1, W, BANKED
11A8A  5806     SUBWFB 0x6, W, ACCESS
11A8C  51E2     MOVF 0xE2, W, BANKED
11A8E  5807     SUBWFB 0x7, W, ACCESS
11A90  51E3     MOVF 0xE3, W, BANKED
11A92  5808     SUBWFB 0x8, W, ACCESS
11A94  B0D8     BTFSC STATUS, 0, ACCESS
11A96  0012     RETURN 0
199:           		sleepCountDown = t;
11A98  C1E0     MOVFF t, sleepCountDown
11A9A  F005     NOP
11A9C  C1E1     MOVFF 0x1E1, 0x6
11A9E  F006     NOP
11AA0  C1E2     MOVFF 0x1E2, 0x7
11AA2  F007     NOP
11AA4  C1E3     MOVFF 0x1E3, 0x8
11AA6  F008     NOP
11AA8  0012     RETURN 0
200:           	}
201:           }
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/interrupts.c  -------------------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             #include <xc.h>         /* XC8 General Include File */
6:             
7:             #include <stdint.h>         /* For uint8_t definition */
8:             #include <stdbool.h>        /* For true/false definition */
9:             #include <string.h>
10:            #include "eusart2.h"
11:            #include "eusart5.h"
12:            #include "user.h"
13:            #include "main.h"
14:            #include "FT230X.h"
15:            #include "RN42.h"
16:            #include "sw.h"
17:            #include "ringBuffer.h"
18:            
19:            static const unsigned char connectedString[] = "-CONNECT,";
20:            unsigned char connectedStringIndex = 0;
21:            unsigned short aaa;
22:            unsigned short bbb;
23:            unsigned short ccc;
24:            
25:            /******************************************************************************/
26:            /* Interrupt Routines                                                         */
27:            /******************************************************************************/
28:            
29:            /* High-priority service */
30:            void interrupt high_isr(void) {
0808  8245     BSF btemp, 1, ACCESS
10FFE  CFFA     MOVFF PCLATH, 0x2F
31:            	//	static unsigned short UsbHostCount = 0;
32:            	aaa =bbb *ccc;
11046  C00F     MOVFF bbb, __pcstackCOMRAM
33:            	RG6 = 1;
11062  8C8F     BSF PORTG, 6, ACCESS
34:            	if (PIR5bits.TMR1IF) {
11064  010E     MOVLB 0xE
35:            		//500k / 256 = 1953.125Hz
36:            		TMR1H = 255;
1106A  68CE     SETF TMR1H, ACCESS
37:            		PIR5bits.TMR1IF = 0;
1106C  9138     BCF 0x38, 0, BANKED
38:            
39:            
40:            		//LEDs
41:            		ledMatrixProcess();
1106E  ECDA     CALL 0x113B4, 0
42:            
43:            		//
44:            		time++;
11072  0E01     MOVLW 0x1
45:            		if (sleepCountDown) {
11080  5005     MOVF sleepCountDown, W, ACCESS
46:            			sleepCountDown--;
1108C  0605     DECF sleepCountDown, F, ACCESS
47:            		} else {
11096  D04B     BRA 0x112E
48:            			mainFlags.shutdown = 1;
11098  8C11     BSF mainFlags, 6, ACCESS
49:            		}
50:            	} else if (PIR3bits.RC2IF) {
1109A  D049     BRA 0x112E
51:            		BT_SetReady(0);
110A0  9486     BCF TRISF, 2, ACCESS
52:            		if (RC2STAbits.OERR) {
110A2  A3F5     BTFSS 0xF5, 1, BANKED
53:            			Reset();
110A6  00FF     RESET
54:            			//			RC2STAbits.CREN = 0;
55:            			//			RC2STAbits.CREN = 1;
56:            		} else {
110A8  D042     BRA 0x112E
57:            			unsigned char c = EUSART2_Read();
110AA  EC79     CALL 0x11EF2, 0
58:            
59:            			bufWrite(&bufU5_intH, c);
110B0  0E22     MOVLW 0x22
60:            
61:            			//Check BT connect string
62:            			if (c == connectedString[0]) {
110C0  0EE9     MOVLW 0xE9
63:            				connectedStringIndex = 1;
110D6  0E01     MOVLW 0x1
64:            			} else if (c == connectedString[connectedStringIndex]) {
110DA  5017     MOVF connectedStringIndex, W, ACCESS
65:            				connectedStringIndex++;
110FA  2A17     INCF connectedStringIndex, F, ACCESS
66:            				if (connectedStringIndex == strlen(connectedString)) {
110FC  0EE9     MOVLW 0xE9
67:            					connectedStringIndex = 0;
1111C  0E00     MOVLW 0x0
68:            					mainFlags.connected = 1;
11120  8012     BSF 0x12, 0, ACCESS
69:            				}
70:            			} else {
11122  D002     BRA 0x1128
71:            				connectedStringIndex = 0;
11124  0E00     MOVLW 0x0
72:            			}
73:            
74:            			if (!PIR3bits.RC2IF) {
11128  010E     MOVLB 0xE
75:            				BT_SetReady(1);
1112C  8486     BSF TRISF, 2, ACCESS
76:            			}
77:            		}
78:            	} else {
79:            		/* Unhandled interrupts */
80:            	}
81:            	RG6 = 0;
1112E  9C8F     BCF PORTG, 6, ACCESS
82:            }
11130  C040     MOVFF 0x40, 0x48
83:            
84:            /* Low-priority interrupt routine */
85:            void low_priority interrupt low_isr(void) {
0818  8045     BSF btemp, 0, ACCESS
081A  CFD8     MOVFF STATUS, 0xCF
081C  F0CF     NOP
081E  CFE8     MOVFF WREG, 0xD0
0820  F0D0     NOP
0822  CFE0     MOVFF BSR, 0xD1
0824  F0D1     NOP
0826  CFFA     MOVFF PCLATH, 0xD2
0828  F0D2     NOP
082A  CFFB     MOVFF PCLATU, 0xD3
082C  F0D3     NOP
082E  CFE9     MOVFF FSR0, 0xD4
0830  F0D4     NOP
0832  CFEA     MOVFF FSR0H, 0xD5
0834  F0D5     NOP
0836  CFE1     MOVFF FSR1, 0xD6
0838  F0D6     NOP
083A  CFE2     MOVFF FSR1H, 0xD7
083C  F0D7     NOP
083E  CFD9     MOVFF FSR2, 0xD8
0840  F0D8     NOP
0842  CFDA     MOVFF FSR2H, 0xD9
0844  F0D9     NOP
0846  CFF3     MOVFF PROD, 0xDA
0848  F0DA     NOP
084A  CFF4     MOVFF PRODH, 0xDB
084C  F0DB     NOP
084E  CFF6     MOVFF TBLPTR, 0xDC
0850  F0DC     NOP
0852  CFF7     MOVFF TBLPTRH, 0xDD
0854  F0DD     NOP
0856  CFF8     MOVFF TBLPTRU, 0xDE
0858  F0DE     NOP
085A  CFF5     MOVFF TABLAT, 0xDF
085C  F0DF     NOP
085E  C045     MOVFF btemp, 0xE0
0860  F0E0     NOP
0862  C046     MOVFF 0x46, 0xE1
0864  F0E1     NOP
0866  C047     MOVFF 0x47, 0xE2
0868  F0E2     NOP
086A  C048     MOVFF 0x48, 0xE3
086C  F0E3     NOP
86:            	static unsigned short cnt = 0;
87:            
88:            	RG7 = 1;
086E  8E8F     BSF PORTG, 7, ACCESS
89:            	if (PIR4bits.RC5IF) {
0870  010E     MOVLB 0xE
0872  AB37     BTFSS 0x37, 5, BANKED
0874  D03D     BRA 0x8F0
90:            		USB_SetReady(0);
0876  907E     BCF LATF, 0, ACCESS
91:            		if (RC5STAbits.OERR) {
0878  A3E0     BTFSS 0xE0, 1, BANKED
087A  D002     BRA 0x880
92:            			Reset();
087C  00FF     RESET
93:            			//			RC5STAbits.CREN = 0;
94:            			//			RC5STAbits.CREN = 1;
95:            		} else {
087E  D05D     BRA 0x93A
96:            			unsigned char c = EUSART5_Read();
0880  EC76     CALL 0x11EEC, 0
0882  F08F     NOP
0884  0100     MOVLB 0x0
0886  6FE5     MOVWF c, BANKED
97:            
98:            			bufWrite(&bufU5_intL, c);
0888  0E1D     MOVLW 0x1D
088A  6FB9     MOVWF __pcstackBANK0, BANKED
088C  0E00     MOVLW 0x0
088E  6FBA     MOVWF 0xBA, BANKED
0890  C0E5     MOVFF c, sameCol
0892  F0BB     NOP
0894  EC61     CALL 0x116C2, 0
0896  F08B     NOP
99:            
100:           			if (c == '!') {
0898  0E21     MOVLW 0x21
089A  0100     MOVLB 0x0
089C  19E5     XORWF c, W, BANKED
089E  A4D8     BTFSS STATUS, 2, ACCESS
08A0  D002     BRA 0x8A6
101:           				BT_Reset(1);
08A2  9879     BCF LATA, 4, ACCESS
102:           			} else if (c == '@') {
08A4  D020     BRA 0x8E6
08A6  0E40     MOVLW 0x40
08A8  19E5     XORWF c, W, BANKED
08AA  A4D8     BTFSS STATUS, 2, ACCESS
08AC  D002     BRA 0x8B2
103:           				BT_Reset(0);
08AE  8879     BSF LATA, 4, ACCESS
104:           				//				mainFlags.disconnect = 1;
105:           			} else if (c == '#') {
08B0  D01A     BRA 0x8E6
08B2  0E23     MOVLW 0x23
08B4  19E5     XORWF c, W, BANKED
08B6  A4D8     BTFSS STATUS, 2, ACCESS
08B8  D002     BRA 0x8BE
106:           				Reset();
08BA  00FF     RESET
107:           			} else if (c == '%') {
08BC  D014     BRA 0x8E6
08BE  0E25     MOVLW 0x25
08C0  0100     MOVLB 0x0
08C2  19E5     XORWF c, W, BANKED
08C4  B4D8     BTFSC STATUS, 2, ACCESS
08C6  D00F     BRA 0x8E6
108:           				//				enterCommand();
109:           			} else if (c == '^') {
08C8  0E5E     MOVLW 0x5E
08CA  19E5     XORWF c, W, BANKED
08CC  B4D8     BTFSC STATUS, 2, ACCESS
08CE  D00B     BRA 0x8E6
110:           				//				endCommand();
111:           			} else if (c == 0) {
08D0  51E5     MOVF c, W, BANKED
08D2  B4D8     BTFSC STATUS, 2, ACCESS
08D4  D008     BRA 0x8E6
112:           			} else {
113:           				bufWrite(&bufU2_intL, c);
08D6  0E18     MOVLW 0x18
08D8  6FB9     MOVWF __pcstackBANK0, BANKED
08DA  0E00     MOVLW 0x0
08DC  6FBA     MOVWF 0xBA, BANKED
08DE  C0E5     MOVFF c, sameCol
08E0  F0BB     NOP
08E2  EC61     CALL 0x116C2, 0
08E4  F08B     NOP
114:           			}
115:           
116:           			if (!PIR4bits.RC5IF) {
08E6  010E     MOVLB 0xE
08E8  BB37     BTFSC 0x37, 5, BANKED
08EA  D027     BRA 0x93A
117:           				USB_SetReady(1);
08EC  807E     BSF LATF, 0, ACCESS
118:           			}
119:           		}
120:           	} else if (PIR5bits.TMR3IF) {
08EE  D025     BRA 0x93A
08F0  A538     BTFSS 0x38, 2, BANKED
08F2  D023     BRA 0x93A
121:           		//500k / 256 / 10 = 195.3125Hz
122:           		TMR3H = 246;
08F4  0EF6     MOVLW 0xF6
08F6  6EC8     MOVWF TMR3H, ACCESS
123:           		PIR5bits.TMR3IF = 0;
08F8  9538     BCF 0x38, 2, BANKED
124:           
125:           		//BT connection status
126:           		checkBtState();
08FA  EC49     CALL 0x11E92, 0
08FC  F08F     NOP
127:           
128:           		//SW1 
129:           		sw1Process();
08FE  EC83     CALL 0x11906, 0
0900  F08C     NOP
130:           
131:           		//SW101-172
132:           		swProcess();
0902  EC61     CALL 0x104C2, 0
0904  F082     NOP
133:           
134:           		if (++cnt == 1000) {
0906  4A0B     INFSNZ cnt, F, ACCESS
0908  2A0C     INCF 0xC, F, ACCESS
090A  0EE8     MOVLW 0xE8
090C  180B     XORWF cnt, W, ACCESS
090E  E108     BNZ 0x920
0910  0E03     MOVLW 0x3
0912  180C     XORWF 0xC, W, ACCESS
0914  A4D8     BTFSS STATUS, 2, ACCESS
0916  D004     BRA 0x920
135:           			//			swProcess();
136:           			cnt = 0;
0918  0E00     MOVLW 0x0
091A  6E0C     MOVWF 0xC, ACCESS
091C  0E00     MOVLW 0x0
091E  6E0B     MOVWF cnt, ACCESS
137:           		}
138:           
139:           		//Battery charge current
140:           		Chg400mAEn(USB_UpTo400mA);
0920  0E00     MOVLW 0x0
0922  0100     MOVLB 0x0
0924  6FE4     MOVWF 0xE4, BANKED
0926  AC8E     BTFSS PORTF, 6, ACCESS
0928  AE8E     BTFSS PORTF, 7, ACCESS
092A  D002     BRA 0x930
092C  0E01     MOVLW 0x1
092E  6FE4     MOVWF 0xE4, BANKED
0930  B1E4     BTFSC 0xE4, 0, BANKED
0932  D002     BRA 0x938
0934  987E     BCF LATF, 4, ACCESS
0936  D001     BRA 0x93A
0938  887E     BSF LATF, 4, ACCESS
141:           	}//	else if (PIR2bits.HLVDIF)
142:           		//	{
143:           		//		LED1 = 1;
144:           		//		BT_Reset(1);
145:           		//		PIE2bits.HLVDIE = 0;
146:           		//		PMD0 = 0xff;
147:           		//		PMD1 = 0xff;
148:           		//		PMD2 = 0xff;
149:           		//		PMD3 = 0xff;
150:           		//		PMD4 = 0xff;
151:           		//		PMD5 = 0xff;
152:           		//
153:           		//		LED1 = 0;
154:           		//
155:           		//		//TODO more low power
156:           		//		Sleep();
157:           		//		Reset();
158:           		//	}
159:           		//	else if (PIR0bits.IOCIF)
160:           		//	{
161:           		//
162:           		//		//	mainFlags.FlagCheckSwMatrix = 1;
163:           		//		IOCBF = 0x00;
164:           		//		IOCEF = 0x00;
165:           		//	}
166:           	else {
167:           	}
168:           	RG7 = 0;
093A  9E8F     BCF PORTG, 7, ACCESS
169:           }
093C  C0E3     MOVFF 0xE3, 0x48
093E  F048     NOP
0940  C0E2     MOVFF 0xE2, 0x47
0942  F047     NOP
0944  C0E1     MOVFF 0xE1, 0x46
0946  F046     NOP
0948  C0E0     MOVFF 0xE0, btemp
094A  F045     NOP
094C  C0DF     MOVFF 0xDF, TABLAT
094E  FFF5     NOP
0950  C0DE     MOVFF 0xDE, TBLPTRU
0952  FFF8     NOP
0954  C0DD     MOVFF 0xDD, TBLPTRH
0956  FFF7     NOP
0958  C0DC     MOVFF 0xDC, TBLPTR
095A  FFF6     NOP
095C  C0DB     MOVFF 0xDB, PRODH
095E  FFF4     NOP
0960  C0DA     MOVFF 0xDA, PROD
0962  FFF3     NOP
0964  C0D9     MOVFF 0xD9, FSR2H
0966  FFDA     NOP
0968  C0D8     MOVFF 0xD8, FSR2
096A  FFD9     NOP
096C  C0D7     MOVFF 0xD7, FSR1H
096E  FFE2     NOP
0970  C0D6     MOVFF 0xD6, FSR1
0972  FFE1     NOP
0974  C0D5     MOVFF 0xD5, FSR0H
0976  FFEA     NOP
0978  C0D4     MOVFF 0xD4, FSR0
097A  FFE9     NOP
097C  C0D3     MOVFF 0xD3, PCLATU
097E  FFFB     NOP
0980  C0D2     MOVFF 0xD2, PCLATH
0982  FFFA     NOP
0984  C0D1     MOVFF 0xD1, BSR
0986  FFE0     NOP
0988  C0D0     MOVFF 0xD0, WREG
098A  FFE8     NOP
098C  C0CF     MOVFF 0xCF, STATUS
098E  FFD8     NOP
0990  9045     BCF btemp, 0, ACCESS
0992  0010     RETFIE 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/eusart5.c  ----------------------------------
1:             /**
2:               EUSART5 Generated Driver File
3:             
4:               @Company
5:             	Microchip Technology Inc.
6:             
7:               @File Name
8:             	eusart5.c
9:             
10:              @Summary
11:            	This is the generated driver implementation file for the EUSART5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:            	This source file provides APIs for EUSART5.
15:            	Generation Information :
16:            		Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:            		Device            :  PIC18LF67K40
18:            		Driver Version    :  2.00
19:            	The generated drivers are tested against the following:
20:            		Compiler          :  XC8 1.45
21:            		MPLAB 	          :  MPLAB X 4.10
22:             */
23:            /*
24:            	(c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:            	software and any derivatives exclusively with Microchip products.
26:            
27:            	THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            	EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            	WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            	PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:            	WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:            
33:            	IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:            	INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:            	WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:            	BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:            	FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:            	ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:            	THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:            
41:            	MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:            	TERMS.
43:             */
44:            /**
45:              Section: Included Files
46:             */
47:            #include "eusart5.h"
48:            #include "user.h"
49:            
50:            /**
51:              Section: EUSART5 APIs
52:             */
53:            void EUSART5_Initialize(void)
54:            {
55:            	// Set the EUSART5 module to the options selected in the user interface.
56:            
57:            	// ABDOVF no_overflow; SCKP Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
58:            	BAUD5CON = 0x18;
11E20  0E18     MOVLW 0x18
11E22  010E     MOVLB 0xE
11E24  6FE2     MOVWF 0xE2, BANKED
59:            
60:            	// SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
61:            	RC5STA = 0x90;
11E26  0E90     MOVLW 0x90
11E28  6FE0     MOVWF 0xE0, BANKED
62:            
63:            	// TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
64:            	TX5STA = 0x24;
11E2A  0E24     MOVLW 0x24
11E2C  6FE1     MOVWF 0xE1, BANKED
65:            
66:            	// SP5BRGL 34; 
67:            	SP5BRGL = 0x22;
11E2E  0E22     MOVLW 0x22
11E30  6FDE     MOVWF 0xDE, BANKED
68:            
69:            	// SP5BRGH 0; 
70:            	SP5BRGH = 0x00;
11E32  0E00     MOVLW 0x0
11E34  6FDF     MOVWF 0xDF, BANKED
71:            
72:            
73:            }
11E36  0012     RETURN 0
74:            
75:            uint8_t EUSART5_Read(void)
76:            {
77:            	return RC5REG;
11EEC  010E     MOVLB 0xE
11EEE  51DC     MOVF 0xDC, W, BANKED
11EF0  0012     RETURN 0
78:            }
0808  8245     BSF btemp, 1, ACCESS
79:            
80:            void EUSART5_Write(uint8_t txData)
11EC8  0101     MOVLB 0x1
11ECA  6FD2     MOVWF 0xD2, BANKED
81:            {
82:            	while (!PIR4bits.TX5IF);
11ECC  010E     MOVLB 0xE
11ECE  A937     BTFSS 0x37, 4, BANKED
11ED0  D7FD     BRA 0x1ECC
83:            
84:            	TX5REG = txData; // Write the data byte to the USART.
11ED2  C1D2     MOVFF __pcstackBANK1, TX5REG
11ED4  FEDD     NOP
85:            }
11ED6  0012     RETURN 0
86:            
87:            /**
88:              End of File
89:             */
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/eusart2.c  ----------------------------------
1:             /**
2:               EUSART2 Generated Driver File
3:             
4:               @Company
5:             	Microchip Technology Inc.
6:             
7:               @File Name
8:             	eusart2.c
9:             
10:              @Summary
11:            	This is the generated driver implementation file for the EUSART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:            	This source file provides APIs for EUSART2.
15:            	Generation Information :
16:            		Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:            		Device            :  PIC18LF67K40
18:            		Driver Version    :  2.00
19:            	The generated drivers are tested against the following:
20:            		Compiler          :  XC8 1.45
21:            		MPLAB 	          :  MPLAB X 4.10
22:             */
23:            /*
24:            	(c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:            	software and any derivatives exclusively with Microchip products.
26:            
27:            	THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            	EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            	WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            	PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:            	WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:            
33:            	IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:            	INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:            	WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:            	BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:            	FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:            	ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:            	THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:            
41:            	MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:            	TERMS.
43:             */
44:            /**
45:              Section: Included Files
46:             */
47:            #include "eusart2.h"
48:            
49:            /**
50:              Section: EUSART2 APIs
51:             */
52:            void EUSART2_Initialize(void)
53:            {
54:            	// Set the EUSART2 module to the options selected in the user interface.
55:            
56:            	// ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
57:            	BAUD2CON = 0x08;
11E38  0E08     MOVLW 0x8
11E3A  010E     MOVLB 0xE
11E3C  6FF7     MOVWF 0xF7, BANKED
58:            
59:            	// SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
60:            	RC2STA = 0x90;
11E3E  0E90     MOVLW 0x90
11E40  6FF5     MOVWF 0xF5, BANKED
61:            
62:            	// TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
63:            	TX2STA = 0x24;
11E42  0E24     MOVLW 0x24
11E44  6FF6     MOVWF 0xF6, BANKED
64:            
65:            	// SP2BRGL 34; 
66:            	SP2BRGL = 0x22;
11E46  0E22     MOVLW 0x22
11E48  6FF3     MOVWF 0xF3, BANKED
67:            
68:            	// SP2BRGH 0; 
69:            	SP2BRGH = 0x00;
11E4A  0E00     MOVLW 0x0
11E4C  6FF4     MOVWF 0xF4, BANKED
70:            
71:            
72:            }
11E4E  0012     RETURN 0
73:            
74:            uint8_t EUSART2_Read(void)
75:            {
76:            	return RC2REG;
11EF2  010E     MOVLB 0xE
11EF4  51F1     MOVF 0xF1, W, BANKED
11EF6  0012     RETURN 0
77:            }
78:            
79:            void EUSART2_Write(uint8_t txData)
11EB8  0101     MOVLB 0x1
11EBA  6FD2     MOVWF 0xD2, BANKED
80:            {
81:            	while (!PIR3bits.TX2IF);
11EBC  010E     MOVLB 0xE
11EBE  AD36     BTFSS 0x36, 6, BANKED
11EC0  D7FD     BRA 0x1EBC
82:            
83:            	TX2REG = txData; // Write the data byte to the USART.
11EC2  C1D2     MOVFF __pcstackBANK1, TX2REG
11EC4  FEF2     NOP
84:            }
11EC6  0012     RETURN 0
85:            
86:            /**
87:              End of File
88:             */
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/adcc.c  -------------------------------------
1:             /**
2:               ADCC Generated Driver File
3:             
4:               @Company
5:             	Microchip Technology Inc.
6:             
7:               @File Name
8:             	adcc.c
9:             
10:              @Summary
11:            	This is the generated driver implementation file for the ADCC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:            	This source file provides implementations for driver APIs for ADCC.
15:            	Generation Information :
16:            		Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:            		Device            :  PIC18LF67K40
18:            		Driver Version    :  2.00
19:            	The generated drivers are tested against the following:
20:            		Compiler          :  XC8 1.45
21:            		MPLAB             :  MPLAB X 4.10
22:             */
23:            
24:            /*
25:            	(c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:            	software and any derivatives exclusively with Microchip products.
27:            
28:            	THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:            	EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:            	WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:            	PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:            	WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:            	IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:            	INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:            	WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:            	BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:            	FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:            	ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:            	THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:            	MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:            	TERMS.
44:             */
45:            
46:            /**
47:              Section: Included Files
48:             */
49:            
50:            #include <xc.h>
51:            #include "adcc.h"
52:            
53:            /**
54:              Section: ADCC Module Variables
55:             */
56:            
57:            /**
58:              Section: ADCC Module APIs
59:             */
60:            
61:            void ADCC_Initialize(void)
62:            {
63:            	// set the ADCC to the options selected in the User Interface
64:            	// ADLTHL 0; 
65:            	ADLTHL = 0x00;
11B56  0E00     MOVLW 0x0
11B58  6E6A     MOVWF ADLTH, ACCESS
66:            	// ADLTHH 0; 
67:            	ADLTHH = 0x00;
11B5A  0E00     MOVLW 0x0
11B5C  6E6B     MOVWF ADLTHH, ACCESS
68:            	// ADUTHL 0; 
69:            	ADUTHL = 0x00;
11B5E  0E00     MOVLW 0x0
11B60  6E6C     MOVWF ADUTH, ACCESS
70:            	// ADUTHH 0; 
71:            	ADUTHH = 0x00;
11B62  0E00     MOVLW 0x0
11B64  6E6D     MOVWF ADUTHH, ACCESS
72:            	// ADSTPTL 0; 
73:            	ADSTPTL = 0x00;
11B66  0E00     MOVLW 0x0
11B68  6E68     MOVWF ADSTPT, ACCESS
74:            	// ADSTPTH 0; 
75:            	ADSTPTH = 0x00;
11B6A  0E00     MOVLW 0x0
11B6C  6E69     MOVWF ADSTPTH, ACCESS
76:            	// ADRPT 0; 
77:            	ADRPT = 0x00;
11B6E  0E00     MOVLW 0x0
11B70  6E66     MOVWF ADRPT, ACCESS
78:            	// ADPCH ANA0; 
79:            	ADPCH = 0x00;
11B72  0E00     MOVLW 0x0
11B74  010F     MOVLB 0xF
11B76  6F5F     MOVWF 0x5F, BANKED
80:            	// ADCAP Additional uC disabled; 
81:            	ADCAP = 0x00;
11B78  0E00     MOVLW 0x0
11B7A  6F5D     MOVWF 0x5D, BANKED
82:            	// ADDSEN disabled; ADGPOL digital_low; ADIPEN disabled; ADPPOL VSS; 
83:            	ADCON1 = 0x00;
11B7C  0E00     MOVLW 0x0
11B7E  6F59     MOVWF 0x59, BANKED
84:            	// ADCRS 0; ADMD Basic_mode; ADACLR disabled; ADPSIS ADFLTR; 
85:            	ADCON2 = 0x00;
11B80  0E00     MOVLW 0x0
11B82  6F5A     MOVWF 0x5A, BANKED
86:            	// ADCALC First derivative of Single measurement; ADTMD disabled; ADSOI ADGO not cleared; 
87:            	ADCON3 = 0x00;
11B84  0E00     MOVLW 0x0
11B86  6F5B     MOVWF 0x5B, BANKED
88:            	ADACQ = 255;
11B88  695C     SETF 0x5C, BANKED
89:            	// ADAOV ACC or ADERR not Overflowed; 
90:            	ADSTAT = 0x00;
11B8A  0E00     MOVLW 0x0
11B8C  6E65     MOVWF ADSTAT, ACCESS
91:            	// ADNREF VSS; ADPREF FVR; 
92:            	ADREF = 0x03;
11B8E  0E03     MOVLW 0x3
11B90  6F58     MOVWF 0x58, BANKED
93:            	// ADACT disabled; 
94:            	ADACT = 0x00;
11B92  0E00     MOVLW 0x0
11B94  6F56     MOVWF 0x56, BANKED
95:            	// ADCS FOSC/2; 
96:            	ADCLK = 0x00;
11B96  0E00     MOVLW 0x0
11B98  6F57     MOVWF 0x57, BANKED
97:            	// ADGO stop; ADFM right; ADON enabled; ADCONT disabled; ADCS FRC; 
98:            	ADCON0 = 0x94;
11B9A  0E94     MOVLW 0x94
11B9C  6E60     MOVWF ADCON0, ACCESS
99:            
100:           
101:           }
11B9E  0012     RETURN 0
102:           
103:           //void ADCC_StartConversion(adcc_channel_t channel)
104:           //{
105:           //	// select the A/D channel
106:           //	ADPCH = channel;
107:           //
108:           //	// Turn on the ADC module
109:           //	ADCON0bits.ADON = 1;
110:           //
111:           //	// Start the conversion
112:           //	ADCON0bits.ADGO = 1;
113:           //}
114:           //
115:           //bool ADCC_IsConversionDone()
116:           //{
117:           //	// Start the conversion
118:           //	return ((unsigned char) (!ADCON0bits.ADGO));
119:           //}
120:           //
121:           //adc_result_t ADCC_GetConversionResult(void)
122:           //{
123:           //	// Return the result
124:           //	return ((adc_result_t) ((ADRESH << 8) + ADRESL));
125:           //}
126:           
127:           adc_result_t ADCC_GetSingleConversion(adcc_channel_t channel)
11D5A  0101     MOVLB 0x1
11D5C  6FD6     MOVWF 0xD6, BANKED
128:           {
129:           	// select the A/D channel
130:           	ADPCH = channel;
11D5E  C1D6     MOVFF multiplicand, ADPCH
11D60  FF5F     NOP
131:           
132:           	// Turn on the ADC module
133:           	ADCON0bits.ADON = 1;
11D62  8E60     BSF ADCON0, 7, ACCESS
134:           
135:           	//Disable the continuous mode.
136:           	ADCON0bits.ADCONT = 0;
11D64  9C60     BCF ADCON0, 6, ACCESS
137:           
138:           	// Start the conversion
139:           	ADCON0bits.ADGO = 1;
11D66  8060     BSF ADCON0, 0, ACCESS
140:           
141:           
142:           	// Wait for the conversion to finish
143:           	while (ADCON0bits.ADGO)
11D68  B060     BTFSC ADCON0, 0, ACCESS
11D6A  D7FE     BRA 0x1D68
144:           	{
145:           	}
146:           
147:           
148:           	// Conversion finished, return the result
149:           	return ((adc_result_t) ((ADRESH << 8) + ADRESL));
11D6C  5064     MOVF ADRESH, W, ACCESS
11D6E  0101     MOVLB 0x1
11D70  6FD5     MOVWF 0xD5, BANKED
11D72  6BD4     CLRF 0xD4, BANKED
11D74  5063     MOVF ADRES, W, ACCESS
11D76  25D4     ADDWF 0xD4, W, BANKED
11D78  6FD2     MOVWF 0xD2, BANKED
11D7A  0E00     MOVLW 0x0
11D7C  21D5     ADDWFC 0xD5, W, BANKED
11D7E  6FD3     MOVWF 0xD3, BANKED
11D80  0012     RETURN 0
150:           }
151:           
152:           //void ADCC_StopConversion(void)
153:           //{
154:           //	//Reset the ADGO bit.
155:           //	ADCON0bits.ADGO = 0;
156:           //}
157:           //
158:           //void ADCC_SetStopOnInterrupt(void)
159:           //{
160:           //	//Set the ADSOI bit.
161:           //	ADCON3bits.ADSOI = 1;
162:           //}
163:           //
164:           //void ADCC_DischargeSampleCapacitor(void)
165:           //{
166:           //	//Set the ADC channel to AVss.
167:           //	ADPCH = 0x3C;
168:           //}
169:           //
170:           //void ADCC_LoadAcquisitionRegister(uint8_t acquisitionValue)
171:           //{
172:           //	//Load the ADACQ register.
173:           //	ADACQ = acquisitionValue;
174:           //}
175:           //
176:           //void ADCC_SetPrechargeTime(uint8_t prechargeTime)
177:           //{
178:           //	//Load the ADPRE register.
179:           //	ADPRE = prechargeTime;
180:           //}
181:           //
182:           //void ADCC_SetRepeatCount(uint8_t repeatCount)
183:           //{
184:           //	//Load the ADRPT register.
185:           //	ADRPT = repeatCount;
186:           //}
187:           //
188:           //uint8_t ADCC_GetCurrentCountofConversions(void)
189:           //{
190:           //	//Return the contents of ADCNT register
191:           //	return ADCNT;
192:           //}
193:           //
194:           //void ADCC_ClearAccumulator(void)
195:           //{
196:           //	//Reset the ADCON2bits.ADACLR bit.
197:           //	ADCON2bits.ADACLR = 1;
198:           //}
199:           //
200:           //uint16_t ADCC_GetAccumulatorValue(void)
201:           //{
202:           //	//Return the contents of ADACCH and ADACCL registers
203:           //	return ((uint16_t) ((ADACCH << 8) + ADACCL));
204:           //}
205:           //
206:           //bool ADCC_HasAccumulatorOverflowed(void)
207:           //{
208:           //	//Return the status of ADSTATbits.ADAOV
209:           //	return ADSTATbits.ADAOV;
210:           //}
211:           //
212:           //uint16_t ADCC_GetFilterValue(void)
213:           //{
214:           //	//Return the contents of ADFLTRH and ADFLTRL registers
215:           //	return ((uint16_t) ((ADFLTRH << 8) + ADFLTRL));
216:           //}
217:           //
218:           //uint16_t ADCC_GetPreviousResult(void)
219:           //{
220:           //	//Return the contents of ADPREVH and ADPREVL registers
221:           //	return ((uint16_t) ((ADPREVH << 8) + ADPREVL));
222:           //}
223:           //
224:           //void ADCC_DefineSetPoint(uint16_t setPoint)
225:           //{
226:           //	//Sets the ADSTPTH and ADSTPTL registers
227:           //	ADSTPTH = setPoint >> 8;
228:           //	ADSTPTL = setPoint;
229:           //}
230:           //
231:           //void ADCC_SetUpperThreshold(uint16_t upperThreshold)
232:           //{
233:           //	//Sets the ADUTHH and ADUTHL registers
234:           //	ADUTHH = upperThreshold >> 8;
235:           //	ADUTHL = upperThreshold;
236:           //}
237:           //
238:           //void ADCC_SetLowerThreshold(uint16_t lowerThreshold)
239:           //{
240:           //	//Sets the ADLTHH and ADLTHL registers
241:           //	ADLTHH = lowerThreshold >> 8;
242:           //	ADLTHL = lowerThreshold;
243:           //}
244:           //
245:           //uint16_t ADCC_GetErrorCalculation(void)
246:           //{
247:           //	//Return the contents of ADERRH and ADERRL registers
248:           //	return ((uint16_t) ((ADERRH << 8) + ADERRL));
249:           //}
250:           //
251:           //void ADCC_EnableDoubleSampling(void)
252:           //{
253:           //	//Sets the ADCON1bits.ADDSEN
254:           //	ADCON1bits.ADDSEN = 1;
255:           //}
256:           //
257:           //void ADCC_EnableContinuousConversion(void)
258:           //{
259:           //	//Sets the ADCON0bits.ADCONT
260:           //	ADCON0bits.ADCONT = 1;
261:           //}
262:           //
263:           //void ADCC_DisableContinuousConversion(void)
264:           //{
265:           //	//Resets the ADCON0bits.ADCONT
266:           //	ADCON0bits.ADCONT = 0;
267:           //}
268:           //
269:           //bool ADCC_HasErrorCrossedUpperThreshold(void)
270:           //{
271:           //	//Returns the value of ADSTATbits.ADUTHR bit.
272:           //	return ADSTATbits.ADUTHR;
273:           //}
274:           //
275:           //bool ADCC_HasErrorCrossedLowerThreshold(void)
276:           //{
277:           //	//Returns the value of ADSTATbits.ADLTHR bit.
278:           //	return ADSTATbits.ADLTHR;
279:           //}
280:           //
281:           //uint8_t ADCC_GetConversionStageStatus(void)
282:           //{
283:           //	//Returns the contents of ADSTATbits.ADSTAT field.
284:           //	return ADSTATbits.ADSTAT;
285:           //}
286:           
287:           
288:           /**
289:            End of File
290:            */
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/RN42.c  -------------------------------------
1:             #include <xc.h>         /* XC8 General Include File */
2:             #include "user.h"
3:             
4:             #include "RN42.h"
5:             #include "HID_Define.h"
6:             #include "FT230X.h"
7:             #include "eusart2.h"
8:             #include "eusart5.h"
9:             #include "main.h"
10:            #include "ringBuffer.h"
11:            
12:            unsigned char BtConnected = 0;
13:            
14:            struct KeyReport keyReport;
15:            
16:            struct MouseReport mouseReport;
17:            signed char mouseSpeed = 8;
18:            
19:            unsigned short consumerKey = 0;
20:            unsigned short BtGPIO5LowCount = 0;
21:            
22:            //unsigned char translateToScanCode(unsigned char x)
23:            //{
24:            //	if ('a' <= x && x <= 'z')return x - 'a' + 0x04;
25:            //	if ('1' <= x && x <= '9')return x - '1' + 0x1E;
26:            //	if (x <= '0')return 0x27;
27:            //	if (x <= '0')return 0x27;
28:            //	return 0;
29:            //}
30:            
31:            void connected(void){
32:            	BtConnected = 1;
11EE4  0E01     MOVLW 0x1
11EE6  0100     MOVLB 0x0
11EE8  6F87     MOVWF BtConnected, BANKED
33:            }
11EEA  0012     RETURN 0
34:            
35:            inline void checkBtState(void)
36:            {
37:            	//call this function from interval timer interrupt
38:            
39:            	if (!BT_GPIO5)
11E92  A28E     BTFSS PORTF, 1, ACCESS
11E94  0012     RETURN 0
40:            	{
41:            //		if (!BtConnected)
42:            //		{
43:            //			if (++BtGPIO5LowCount > 220)
44:            //			{
45:            //				//Low 1.1sec
46:            //				BtConnected = 1;
47:            //			}
48:            //		}
49:            	}
50:            	else
51:            	{
52:            		BtGPIO5LowCount = 0;
11E96  0E00     MOVLW 0x0
11E98  0100     MOVLB 0x0
11E9A  6F84     MOVWF 0x84, BANKED
11E9C  0E00     MOVLW 0x0
11E9E  6F83     MOVWF BtGPIO5LowCount, BANKED
53:            		BtConnected = 0;
11EA0  0E00     MOVLW 0x0
11EA2  6F87     MOVWF BtConnected, BANKED
11EA4  0012     RETURN 0
54:            	}
55:            }
56:            
57:            //void enterCommand(void)
58:            //{
59:            //	BT_Reset(1);
60:            //	disconnect();
61:            //	waitMs(10);
62:            //	BT_Reset(0);
63:            //	waitMs(1);
64:            //
65:            //	bufWrite(&bufU2_main,'$');
66:            //	bufWrite(&bufU2_main,'$');
67:            //	bufWrite(&bufU2_main,'$');
68:            //	waitMs(1);
69:            //
70:            //	bufWrite(&bufU2_main,'G');
71:            //	bufWrite(&bufU2_main,'R');
72:            //	bufWrite(&bufU2_main,'\r');
73:            //}
74:            //
75:            //void endCommand(void)
76:            //{
77:            //	bufWrite(&bufU2_main,'-');
78:            //	bufWrite(&bufU2_main,'-');
79:            //	bufWrite(&bufU2_main,'-');
80:            //	bufWrite(&bufU2_main,'\r');
81:            //}
82:            
83:            void disconnect(void)
84:            {
85:            	//	bufWrite(&bufU2_main,0);
86:            	//	BT_Reset(1);
87:            	BT_Connect(1);
11CDE  8279     BSF LATA, 1, ACCESS
88:            	waitMs(10);
11CE0  0E0A     MOVLW 0xA
11CE2  0101     MOVLB 0x1
11CE4  6FD2     MOVWF 0xD2, BANKED
11CE6  0E00     MOVLW 0x0
11CE8  6FD3     MOVWF 0xD3, BANKED
11CEA  0E00     MOVLW 0x0
11CEC  6FD4     MOVWF 0xD4, BANKED
11CEE  0E00     MOVLW 0x0
11CF0  6FD5     MOVWF 0xD5, BANKED
11CF2  ECD0     CALL 0x11BA0, 0
11CF4  F08D     NOP
89:            	BT_Connect(0);
11CF6  9279     BCF LATA, 1, ACCESS
90:            	BtConnected = 0;
11CF8  0E00     MOVLW 0x0
11CFA  0100     MOVLB 0x0
11CFC  6F87     MOVWF BtConnected, BANKED
91:            	BtGPIO5LowCount = 0;
11CFE  0E00     MOVLW 0x0
11D00  6F84     MOVWF 0x84, BANKED
11D02  0E00     MOVLW 0x0
11D04  6F83     MOVWF BtGPIO5LowCount, BANKED
92:            }
11D06  0012     RETURN 0
93:            
94:            void connect(void)
95:            {
96:            	BT_Connect(0);
11DCC  9279     BCF LATA, 1, ACCESS
97:            	BT_Reset(0);
11DCE  8879     BSF LATA, 4, ACCESS
98:            	waitMs(100);
11DD0  0E64     MOVLW 0x64
11DD2  0101     MOVLB 0x1
11DD4  6FD2     MOVWF 0xD2, BANKED
11DD6  0E00     MOVLW 0x0
11DD8  6FD3     MOVWF 0xD3, BANKED
11DDA  0E00     MOVLW 0x0
11DDC  6FD4     MOVWF 0xD4, BANKED
11DDE  0E00     MOVLW 0x0
11DE0  6FD5     MOVWF 0xD5, BANKED
11DE2  ECD0     CALL 0x11BA0, 0
11DE4  F08D     NOP
99:            	BT_Connect(1);
11DE6  8279     BSF LATA, 1, ACCESS
100:           
101:           	//	BT_Reset(1);
102:           	//	waitMs(1);
103:           	//	BT_Reset(0);
104:           	//	waitMs(5);
105:           	//	bufWrite(&bufU2_main,1);
106:           	//	//	waitMs(10);
107:           	//	//	bufWrite(&bufU2_main,'$');	//SM,2
108:           	//	//	bufWrite(&bufU2_main,'$');
109:           	//	//	bufWrite(&bufU2_main,'$');
110:           	//	//				waitMs(1100);
111:           	//	//	bufWrite(&bufU2_main,'C');
112:           	//	//				bufWrite(&bufU2_main,'F');
113:           	//	//				bufWrite(&bufU2_main,'I');
114:           	//	//		bufWrite(&bufU2_main,'\n');
115:           }
11DE8  0012     RETURN 0
116:           
117:           void switchHost(unsigned char n)
118:           {
119:           
120:           }
121:           
122:           void sendMouse(void)
123:           {
124:           	if (BtConnected)
11444  0100     MOVLB 0x0
11446  5187     MOVF BtConnected, W, BANKED
11448  B4D8     BTFSC STATUS, 2, ACCESS
1144A  0012     RETURN 0
125:           	{
126:           		bufWrite(&bufU2_main, 0xfd);
1144C  0EAF     MOVLW 0xAF
1144E  0101     MOVLB 0x1
11450  6FD2     MOVWF 0xD2, BANKED
11452  0E00     MOVLW 0x0
11454  6FD3     MOVWF 0xD3, BANKED
11456  0EFD     MOVLW 0xFD
11458  6FD4     MOVWF 0xD4, BANKED
1145A  EC26     CALL 0x1164C, 0
1145C  F08B     NOP
127:           				bufWrite(&bufU2_main,0x05);
1145E  0EAF     MOVLW 0xAF
11460  0101     MOVLB 0x1
11462  6FD2     MOVWF 0xD2, BANKED
11464  0E00     MOVLW 0x0
11466  6FD3     MOVWF 0xD3, BANKED
11468  0E05     MOVLW 0x5
1146A  6FD4     MOVWF 0xD4, BANKED
1146C  EC26     CALL 0x1164C, 0
1146E  F08B     NOP
128:           				bufWrite(&bufU2_main,0x02);
11470  0EAF     MOVLW 0xAF
11472  0101     MOVLB 0x1
11474  6FD2     MOVWF 0xD2, BANKED
11476  0E00     MOVLW 0x0
11478  6FD3     MOVWF 0xD3, BANKED
1147A  0E02     MOVLW 0x2
1147C  6FD4     MOVWF 0xD4, BANKED
1147E  EC26     CALL 0x1164C, 0
11480  F08B     NOP
129:           		bufWrite(&bufU2_main,mouseReport.mouseButton.byte);
11482  0EAF     MOVLW 0xAF
11484  0101     MOVLB 0x1
11486  6FD2     MOVWF 0xD2, BANKED
11488  0E00     MOVLW 0x0
1148A  6FD3     MOVWF 0xD3, BANKED
1148C  C001     MOVFF mouseReport, multiplicand
1148E  F1D4     NOP
11490  EC26     CALL 0x1164C, 0
11492  F08B     NOP
130:           		bufWrite(&bufU2_main,mouseReport.X);
11494  0EAF     MOVLW 0xAF
11496  0101     MOVLB 0x1
11498  6FD2     MOVWF 0xD2, BANKED
1149A  0E00     MOVLW 0x0
1149C  6FD3     MOVWF 0xD3, BANKED
1149E  C002     MOVFF 0x2, multiplicand
114A0  F1D4     NOP
114A2  EC26     CALL 0x1164C, 0
114A4  F08B     NOP
131:           		bufWrite(&bufU2_main,mouseReport.Y);
114A6  0EAF     MOVLW 0xAF
114A8  0101     MOVLB 0x1
114AA  6FD2     MOVWF 0xD2, BANKED
114AC  0E00     MOVLW 0x0
114AE  6FD3     MOVWF 0xD3, BANKED
114B0  C003     MOVFF 0x3, multiplicand
114B2  F1D4     NOP
114B4  EC26     CALL 0x1164C, 0
114B6  F08B     NOP
132:           		bufWrite(&bufU2_main,mouseReport.W);
114B8  0EAF     MOVLW 0xAF
114BA  0101     MOVLB 0x1
114BC  6FD2     MOVWF 0xD2, BANKED
114BE  0E00     MOVLW 0x0
114C0  6FD3     MOVWF 0xD3, BANKED
114C2  C004     MOVFF 0x4, multiplicand
114C4  F1D4     NOP
114C6  EC26     CALL 0x1164C, 0
114C8  F08B     NOP
114CA  0012     RETURN 0
133:           	}
134:           }
135:           
136:           void sendKey(void)
137:           {
138:           	if (BtConnected)
112E4  0100     MOVLB 0x0
112E6  5187     MOVF BtConnected, W, BANKED
112E8  B4D8     BTFSC STATUS, 2, ACCESS
112EA  0012     RETURN 0
139:           	{
140:           		bufWrite(&bufU2_main,0xfd);
112EC  0EAF     MOVLW 0xAF
112EE  0101     MOVLB 0x1
112F0  6FD2     MOVWF 0xD2, BANKED
112F2  0E00     MOVLW 0x0
112F4  6FD3     MOVWF 0xD3, BANKED
112F6  0EFD     MOVLW 0xFD
112F8  6FD4     MOVWF 0xD4, BANKED
112FA  EC26     CALL 0x1164C, 0
112FC  F08B     NOP
141:           		bufWrite(&bufU2_main,0x09);
112FE  0EAF     MOVLW 0xAF
11300  0101     MOVLB 0x1
11302  6FD2     MOVWF 0xD2, BANKED
11304  0E00     MOVLW 0x0
11306  6FD3     MOVWF 0xD3, BANKED
11308  0E09     MOVLW 0x9
1130A  6FD4     MOVWF 0xD4, BANKED
1130C  EC26     CALL 0x1164C, 0
1130E  F08B     NOP
142:           		bufWrite(&bufU2_main,0x01);
11310  0EAF     MOVLW 0xAF
11312  0101     MOVLB 0x1
11314  6FD2     MOVWF 0xD2, BANKED
11316  0E00     MOVLW 0x0
11318  6FD3     MOVWF 0xD3, BANKED
1131A  0E01     MOVLW 0x1
1131C  6FD4     MOVWF 0xD4, BANKED
1131E  EC26     CALL 0x1164C, 0
11320  F08B     NOP
143:           		bufWrite(&bufU2_main,keyReport.modifier.byte);
11322  0EAF     MOVLW 0xAF
11324  0101     MOVLB 0x1
11326  6FD2     MOVWF 0xD2, BANKED
11328  0E00     MOVLW 0x0
1132A  6FD3     MOVWF 0xD3, BANKED
1132C  C078     MOVFF keyReport, multiplicand
1132E  F1D4     NOP
11330  EC26     CALL 0x1164C, 0
11332  F08B     NOP
144:           		bufWrite(&bufU2_main,0x00);
11334  0EAF     MOVLW 0xAF
11336  0101     MOVLB 0x1
11338  6FD2     MOVWF 0xD2, BANKED
1133A  0E00     MOVLW 0x0
1133C  6FD3     MOVWF 0xD3, BANKED
1133E  0E00     MOVLW 0x0
11340  6FD4     MOVWF 0xD4, BANKED
11342  EC26     CALL 0x1164C, 0
11344  F08B     NOP
145:           		bufWrite(&bufU2_main,keyReport.scanCodes[0]);
11346  0EAF     MOVLW 0xAF
11348  0101     MOVLB 0x1
1134A  6FD2     MOVWF 0xD2, BANKED
1134C  0E00     MOVLW 0x0
1134E  6FD3     MOVWF 0xD3, BANKED
11350  C079     MOVFF 0x79, multiplicand
11352  F1D4     NOP
11354  EC26     CALL 0x1164C, 0
11356  F08B     NOP
146:           		bufWrite(&bufU2_main,keyReport.scanCodes[1]);
11358  0EAF     MOVLW 0xAF
1135A  0101     MOVLB 0x1
1135C  6FD2     MOVWF 0xD2, BANKED
1135E  0E00     MOVLW 0x0
11360  6FD3     MOVWF 0xD3, BANKED
11362  C07A     MOVFF 0x7A, multiplicand
11364  F1D4     NOP
11366  EC26     CALL 0x1164C, 0
11368  F08B     NOP
147:           		bufWrite(&bufU2_main,keyReport.scanCodes[2]);
1136A  0EAF     MOVLW 0xAF
1136C  0101     MOVLB 0x1
1136E  6FD2     MOVWF 0xD2, BANKED
11370  0E00     MOVLW 0x0
11372  6FD3     MOVWF 0xD3, BANKED
11374  C07B     MOVFF 0x7B, multiplicand
11376  F1D4     NOP
11378  EC26     CALL 0x1164C, 0
1137A  F08B     NOP
148:           		bufWrite(&bufU2_main,keyReport.scanCodes[3]);
1137C  0EAF     MOVLW 0xAF
1137E  0101     MOVLB 0x1
11380  6FD2     MOVWF 0xD2, BANKED
11382  0E00     MOVLW 0x0
11384  6FD3     MOVWF 0xD3, BANKED
11386  C07C     MOVFF 0x7C, multiplicand
11388  F1D4     NOP
1138A  EC26     CALL 0x1164C, 0
1138C  F08B     NOP
149:           		bufWrite(&bufU2_main,keyReport.scanCodes[4]);
1138E  0EAF     MOVLW 0xAF
11390  0101     MOVLB 0x1
11392  6FD2     MOVWF 0xD2, BANKED
11394  0E00     MOVLW 0x0
11396  6FD3     MOVWF 0xD3, BANKED
11398  C07D     MOVFF 0x7D, multiplicand
1139A  F1D4     NOP
1139C  EC26     CALL 0x1164C, 0
1139E  F08B     NOP
150:           		bufWrite(&bufU2_main,keyReport.scanCodes[5]);
113A0  0EAF     MOVLW 0xAF
113A2  0101     MOVLB 0x1
113A4  6FD2     MOVWF 0xD2, BANKED
113A6  0E00     MOVLW 0x0
113A8  6FD3     MOVWF 0xD3, BANKED
113AA  C07E     MOVFF 0x7E, multiplicand
113AC  F1D4     NOP
113AE  EC26     CALL 0x1164C, 0
113B0  F08B     NOP
113B2  0012     RETURN 0
151:           	}
152:           }
153:           
154:           void sendConsumerReport(void)
155:           {
156:           	if (BtConnected)
119E8  0100     MOVLB 0x0
119EA  5187     MOVF BtConnected, W, BANKED
119EC  B4D8     BTFSC STATUS, 2, ACCESS
119EE  0012     RETURN 0
157:           	{
158:           		bufWrite(&bufU2_main,0xfd);
119F0  0EAF     MOVLW 0xAF
119F2  0101     MOVLB 0x1
119F4  6FD2     MOVWF 0xD2, BANKED
119F6  0E00     MOVLW 0x0
119F8  6FD3     MOVWF 0xD3, BANKED
119FA  0EFD     MOVLW 0xFD
119FC  6FD4     MOVWF 0xD4, BANKED
119FE  EC26     CALL 0x1164C, 0
11A00  F08B     NOP
159:           		bufWrite(&bufU2_main,0x03);
11A02  0EAF     MOVLW 0xAF
11A04  0101     MOVLB 0x1
11A06  6FD2     MOVWF 0xD2, BANKED
11A08  0E00     MOVLW 0x0
11A0A  6FD3     MOVWF 0xD3, BANKED
11A0C  0E03     MOVLW 0x3
11A0E  6FD4     MOVWF 0xD4, BANKED
11A10  EC26     CALL 0x1164C, 0
11A12  F08B     NOP
160:           		bufWrite(&bufU2_main,0x03);
11A14  0EAF     MOVLW 0xAF
11A16  0101     MOVLB 0x1
11A18  6FD2     MOVWF 0xD2, BANKED
11A1A  0E00     MOVLW 0x0
11A1C  6FD3     MOVWF 0xD3, BANKED
11A1E  0E03     MOVLW 0x3
11A20  6FD4     MOVWF 0xD4, BANKED
11A22  EC26     CALL 0x1164C, 0
11A24  F08B     NOP
161:           		bufWrite(&bufU2_main,consumerKey);
11A26  0EAF     MOVLW 0xAF
11A28  0101     MOVLB 0x1
11A2A  6FD2     MOVWF 0xD2, BANKED
11A2C  0E00     MOVLW 0x0
11A2E  6FD3     MOVWF 0xD3, BANKED
11A30  C085     MOVFF consumerKey, multiplicand
11A32  F1D4     NOP
11A34  EC26     CALL 0x1164C, 0
11A36  F08B     NOP
162:           		bufWrite(&bufU2_main,consumerKey >> 8);
11A38  0EAF     MOVLW 0xAF
11A3A  0101     MOVLB 0x1
11A3C  6FD2     MOVWF 0xD2, BANKED
11A3E  0E00     MOVLW 0x0
11A40  6FD3     MOVWF 0xD3, BANKED
11A42  0100     MOVLB 0x0
11A44  5186     MOVF 0x86, W, BANKED
11A46  0101     MOVLB 0x1
11A48  6FD4     MOVWF 0xD4, BANKED
11A4A  EC26     CALL 0x1164C, 0
11A4C  F08B     NOP
11A4E  0012     RETURN 0
163:           		//
164:           		//		//release the key
165:           		//		bufWrite(&bufU2_main,0xfd);
166:           		//		bufWrite(&bufU2_main,0x03);
167:           		//		bufWrite(&bufU2_main,0x03);
168:           		//		bufWrite(&bufU2_main,0x00);
169:           		//		bufWrite(&bufU2_main,0x00);
170:           	}
171:           }
172:           
173:           void putText(unsigned char* text)
174:           {
175:           	while (*text)
176:           	{
177:           		bufWrite(&bufU2_main,*text++);
178:           	}
179:           }
180:           
181:           //void BT_SetToHID(void)
182:           //{
183:           //#if 0
184:           //	putText("$$$");
185:           //	putText("S~,6");
186:           //	//	TODO:
187:           //#endif
188:           //}
189:           
190:           void SendCharBT(unsigned char d)
11DA8  0101     MOVLB 0x1
11DAA  6FD8     MOVWF 0xD8, BANKED
191:           {
192:           	bufWrite(&bufU5_main,d);
11DAC  0EAA     MOVLW 0xAA
11DAE  0101     MOVLB 0x1
11DB0  6FD2     MOVWF 0xD2, BANKED
11DB2  0E00     MOVLW 0x0
11DB4  6FD3     MOVWF 0xD3, BANKED
11DB6  C1D8     MOVFF d, multiplicand
11DB8  F1D4     NOP
11DBA  EC26     CALL 0x1164C, 0
11DBC  F08B     NOP
193:           	
194:           	while (!BT_Ready);
11DBE  B48E     BTFSC PORTF, 2, ACCESS
11DC0  D7FE     BRA 0x1DBE
195:           	EUSART2_Write(d);
11DC2  0101     MOVLB 0x1
11DC4  51D8     MOVF 0xD8, W, BANKED
11DC6  EC5C     CALL 0x11EB8, 0
11DC8  F08F     NOP
196:           }
11DCA  0012     RETURN 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/FT230X.c  -----------------------------------
1:             #include <xc.h>         /* XC8 General Include File */
2:             #include "FT230X.h"
3:             #include "eusart5.h"
4:             
5:             unsigned char UsbConnected = 0;
6:             
7:             static const unsigned char hex[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
8:             
9:             void SendCharUSB(unsigned char d)
11DEA  0101     MOVLB 0x1
11DEC  6FD3     MOVWF 0xD3, BANKED
10:            {
11:            	if (USB_Host && USB_Ready)
11DEE  BC8E     BTFSC PORTF, 6, ACCESS
11DF0  0012     RETURN 0
11DF2  AE8E     BTFSS PORTF, 7, ACCESS
11DF4  0012     RETURN 0
11DF6  BA8E     BTFSC PORTF, 5, ACCESS
11DF8  0012     RETURN 0
11DFA  A08E     BTFSS PORTF, 0, ACCESS
11DFC  0012     RETURN 0
12:            	{
13:            		EUSART5_Write(d);
11DFE  0101     MOVLB 0x1
11E00  51D3     MOVF 0xD3, W, BANKED
11E02  EC64     CALL 0x11EC8, 0
11E04  F08F     NOP
11E06  0012     RETURN 0
14:            	}
15:            }
16:            
17:            void showText(unsigned char* text)
18:            {
19:            	while (*text)
11CAA  D00D     BRA 0x1CC6
20:            	{
21:            		SendCharUSB(*text++);
11CAC  C1D4     MOVFF multiplicand, TBLPTR
11CAE  FFF6     NOP
11CB0  C1D5     MOVFF 0x1D5, TBLPTRH
11CB2  FFF7     NOP
11CB4  0E00     MOVLW 0x0
11CB6  6EF8     MOVWF TBLPTRU, ACCESS
11CB8  0008     TBLRD*
11CBA  50F5     MOVF TABLAT, W, ACCESS
11CBC  ECF5     CALL 0x11DEA, 0
11CBE  F08E     NOP
11CC0  0101     MOVLB 0x1
11CC2  4BD4     INFSNZ 0xD4, F, BANKED
11CC4  2BD5     INCF 0xD5, F, BANKED
22:            	}
11CC6  C1D4     MOVFF multiplicand, TBLPTR
11CC8  FFF6     NOP
11CCA  C1D5     MOVFF 0x1D5, TBLPTRH
11CCC  FFF7     NOP
11CCE  0E00     MOVLW 0x0
11CD0  6EF8     MOVWF TBLPTRU, ACCESS
11CD2  0008     TBLRD*
11CD4  50F5     MOVF TABLAT, W, ACCESS
11CD6  0900     IORLW 0x0
11CD8  B4D8     BTFSC STATUS, 2, ACCESS
11CDA  0012     RETURN 0
11CDC  D7E7     BRA 0x1CAC
23:            }
24:            
25:            void showHex2(unsigned char n)
26:            {
27:            	SendCharUSB('0');
28:            	SendCharUSB('x');
29:            	SendCharUSB(hex[n / 0x10]);
30:            	SendCharUSB(hex[ n % 0x10]);
31:            	SendCharUSB(',');
32:            }
33:            
34:            void showHex4(unsigned short n)
35:            {
36:            	SendCharUSB('0');
37:            	SendCharUSB('x');
38:            	SendCharUSB(hex[ n / 0x1000]);
39:            	SendCharUSB(hex[n / 0x100 % 0x10]);
40:            	SendCharUSB(hex[ n / 0x10 % 0x10]);
41:            	SendCharUSB(hex[ n % 0x10]);
42:            	SendCharUSB(',');
43:            }
44:            
45:            void showState(void)
46:            {
47:            	//	showText("Vbat=");
48:            	//	SendCharBT('0' + v / 100);
49:            	//	SendCharBT('.');
50:            	//	SendCharBT('0' + v / 10 % 10);
51:            	//	SendCharBT('0' + v % 10);
52:            	//	SendCharBT('V');
53:            	//	SendCharBT(' ');
54:            	//	SendCharBT('\r');
55:            	//	SendCharBT('\r');
56:            }
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/strlen.c  --------------------------------
1:             #include	<string.h>
2:             
3:             size_t
4:             strlen(const char * s)
5:             {
6:             	register const char *	cp;
7:             
8:             	cp = s;
11C28  C027     MOVFF __pcstackCOMRAM, __wmul
11C2A  F02B     NOP
11C2C  C028     MOVFF 0x28, 0x2C
11C2E  F02C     NOP
9:             	while(*cp) {
11C30  D002     BRA 0x1C36
10:            		cp++;
11C32  4A2B     INFSNZ __wmul, F, ACCESS
11C34  2A2C     INCF 0x2C, F, ACCESS
11:            	}
11C36  C02B     MOVFF __wmul, TBLPTR
11C38  FFF6     NOP
11C3A  C02C     MOVFF 0x2C, TBLPTRH
11C3C  FFF7     NOP
11C3E  0E00     MOVLW 0x0
11C40  6EF8     MOVWF TBLPTRU, ACCESS
11C42  0008     TBLRD*
11C44  50F5     MOVF TABLAT, W, ACCESS
11C46  0900     IORLW 0x0
11C48  A4D8     BTFSS STATUS, 2, ACCESS
11C4A  D7F3     BRA 0x1C32
12:            	return cp-s;
11C4C  C027     MOVFF __pcstackCOMRAM, multiplicand
11C4E  F029     NOP
11C50  C028     MOVFF 0x28, 0x2A
11C52  F02A     NOP
11C54  1E29     COMF multiplicand, F, ACCESS
11C56  1E2A     COMF 0x2A, F, ACCESS
11C58  4A29     INFSNZ multiplicand, F, ACCESS
11C5A  2A2A     INCF 0x2A, F, ACCESS
11C5C  502B     MOVF __wmul, W, ACCESS
11C5E  2429     ADDWF multiplicand, W, ACCESS
11C60  6E27     MOVWF __pcstackCOMRAM, ACCESS
11C62  502C     MOVF 0x2C, W, ACCESS
11C64  202A     ADDWFC 0x2A, W, ACCESS
11C66  6E28     MOVWF 0x28, ACCESS
11C68  0012     RETURN 0
13:            }
14:            
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/Umul32.c  --------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
11AAA  0E00     MOVLW 0x0
11AAC  0101     MOVLB 0x1
11AAE  6FDA     MOVWF 0xDA, BANKED
11AB0  0E00     MOVLW 0x0
11AB2  6FDB     MOVWF 0xDB, BANKED
11AB4  0E00     MOVLW 0x0
11AB6  6FDC     MOVWF 0xDC, BANKED
11AB8  0E00     MOVLW 0x0
11ABA  6FDD     MOVWF 0xDD, BANKED
120:           	do {
121:           		if(multiplier & 1)
11ABC  A1D2     BTFSS 0xD2, 0, BANKED
11ABE  D008     BRA 0x1AD0
122:           			product += multiplicand;
11AC0  51D6     MOVF 0xD6, W, BANKED
11AC2  27DA     ADDWF 0xDA, F, BANKED
11AC4  51D7     MOVF 0xD7, W, BANKED
11AC6  23DB     ADDWFC 0xDB, F, BANKED
11AC8  51D8     MOVF 0xD8, W, BANKED
11ACA  23DC     ADDWFC 0xDC, F, BANKED
11ACC  51D9     MOVF 0xD9, W, BANKED
11ACE  23DD     ADDWFC 0xDD, F, BANKED
123:           		multiplicand <<= 1;
11AD0  90D8     BCF STATUS, 0, ACCESS
11AD2  37D6     RLCF 0xD6, F, BANKED
11AD4  37D7     RLCF 0xD7, F, BANKED
11AD6  37D8     RLCF 0xD8, F, BANKED
11AD8  37D9     RLCF 0xD9, F, BANKED
124:           		multiplier >>= 1;
11ADA  90D8     BCF STATUS, 0, ACCESS
11ADC  33D5     RRCF 0xD5, F, BANKED
11ADE  33D4     RRCF 0xD4, F, BANKED
11AE0  33D3     RRCF 0xD3, F, BANKED
11AE2  33D2     RRCF 0xD2, F, BANKED
125:           	} while(multiplier != 0);
11AE4  51D2     MOVF 0xD2, W, BANKED
11AE6  11D3     IORWF 0xD3, W, BANKED
11AE8  11D4     IORWF 0xD4, W, BANKED
11AEA  11D5     IORWF 0xD5, W, BANKED
11AEC  A4D8     BTFSS STATUS, 2, ACCESS
11AEE  D7E6     BRA 0x1ABC
126:           
127:           #endif
128:           	return product;
11AF0  C1DA     MOVFF product, __pcstackBANK1
11AF2  F1D2     NOP
11AF4  C1DB     MOVFF r, d
11AF6  F1D3     NOP
11AF8  C1DC     MOVFF c, multiplicand
11AFA  F1D4     NOP
11AFC  C1DD     MOVFF d, 0x1D5
11AFE  F1D5     NOP
129:           }
11B00  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/Umul16.c  --------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
11D32  0101     MOVLB 0x1
11D34  51D2     MOVF 0xD2, W, BANKED
11D36  03D4     MULWF 0xD4, BANKED
11D38  CFF3     MOVFF PROD, multiplicand
11D3A  F1D6     NOP
11D3C  CFF4     MOVFF PRODH, d
11D3E  F1D7     NOP
11D82  5027     MOVF __pcstackCOMRAM, W, ACCESS
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
11D40  51D2     MOVF 0xD2, W, BANKED
11D42  03D5     MULWF 0xD5, BANKED
11D44  50F3     MOVF PROD, W, ACCESS
11D46  27D7     ADDWF 0xD7, F, BANKED
11D8E  5027     MOVF __pcstackCOMRAM, W, ACCESS
11D90  022A     MULWF 0x2A, ACCESS
11D92  50F3     MOVF PROD, W, ACCESS
11D94  262C     ADDWF 0x2C, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
11D48  51D3     MOVF 0xD3, W, BANKED
11D4A  03D4     MULWF 0xD4, BANKED
11D4C  50F3     MOVF PROD, W, ACCESS
11D4E  27D7     ADDWF 0xD7, F, BANKED
11D96  5028     MOVF 0x28, W, ACCESS
11D98  0229     MULWF multiplicand, ACCESS
11D9A  50F3     MOVF PROD, W, ACCESS
11D9C  262C     ADDWF 0x2C, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
11D50  C1D6     MOVFF multiplicand, __pcstackBANK1
11D9E  C02B     MOVFF __wmul, __pcstackCOMRAM
11DA0  F027     NOP
11DA2  C02C     MOVFF 0x2C, 0x28
11DA4  F028     NOP
11DA6  0012     RETURN 0
53:            }
