Disassembly Listing for BTKB
Generated From:
C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/dist/XC8_18F67K40/production/BTKB.X.production.elf
Jul 25, 2018 5:46:01 AM

---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/user.c  -------------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #include <xc.h>         /* XC8 General Include File */
6:             
7:             #include <stdint.h>         /* For uint8_t definition */
8:             #include <stdbool.h>        /* For true/false definition */
9:             //#include <stdlib.h>
10:            //#include <stdio.h>
11:            
12:            #include "system.h"
13:            #include "keys.h"
14:            #include "user.h"
15:            #include "swMatrix.h"
16:            #include "adcc.h"
17:            #include "eusart2.h"
18:            #include "eusart5.h"
19:            #include "main.h"
20:            #include "RN42.h"
21:            #include "FT230X.h"
22:            
23:            #define	SW1LONG	2000
24:            //M1,M2,M3,FnL,FnR,Ctrl,Alt,Win,ShiftL,ShiftR,CursorL,CursorR
25:            static const unsigned char ledAnodeTable[LEDNUM] = {8, 1, 4, 8, 2, 2, 2, 1, 4, 4, 1, 8};
26:            static const unsigned char ledCathodeTable[LEDNUM] = {1, 8, 8, 2, 4, 1, 8, 2, 2, 1, 4, 4};
27:            
28:            
29:            /******************************************************************************/
30:            /* User Functions                                                             */
31:            /******************************************************************************/
32:            
33:            /* <Initialize variables in user.h and insert code for user algorithms.> */
34:            unsigned char led[LEDNUM];
35:            unsigned long sleepCountDown = 0;
36:            
37:            void ledMatrixProcess(void)
38:            {
39:            	//call this function from interval timer interrupt
40:            #ifdef MICRO_QWERTY
41:            	static unsigned char c = 0;
42:            
43:            	if (++c == LEDNUM)
11BE6  2A0F     INCF c, F, ACCESS
11BE8  0E0C     MOVLW 0xC
11BEA  180F     XORWF c, W, ACCESS
11BEC  A4D8     BTFSS STATUS, 2, ACCESS
11BEE  D002     BRA 0x1BF4
44:            	{
45:            		c = 0;
11BF0  0E00     MOVLW 0x0
11BF2  6E0F     MOVWF c, ACCESS
46:            	}
47:            
48:            	LATE &= 0xf0;
11BF4  0EF0     MOVLW 0xF0
11BF6  167D     ANDWF LATE, F, ACCESS
49:            	TRISE = (TRISE & 0xf0) | (~(ledAnodeTable[c] | ledCathodeTable[c]) & 0x0f);
11BF8  500F     MOVF c, W, ACCESS
11BFA  0D01     MULLW 0x1
11BFC  0E43     MOVLW 0x43
11BFE  24F3     ADDWF PROD, W, ACCESS
11C00  6EF6     MOVWF TBLPTR, ACCESS
11C02  0EFB     MOVLW 0xFB
11C04  20F4     ADDWFC PRODH, W, ACCESS
11C06  6EF7     MOVWF TBLPTRH, ACCESS
11C08  6AF8     CLRF TBLPTRU, ACCESS
11C0A  0E00     MOVLW 0x0
11C0C  22F8     ADDWFC TBLPTRU, F, ACCESS
11C0E  0008     TBLRD*
11C10  CFF5     MOVFF TABLAT, __pcstackCOMRAM
11C12  F021     NOP
11C14  500F     MOVF c, W, ACCESS
11C16  0D01     MULLW 0x1
11C18  0E4F     MOVLW 0x4F
11C1A  24F3     ADDWF PROD, W, ACCESS
11C1C  6EF6     MOVWF TBLPTR, ACCESS
11C1E  0EFB     MOVLW 0xFB
11C20  20F4     ADDWFC PRODH, W, ACCESS
11C22  6EF7     MOVWF TBLPTRH, ACCESS
11C24  6AF8     CLRF TBLPTRU, ACCESS
11C26  0E00     MOVLW 0x0
11C28  22F8     ADDWFC TBLPTRU, F, ACCESS
11C2A  0008     TBLRD*
11C2C  50F5     MOVF TABLAT, W, ACCESS
11C2E  1021     IORWF __pcstackCOMRAM, W, ACCESS
11C30  0AFF     XORLW 0xFF
11C32  6E22     MOVWF 0x22, ACCESS
11C34  0E0F     MOVLW 0xF
11C36  1622     ANDWF 0x22, F, ACCESS
11C38  5085     MOVF TRISE, W, ACCESS
11C3A  0BF0     ANDLW 0xF0
11C3C  1022     IORWF 0x22, W, ACCESS
11C3E  6E85     MOVWF TRISE, ACCESS
50:            	if (led[c])
11C40  500F     MOVF c, W, ACCESS
11C42  0D01     MULLW 0x1
11C44  0EAC     MOVLW 0xAC
11C46  24F3     ADDWF PROD, W, ACCESS
11C48  6ED9     MOVWF FSR2, ACCESS
11C4A  0E00     MOVLW 0x0
11C4C  20F4     ADDWFC PRODH, W, ACCESS
11C4E  6EDA     MOVWF FSR2H, ACCESS
11C50  50DF     MOVF INDF2, W, ACCESS
11C52  B4D8     BTFSC STATUS, 2, ACCESS
11C54  0012     RETURN 0
51:            	{
52:            		LATE |= ledAnodeTable[c] & 0x0f;
11C56  500F     MOVF c, W, ACCESS
11C58  0D01     MULLW 0x1
11C5A  0E4F     MOVLW 0x4F
11C5C  24F3     ADDWF PROD, W, ACCESS
11C5E  6EF6     MOVWF TBLPTR, ACCESS
11C60  0EFB     MOVLW 0xFB
11C62  20F4     ADDWFC PRODH, W, ACCESS
11C64  6EF7     MOVWF TBLPTRH, ACCESS
11C66  6AF8     CLRF TBLPTRU, ACCESS
11C68  0E00     MOVLW 0x0
11C6A  22F8     ADDWFC TBLPTRU, F, ACCESS
11C6C  0008     TBLRD*
11C6E  50F5     MOVF TABLAT, W, ACCESS
11C70  0B0F     ANDLW 0xF
11C72  127D     IORWF LATE, F, ACCESS
11C74  0012     RETURN 0
53:            	}
54:            #endif
55:            }
56:            
57:            void sw1Process(void)
58:            {
59:            	//call this function from interval timer interrupt
60:            	static unsigned char sw1Count = 0;
61:            	static unsigned char sw1State = 0;
62:            	static unsigned short sw1Count2 = 0;
63:            	if (sw1State != SW1)
11EF0  BC8C     BTFSC PORTD, 6, ACCESS
11EF2  D002     BRA 0x1EF8
11EF4  0E01     MOVLW 0x1
11EF6  D001     BRA 0x1EFA
11EF8  0E00     MOVLW 0x0
11EFA  180D     XORWF sw1State, W, ACCESS
11EFC  B4D8     BTFSC STATUS, 2, ACCESS
11EFE  D017     BRA 0x1F2E
64:            	{
65:            		if (++sw1Count == 10)
11F00  2A0E     INCF sw1Count, F, ACCESS
11F02  0E0A     MOVLW 0xA
11F04  180E     XORWF sw1Count, W, ACCESS
11F06  A4D8     BTFSS STATUS, 2, ACCESS
11F08  D014     BRA 0x1F32
66:            		{
67:            			sw1State = !sw1State;
11F0A  500D     MOVF sw1State, W, ACCESS
11F0C  A4D8     BTFSS STATUS, 2, ACCESS
11F0E  D002     BRA 0x1F14
11F10  0E01     MOVLW 0x1
11F12  D001     BRA 0x1F16
11F14  0E00     MOVLW 0x0
11F16  6E0D     MOVWF sw1State, ACCESS
68:            			if (!sw1State)
11F18  500D     MOVF sw1State, W, ACCESS
11F1A  A4D8     BTFSS STATUS, 2, ACCESS
11F1C  D00A     BRA 0x1F32
69:            			{
70:            				if (sw1Count2 < SW1LONG)
11F1E  0ED0     MOVLW 0xD0
11F20  5C09     SUBWF sw1Count2, W, ACCESS
11F22  0E07     MOVLW 0x7
11F24  580A     SUBWFB 0xA, W, ACCESS
11F26  B0D8     BTFSC STATUS, 0, ACCESS
11F28  D004     BRA 0x1F32
71:            				{
72:            					mainFlags.sw1Pushed = 1;
11F2A  800B     BSF mainFlags, 0, ACCESS
73:            				}
74:            			}
75:            		}
76:            	}
11F2C  D002     BRA 0x1F32
77:            	else
78:            	{
79:            		sw1Count = 0;
11F2E  0E00     MOVLW 0x0
11F30  6E0E     MOVWF sw1Count, ACCESS
80:            	}
81:            
82:            	if (sw1State)
11F32  500D     MOVF sw1State, W, ACCESS
11F34  B4D8     BTFSC STATUS, 2, ACCESS
11F36  D010     BRA 0x1F58
83:            	{
84:            		if (sw1Count2 == SW1LONG)
11F38  0ED0     MOVLW 0xD0
11F3A  1809     XORWF sw1Count2, W, ACCESS
11F3C  E10A     BNZ 0x1F52
11F3E  0E07     MOVLW 0x7
11F40  180A     XORWF 0xA, W, ACCESS
11F42  A4D8     BTFSS STATUS, 2, ACCESS
11F44  D006     BRA 0x1F52
85:            		{
86:            			mainFlags.sw1LongPushing = 1;
11F46  820B     BSF mainFlags, 1, ACCESS
87:            			sw1Count2 = SW1LONG + 1;
11F48  0E07     MOVLW 0x7
11F4A  6E0A     MOVWF 0xA, ACCESS
11F4C  0ED1     MOVLW 0xD1
11F4E  6E09     MOVWF sw1Count2, ACCESS
88:            		}
11F50  0012     RETURN 0
89:            		else
90:            		{
91:            			sw1Count2++;
11F52  4A09     INFSNZ sw1Count2, F, ACCESS
11F54  2A0A     INCF 0xA, F, ACCESS
92:            		}
93:            	}
11F56  0012     RETURN 0
94:            	else
95:            	{
96:            		sw1Count2 = 0;
11F58  0E00     MOVLW 0x0
11F5A  6E0A     MOVWF 0xA, ACCESS
11F5C  0E00     MOVLW 0x0
11F5E  6E09     MOVWF sw1Count2, ACCESS
11F60  0012     RETURN 0
97:            	}
98:            }
99:            
100:           void PMD_AllOff(void)
101:           {
102:           	PMD0 = 0xff;
1275E  010E     MOVLB 0xE
12760  694C     SETF 0x4C, BANKED
103:           	PMD1 = 0xff;
12762  694D     SETF 0x4D, BANKED
104:           	PMD2 = 0xff;
12764  694E     SETF 0x4E, BANKED
105:           	PMD3 = 0xff;
12766  694F     SETF 0x4F, BANKED
106:           	PMD4 = 0xff;
12768  6950     SETF 0x50, BANKED
107:           	PMD5 = 0xff;
1276A  6951     SETF 0x51, BANKED
108:           
109:           	PMD0bits.IOCMD = 0;
1276C  914C     BCF 0x4C, 0, BANKED
110:           }
1276E  0012     RETURN 0
111:           
112:           void PMD_Initialize(void)
113:           {
114:           	// CLKRMD CLKR disabled; SYSCMD SYSCLK enabled; SCANMD SCANNER disabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC disabled; HLVDMD HLVD disabled; NVMMD NVM disabled; 
115:           	PMD0 = 0x3e;
126AC  0E3E     MOVLW 0x3E
126AE  010E     MOVLB 0xE
126B0  6F4C     MOVWF 0x4C, BANKED
116:           	// TMR0MD TMR0 disabled; TMR1MD TMR1 enabled; TMR4MD TMR4 disabled; TMR5MD TMR5 disabled; TMR2MD TMR2 disabled; TMR3MD TMR3 enabled; TMR6MD TMR6 disabled; TMR7MD TMR7 disabled; 
117:           	PMD1 = 0xf5;
126B2  0EF5     MOVLW 0xF5
126B4  6F4D     MOVWF 0x4D, BANKED
118:           	// DSMMD DSM disabled; SMU1MD SMT1 disabled; SMU2MD SMT2 disabled; CWG1MD CWG1 disabled; TMR8MD TMR8 disabled; 
119:           	PMD2 = 0xff;
126B6  694E     SETF 0x4E, BANKED
120:           	// ZCDMD ZCD disabled; DACMD DAC disabled; CMP3MD CMP3 disabled; CMP1MD CMP1 disabled; ADCMD ADC enabled; CMP2MD CMP2 disabled; 
121:           	PMD3 = 0xdf;
126B8  0EDF     MOVLW 0xDF
126BA  6F4F     MOVWF 0x4F, BANKED
122:           	// CCP2MD CCP2 disabled; CCP1MD CCP1 disabled; CCP4MD CCP4 disabled; CCP3MD CCP3 disabled; CCP5MD CCP5 disabled; PWM6MD PWM6 disabled; PWM7MD PWM7 disabled; 
123:           	PMD4 = 0xff;
126BC  6950     SETF 0x50, BANKED
124:           	// UART5MD EUSART5 enabled; UART4MD EUSART4 disabled; UART3MD EUSART3 disabled; UART2MD EUSART2 enabled; MSSP1MD MSSP1 disabled; UART1MD EUSART1 disabled; 
125:           	PMD5 = 0xb7;
126BE  0EB7     MOVLW 0xB7
126C0  6F51     MOVWF 0x51, BANKED
126:           }
126C2  0012     RETURN 0
127:           
128:           void StandbyMainBoardIO(void)
129:           {
130:           	//Set to lowest power consumption state!
131:           
132:           	LATD = 0x00; //(UI Board),SW1,SW2,LED1
11F62  0E00     MOVLW 0x0
11F64  6E7C     MOVWF LATD, ACCESS
133:           	LATA = 0x00; //Bat_Check_EN,BT_Reset
11F66  0E00     MOVLW 0x0
11F68  6E79     MOVWF LATA, ACCESS
134:           	LATF = 0x05; //BT_RTS,BT_GPIO5,USB_RTS,USB_CBUS0,1,3,Chg_State,Chg_500mA,
11F6A  0E05     MOVLW 0x5
11F6C  6E7E     MOVWF LATF, ACCESS
135:           	LATG = 0x02; //BT_TX,RX,USB_TX,RX
11F6E  0E02     MOVLW 0x2
11F70  6E7F     MOVWF LATG, ACCESS
136:           	LATH = 0x00; //Bat_Volt
11F72  0E00     MOVLW 0x0
11F74  6E80     MOVWF LATH, ACCESS
137:           
138:           	TRISD = 0x43;
11F76  0E43     MOVLW 0x43
11F78  6E84     MOVWF TRISD, ACCESS
139:           	TRISA = 0x01;
11F7A  0E01     MOVLW 0x1
11F7C  6E81     MOVWF TRISA, ACCESS
140:           	TRISF = 0xee;
11F7E  0EEE     MOVLW 0xEE
11F80  6E86     MOVWF TRISF, ACCESS
141:           	TRISG = 0x05;
11F82  0E05     MOVLW 0x5
11F84  6E87     MOVWF TRISG, ACCESS
142:           	TRISH = 0x00;
11F86  0E00     MOVLW 0x0
11F88  6E88     MOVWF TRISH, ACCESS
143:           
144:           	ANSELD = 0xbf;
11F8A  0EBF     MOVLW 0xBF
11F8C  010E     MOVLB 0xE
11F8E  6FA7     MOVWF 0xA7, BANKED
145:           	ANSELA = 0xff;
11F90  6992     SETF 0x92, BANKED
146:           	ANSELF = 0xff;
11F92  69B4     SETF 0xB4, BANKED
147:           	ANSELG = 0xff;
11F94  69BC     SETF 0xBC, BANKED
148:           
149:           	WPUD = 0x40;
11F96  0E40     MOVLW 0x40
11F98  6FA6     MOVWF 0xA6, BANKED
150:           	WPUA = 0x00;
11F9A  0E00     MOVLW 0x0
11F9C  6F91     MOVWF 0x91, BANKED
151:           	WPUF = 0x00;
11F9E  0E00     MOVLW 0x0
11FA0  6FB3     MOVWF 0xB3, BANKED
152:           	WPUG = 0x20;
11FA2  0E20     MOVLW 0x20
11FA4  6FBB     MOVWF 0xBB, BANKED
153:           	WPUH = 0x00;
11FA6  0E00     MOVLW 0x0
11FA8  6FC0     MOVWF 0xC0, BANKED
154:           
155:           	INLVLD = 0xff;
11FAA  69A3     SETF 0xA3, BANKED
156:           	INLVLA = 0xff;
11FAC  698E     SETF row, BANKED
157:           	INLVLF = 0xff;
11FAE  69B0     SETF 0xB0, BANKED
158:           	INLVLG = 0xff;
11FB0  69B8     SETF keyReport, BANKED
159:           	INLVLH = 0xff;
11FB2  69BD     SETF 0xBD, BANKED
160:           
161:           	SLRCOND = 0xff;
11FB4  69A4     SETF 0xA4, BANKED
162:           	SLRCONA = 0xff;
11FB6  698F     SETF c, BANKED
163:           	SLRCONF = 0xff;
11FB8  69B1     SETF 0xB1, BANKED
164:           	SLRCONG = 0xff;
11FBA  69B9     SETF 0xB9, BANKED
165:           	SLRCONH = 0xff;
11FBC  69BE     SETF 0xBE, BANKED
166:           
167:           	ODCOND = 0x00;
11FBE  0E00     MOVLW 0x0
11FC0  6FA5     MOVWF 0xA5, BANKED
168:           	ODCONA = 0x00;
11FC2  0E00     MOVLW 0x0
11FC4  6F90     MOVWF 0x90, BANKED
169:           	ODCONF = 0x01;
11FC6  0E01     MOVLW 0x1
11FC8  6FB2     MOVWF 0xB2, BANKED
170:           	ODCONG = 0x00;
11FCA  0E00     MOVLW 0x0
11FCC  6FBA     MOVWF 0xBA, BANKED
171:           	ODCONH = 0x00;
11FCE  0E00     MOVLW 0x0
11FD0  6FBF     MOVWF 0xBF, BANKED
172:           }
11FD2  0012     RETURN 0
173:           
174:           void InitMainBoardIO(void)
175:           {
176:           	ANSELD = 0x00;
1274A  0E00     MOVLW 0x0
1274C  010E     MOVLB 0xE
1274E  6FA7     MOVWF 0xA7, BANKED
177:           	ANSELA = 0x01;
12750  0E01     MOVLW 0x1
12752  6F92     MOVWF 0x92, BANKED
178:           	ANSELF = 0x00;
12754  0E00     MOVLW 0x0
12756  6FB4     MOVWF 0xB4, BANKED
179:           	ANSELG = 0x00;
12758  0E00     MOVLW 0x0
1275A  6FBC     MOVWF 0xBC, BANKED
180:           }
1275C  0012     RETURN 0
181:           
182:           void waitBootTrigger(void)
183:           {
184:           	INT2PPSbits.INT2PPS = 0x1e;
12526  010D     MOVLB 0xD
12528  91F2     BCF 0xF2, 0, BANKED
1252A  83F2     BSF 0xF2, 1, BANKED
1252C  85F2     BSF 0xF2, 2, BANKED
1252E  87F2     BSF 0xF2, 3, BANKED
12530  89F2     BSF 0xF2, 4, BANKED
12532  9BF2     BCF 0xF2, 5, BANKED
185:           
186:           	INTCONbits.GIE = 0;
12534  9EF2     BCF INTCON, 7, ACCESS
187:           	INTCONbits.INT2EDG = 0;
12536  94F2     BCF INTCON, 2, ACCESS
188:           	IPR0bits.INT2IP = 1;
12538  010E     MOVLB 0xE
1253A  851F     BSF 0x1F, 2, BANKED
189:           	PIR0bits.INT2IF = 0;
1253C  9533     BCF 0x33, 2, BANKED
190:           	PIE0bits.INT2IE = 1;
1253E  8529     BSF 0x29, 2, BANKED
191:           
192:           	IOCBF = 0x00;
12540  0E00     MOVLW 0x0
12542  6F93     MOVWF 0x93, BANKED
193:           	IOCEF = 0x00;
12544  0E00     MOVLW 0x0
12546  6FA8     MOVWF 0xA8, BANKED
194:           
195:           	IOCBN = PORTBMASK;
12548  6994     SETF 0x94, BANKED
196:           	IOCEN = PORTEMASK;
1254A  0EF0     MOVLW 0xF0
1254C  6FA9     MOVWF 0xA9, BANKED
197:           
198:           	PIE0bits.IOCIE = 1;
1254E  8929     BSF 0x29, 4, BANKED
199:           	IPR0bits.IOCIP = 1;
12550  891F     BSF 0x1F, 4, BANKED
200:           
201:           //	do
202:           //	{
203:           		LED1 = 0;
12552  9E8C     BCF PORTD, 7, ACCESS
204:           //		PMD0bits.HLVDMD = 1;	//disable LVD
205:           		Sleep(); //Wait for SW1 Push
12554  0003     SLEEP
206:           		Nop();
12556  F000     NOP
207:           		LED1 = 1;
12558  8E8C     BSF PORTD, 7, ACCESS
208:           //		PMD0bits.HLVDMD = 0;	//enable LVD
209:           //		HLVDCON0 = 0x01;
210:           //		HLVDCON1 = 0x07;
211:           //		HLVDCON0bits.EN = 1;
212:           //
213:           //		//wait ready
214:           //		while (!HLVDCON0bits.HLVDRDY)
215:           //		{
216:           //		}
217:           //	}
218:           //	//
219:           //	while (HLVDCON0bits.OUT);
220:           	
221:           	PIE0bits.INT2IE = 0;
1255A  010E     MOVLB 0xE
1255C  9529     BCF 0x29, 2, BANKED
222:           	PIE0bits.IOCIE = 0;
1255E  9929     BCF 0x29, 4, BANKED
223:           	LED1 = 0;
12560  9E8C     BCF PORTD, 7, ACCESS
224:           }
12562  0012     RETURN 0
225:           
226:           void InitApp(void)
227:           {
228:           	NVMCON1bits.NVMREG = 2;
1270C  5077     MOVF NVMCON1, W, ACCESS
1270E  0B3F     ANDLW 0x3F
12710  0980     IORLW 0x80
12712  6E77     MOVWF NVMCON1, ACCESS
229:           	//Power down state
230:           	StandbyMainBoardIO();
12714  ECB1     CALL 0x11F62, 0
12716  F08F     NOP
231:           	StandbyUiBoardIO();
12718  EC73     CALL 0x124E6, 0
1271A  F092     NOP
232:           	PMD_AllOff();
1271C  ECAF     CALL 0x1275E, 0
1271E  F093     NOP
233:           }
12720  0012     RETURN 0
234:           
235:           void InitApp2(void)
236:           {
237:           	//Start 
238:           	PMD_Initialize();
11E06  EC56     CALL 0x126AC, 0
11E08  F093     NOP
239:           	ConfigureOscillator();
11E0A  EC7A     CALL 0x126F4, 0
11E0C  F093     NOP
240:           	InitMainBoardIO();
11E0E  ECA5     CALL 0x1274A, 0
11E10  F093     NOP
241:           	InitUiBoardIO();
11E12  EC50     CALL 0x11AA0, 0
11E14  F08D     NOP
242:           
243:           	RG1PPS = 0x0E; //RG1->EUSART2:TX2;
11E16  0E0E     MOVLW 0xE
11E18  010E     MOVLB 0xE
11E1A  6F83     MOVWF 0x83, BANKED
244:           //	RG7PPS = 0x0E; //RG7->EUSART2:TX2; DEBUG
245:           	RX2PPSbits.RX2PPS = 0x30; //RG0->EUSART2:RX2;
11E1C  9111     BCF bufU5_main, 0, BANKED
11E1E  9311     BCF bufU5_main, 1, BANKED
11E20  9511     BCF bufU5_main, 2, BANKED
11E22  9711     BCF bufU5_main, 3, BANKED
11E24  8911     BSF bufU5_main, 4, BANKED
11E26  8B11     BSF bufU5_main, 5, BANKED
246:           	RG3PPS = 0x14; //RG3->EUSART5:TX5;
11E28  0E14     MOVLW 0x14
11E2A  6F85     MOVWF b, BANKED
247:           	RX5PPSbits.RX5PPS = 0x32; //RG2->EUSART5:RX5;
11E2C  9117     BCF 0x17, 0, BANKED
11E2E  8317     BSF 0x17, 1, BANKED
11E30  9517     BCF 0x17, 2, BANKED
11E32  9717     BCF 0x17, 3, BANKED
11E34  8917     BSF 0x17, 4, BANKED
11E36  8B17     BSF 0x17, 5, BANKED
248:           
249:           	/* Setup analog functionality and port direction */
250:           
251:           	/* Initialize peripherals */
252:           	TMR1CLK = 0x05; //MFINTOSC 500kHz
11E38  0E05     MOVLW 0x5
11E3A  6ED2     MOVWF T1CLK, ACCESS
253:           	T1CON = 0x01;
11E3C  0E01     MOVLW 0x1
11E3E  6ECF     MOVWF T1CON, ACCESS
254:           
255:           	TMR3CLK = 0x05; //MFINTOSC 500kHz
11E40  0E05     MOVLW 0x5
11E42  6ECC     MOVWF T3CLK, ACCESS
256:           	T3CON = 0x01;
11E44  0E01     MOVLW 0x1
11E46  6EC9     MOVWF T3CON, ACCESS
257:           
258:           	FVRCON = 0x82;
11E48  0E82     MOVLW 0x82
11E4A  6FC4     MOVWF 0xC4, BANKED
259:           	ADCC_Initialize();
11E4C  EC62     CALL 0x122C4, 0
11E4E  F091     NOP
260:           
261:           	EUSART5_Initialize();
11E50  EC62     CALL 0x126C4, 0
11E52  F093     NOP
262:           	EUSART2_Initialize();
11E54  EC6E     CALL 0x126DC, 0
11E56  F093     NOP
263:           
264:           
265:           	/* Set the IPEN bit to turn on INT priorities */
266:           	INTCONbits.IPEN = 1;
11E58  8AF2     BSF INTCON, 5, ACCESS
267:           
268:           	/* Enable interrupts */
269:           	IPR3bits.RC2IP = 1; //BT
11E5A  010E     MOVLB 0xE
11E5C  8F22     BSF 0x22, 7, BANKED
270:           	PIE3bits.RC2IE = 1;
11E5E  8F2C     BSF 0x2C, 7, BANKED
271:           	IPR3bits.TX2IP = 0; //BT
11E60  9D22     BCF 0x22, 6, BANKED
272:           	PIE3bits.TX2IE = 1;
11E62  8D2C     BSF 0x2C, 6, BANKED
273:           	IPR4bits.RC5IP = 1; //USB
11E64  8B23     BSF d, 5, BANKED
274:           	PIE4bits.RC5IE = 1;
11E66  8B2D     BSF 0x2D, 5, BANKED
275:           	IPR4bits.TX5IP = 0; //USB
11E68  9923     BCF d, 4, BANKED
276:           	PIE4bits.TX5IE = 1;
11E6A  892D     BSF 0x2D, 4, BANKED
277:           	//	IPR2bits.HLVDIP = 0; //Low Battery
278:           	//	PIE2bits.HLVDIE = 1;
279:           	IPR5bits.TMR1IP = 1; //LED matrix
11E6C  8124     BSF 0x24, 0, BANKED
280:           	PIE5bits.TMR1IE = 1;
11E6E  812E     BSF 0x2E, 0, BANKED
281:           	IPR5bits.TMR3IP = 0; //SW matrix...
11E70  9524     BCF 0x24, 2, BANKED
282:           	PIE5bits.TMR3IE = 1;
11E72  852E     BSF 0x2E, 2, BANKED
283:           	INTCONbits.PEIE = 1;
11E74  8CF2     BSF INTCON, 6, ACCESS
284:           
285:           	//	SendCharUSB(0xff);
286:           
287:           	BT_Reset(0);
11E76  8879     BSF LATA, 4, ACCESS
288:           	BT_SetReady(1);
11E78  8486     BSF TRISF, 2, ACCESS
289:           }
11E7A  0012     RETURN 0
290:           
291:           unsigned char GetSW2(void)
292:           {
293:           	unsigned char ret;
294:           
295:           	TRISD |= 0x3c;
296:           	WPUD |= 0x3c;
297:           	Nop();
298:           	Nop();
299:           	Nop();
300:           	Nop();
301:           	ret = (PORTD >> 2) & 0x0f;
302:           	WPUD &= 0xc3;
303:           	LATD &= 0xc3;
304:           	TRISD &= 0xc3;
305:           
306:           	return ret;
307:           }
308:           
309:           unsigned char GetChgState(void)
310:           {
311:           	unsigned char ret;
312:           
313:           	TRISF3 = 1;
125CE  8686     BSF TRISF, 3, ACCESS
314:           	WPUF3 = 1;
125D0  010E     MOVLB 0xE
125D2  87B3     BSF 0xB3, 3, BANKED
315:           	Nop();
125D4  F000     NOP
316:           	Nop();
125D6  F000     NOP
317:           	Nop();
125D8  F000     NOP
318:           	Nop();
125DA  F000     NOP
319:           	ret = !RF3;
125DC  B68E     BTFSC PORTF, 3, ACCESS
125DE  D002     BRA 0x25E4
125E0  0E01     MOVLW 0x1
125E2  D001     BRA 0x25E6
125E4  0E00     MOVLW 0x0
125E6  0100     MOVLB 0x0
125E8  6F79     MOVWF multiplier, BANKED
320:           	WPUF3 = 0;
125EA  010E     MOVLB 0xE
125EC  97B3     BCF 0xB3, 3, BANKED
321:           	LATF3 = 0;
125EE  967E     BCF LATF, 3, ACCESS
322:           	TRISF3 = 0;
125F0  9686     BCF TRISF, 3, ACCESS
323:           
324:           	return ret;
125F2  0100     MOVLB 0x0
125F4  5179     MOVF multiplier, W, BANKED
125F6  0012     RETURN 0
325:           }
0818  8041     BSF btemp, 0, ACCESS
326:           
327:           void waitMs(unsigned long t)
328:           {
329:           	time = 0;
12422  0E00     MOVLW 0x0
12424  6E05     MOVWF time, ACCESS
12426  0E00     MOVLW 0x0
12428  6E06     MOVWF 0x6, ACCESS
1242A  0E00     MOVLW 0x0
1242C  6E07     MOVWF 0x7, ACCESS
1242E  0E00     MOVLW 0x0
12430  6E08     MOVWF 0x8, ACCESS
330:           	while ((time / 2) < t);
12432  C005     MOVFF time, multiplicand
12434  F07D     NOP
12436  C006     MOVFF 0x6, c
12438  F07E     NOP
1243A  C007     MOVFF 0x7, d
1243C  F07F     NOP
1243E  C008     MOVFF 0x8, kc
12440  F080     NOP
12442  0100     MOVLB 0x0
12444  90D8     BCF STATUS, 0, ACCESS
12446  3380     RRCF kc, F, BANKED
12448  337F     RRCF d, F, BANKED
1244A  337E     RRCF c, F, BANKED
1244C  337D     RRCF multiplicand, F, BANKED
1244E  5179     MOVF multiplier, W, BANKED
12450  5D7D     SUBWF multiplicand, W, BANKED
12452  517A     MOVF e, W, BANKED
12454  597E     SUBWFB c, W, BANKED
12456  517B     MOVF kc, W, BANKED
12458  597F     SUBWFB d, W, BANKED
1245A  517C     MOVF sameRow, W, BANKED
1245C  5980     SUBWFB kc, W, BANKED
1245E  B0D8     BTFSC STATUS, 0, ACCESS
12460  0012     RETURN 0
12462  D7E7     BRA 0x2432
331:           }
332:           
333:           void showBatteryState(void)
334:           {
335:           	unsigned short v = GetFuel();
11D86  EC3E     CALL 0x11E7C, 0
11D88  F08F     NOP
11D8A  C07F     MOVFF d, c
11D8C  F08F     NOP
11D8E  C080     MOVFF kc, 0x90
11D90  F090     NOP
336:           	
337:           	showState(v);
11D92  C08F     MOVFF c, v
11D94  F08D     NOP
11D96  C090     MOVFF 0x90, row
11D98  F08E     NOP
11D9A  ECA0     CALL 0x11740, 0
11D9C  F08B     NOP
338:           	
339:           	//	LED1 = 0;
340:           	//	waitMs(500);
341:           	//	if (v > 400)
342:           	//	{
343:           	//		LED1 = 1;
344:           	//		waitMs(100);
345:           	//		LED1 = 0;
346:           	//		waitMs(300);
347:           	//	}
348:           	//	if (v > 370)
349:           	//	{
350:           	//		LED1 = 1;
351:           	//		waitMs(100);
352:           	//		LED1 = 0;
353:           	//		waitMs(300);
354:           	//	}
355:           	//	if (v > 350)
356:           	//	{
357:           	//		LED1 = 1;
358:           	//		waitMs(100);
359:           	//		LED1 = 0;
360:           	//		waitMs(300);
361:           	//	}
362:           	//	if (v > 330)
363:           	//	{
364:           	//		LED1 = 1;
365:           	//		waitMs(100);
366:           	//		LED1 = 0;
367:           	//		waitMs(300);
368:           	//	}
369:           
370:           #ifdef MICRO_QWERTY
371:           	led[LED_FNL] = v > 400;
11D9E  0E91     MOVLW 0x91
11DA0  0100     MOVLB 0x0
11DA2  5D8F     SUBWF c, W, BANKED
11DA4  0E01     MOVLW 0x1
11DA6  5990     SUBWFB 0x90, W, BANKED
11DA8  A0D8     BTFSS STATUS, 0, ACCESS
11DAA  D002     BRA 0x1DB0
11DAC  0E01     MOVLW 0x1
11DAE  D001     BRA 0x1DB2
11DB0  0E00     MOVLW 0x0
11DB2  6FAF     MOVWF 0xAF, BANKED
372:           	led[LED_ALT] = v > 370;
11DB4  0E73     MOVLW 0x73
11DB6  5D8F     SUBWF c, W, BANKED
11DB8  0E01     MOVLW 0x1
11DBA  5990     SUBWFB 0x90, W, BANKED
11DBC  A0D8     BTFSS STATUS, 0, ACCESS
11DBE  D002     BRA 0x1DC4
11DC0  0E01     MOVLW 0x1
11DC2  D001     BRA 0x1DC6
11DC4  0E00     MOVLW 0x0
11DC6  6FB2     MOVWF 0xB2, BANKED
373:           	led[LED_GUI] = v > 350;
11DC8  0E5F     MOVLW 0x5F
11DCA  5D8F     SUBWF c, W, BANKED
11DCC  0E01     MOVLW 0x1
11DCE  5990     SUBWFB 0x90, W, BANKED
11DD0  A0D8     BTFSS STATUS, 0, ACCESS
11DD2  D002     BRA 0x1DD8
11DD4  0E01     MOVLW 0x1
11DD6  D001     BRA 0x1DDA
11DD8  0E00     MOVLW 0x0
11DDA  6FB3     MOVWF 0xB3, BANKED
374:           	led[LED_CTL] = v > 330;
11DDC  0E4B     MOVLW 0x4B
11DDE  5D8F     SUBWF c, W, BANKED
11DE0  0E01     MOVLW 0x1
11DE2  5990     SUBWFB 0x90, W, BANKED
11DE4  A0D8     BTFSS STATUS, 0, ACCESS
11DE6  D002     BRA 0x1DEC
11DE8  0E01     MOVLW 0x1
11DEA  D001     BRA 0x1DEE
11DEC  0E00     MOVLW 0x0
11DEE  6FB1     MOVWF 0xB1, BANKED
375:           	
376:           	waitMs(500);
11DF0  0EF4     MOVLW 0xF4
11DF2  6F79     MOVWF multiplier, BANKED
11DF4  0E01     MOVLW 0x1
11DF6  6F7A     MOVWF e, BANKED
11DF8  0E00     MOVLW 0x0
11DFA  6F7B     MOVWF kc, BANKED
11DFC  0E00     MOVLW 0x0
11DFE  6F7C     MOVWF sameRow, BANKED
11E00  EC11     CALL 0x12422, 0
11E02  F092     NOP
377:           #endif
378:           }
11E04  0012     RETURN 0
379:           
380:           unsigned short GetFuel(void)
381:           {
382:           	unsigned char c = 0;
11E7C  0E00     MOVLW 0x0
11E7E  0100     MOVLB 0x0
11E80  6F86     MOVWF c, BANKED
383:           	unsigned short ret = 0;
11E82  0E00     MOVLW 0x0
11E84  6F85     MOVWF b, BANKED
11E86  0E00     MOVLW 0x0
11E88  6F84     MOVWF c, BANKED
384:           	BatCheckEn(1);
11E8A  8A79     BSF LATA, 5, ACCESS
385:           
386:           	for (c = 0; c < 10; c++)
11E8C  0E00     MOVLW 0x0
11E8E  6F86     MOVWF c, BANKED
11E90  0E09     MOVLW 0x9
11E92  6586     CPFSGT c, BANKED
11E94  D001     BRA 0x1E98
11E96  D014     BRA 0x1EC0
387:           	{
388:           		unsigned short r = ADCC_GetSingleConversion(0);
11E98  0E00     MOVLW 0x0
11E9A  EC10     CALL 0x12620, 0
11E9C  F093     NOP
11E9E  C079     MOVFF multiplier, c
11EA0  F082     NOP
11EA2  C07A     MOVFF e, 0x83
11EA4  F083     NOP
389:           		if (ret < r)
11EA6  0100     MOVLB 0x0
11EA8  5182     MOVF c, W, BANKED
11EAA  5D84     SUBWF c, W, BANKED
11EAC  5183     MOVF 0x83, W, BANKED
11EAE  5985     SUBWFB b, W, BANKED
11EB0  B0D8     BTFSC STATUS, 0, ACCESS
11EB2  D004     BRA 0x1EBC
390:           		{
391:           			ret = r;
11EB4  C082     MOVFF c, c
11EB6  F084     NOP
11EB8  C083     MOVFF 0x83, b
11EBA  F085     NOP
392:           		}
11EBC  2B86     INCF c, F, BANKED
11EBE  D7E8     BRA 0x1E90
393:           	}
394:           
395:           	BatCheckEn(0);
11EC0  9A79     BCF LATA, 5, ACCESS
396:           
397:           	return ret * 108 / 128; //110/128
11EC2  C084     MOVFF c, multiplier
11EC4  F079     NOP
11EC6  C085     MOVFF b, e
11EC8  F07A     NOP
11ECA  0E00     MOVLW 0x0
11ECC  6F7C     MOVWF sameRow, BANKED
11ECE  0E6C     MOVLW 0x6C
11ED0  6F7B     MOVWF kc, BANKED
11ED2  ECFC     CALL 0x125F8, 0
11ED4  F092     NOP
11ED6  0E07     MOVLW 0x7
11ED8  0100     MOVLB 0x0
11EDA  6F81     MOVWF product, BANKED
11EDC  90D8     BCF STATUS, 0, ACCESS
11EDE  337A     RRCF e, F, BANKED
11EE0  3379     RRCF multiplier, F, BANKED
11EE2  2F81     DECFSZ product, F, BANKED
11EE4  D7FB     BRA 0x1EDC
11EE6  C079     MOVFF multiplier, d
11EE8  F07F     NOP
11EEA  C07A     MOVFF e, kc
11EEC  F080     NOP
11EEE  0012     RETURN 0
398:           }
399:           
400:           void setSleepDelay(unsigned short second)
401:           {
402:           	unsigned long t = (unsigned long) second * 1953;
11FD4  C085     MOVFF b, multiplier
11FD6  F079     NOP
11FD8  C086     MOVFF c, e
11FDA  F07A     NOP
11FDC  0100     MOVLB 0x0
11FDE  6B7B     CLRF kc, BANKED
11FE0  6B7C     CLRF sameRow, BANKED
11FE2  0EA1     MOVLW 0xA1
11FE4  6F7D     MOVWF multiplicand, BANKED
11FE6  0E07     MOVLW 0x7
11FE8  6F7E     MOVWF c, BANKED
11FEA  0E00     MOVLW 0x0
11FEC  6F7F     MOVWF d, BANKED
11FEE  0E00     MOVLW 0x0
11FF0  6F80     MOVWF kc, BANKED
11FF2  ECE0     CALL 0x121C0, 0
11FF4  F090     NOP
11FF6  C079     MOVFF multiplier, t
11FF8  F088     NOP
11FFA  C07A     MOVFF e, 0x89
11FFC  F089     NOP
11FFE  C07B     MOVFF kc, 0x8A
12000  F08A     NOP
12002  C07C     MOVFF sameRow, col
12004  F08B     NOP
403:           	unsigned char gie = INTCONbits.GIE ;
12006  0E00     MOVLW 0x0
12008  BEF2     BTFSC INTCON, 7, ACCESS
1200A  0E01     MOVLW 0x1
1200C  0100     MOVLB 0x0
1200E  6F87     MOVWF d, BANKED
404:           	
405:           	INTCONbits.GIE = 0;
12010  9EF2     BCF INTCON, 7, ACCESS
406:           	if (sleepCountDown < t)
12012  5188     MOVF t, W, BANKED
12014  5C01     SUBWF sleepCountDown, W, ACCESS
12016  5189     MOVF 0x89, W, BANKED
12018  5802     SUBWFB 0x2, W, ACCESS
1201A  518A     MOVF 0x8A, W, BANKED
1201C  5803     SUBWFB 0x3, W, ACCESS
1201E  518B     MOVF col, W, BANKED
12020  5804     SUBWFB 0x4, W, ACCESS
12022  B0D8     BTFSC STATUS, 0, ACCESS
12024  D008     BRA 0x2036
407:           	{
408:           		sleepCountDown = t;
12026  C088     MOVFF t, sleepCountDown
12028  F001     NOP
1202A  C089     MOVFF 0x89, 0x2
1202C  F002     NOP
1202E  C08A     MOVFF 0x8A, 0x3
12030  F003     NOP
12032  C08B     MOVFF col, 0x4
12034  F004     NOP
409:           	}
410:           	INTCONbits.GIE = gie;
12036  B187     BTFSC d, 0, BANKED
12038  D002     BRA 0x203E
1203A  9EF2     BCF INTCON, 7, ACCESS
1203C  D001     BRA 0x2040
1203E  8EF2     BSF INTCON, 7, ACCESS
411:           }
12040  0012     RETURN 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/system.c  -----------------------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:                 #include <xc.h>         /* XC8 General Include File */
6:             
7:             #include <stdint.h>         /* For uint8_t definition */
8:             #include <stdbool.h>        /* For true/false definition */
9:             
10:            #include "system.h"
11:            
12:            /* Refer to the device datasheet for information about available
13:            oscillator configurations. */
14:            void ConfigureOscillator(void)
15:            {
16:                /* TODO Add clock switching code if appropriate.  */
17:            
18:                /* Typical actions in this function are to tweak the oscillator tuning
19:                register, select new clock sources, and to wait until new clock sources
20:                are stable before resuming execution of the main project. */\
21:            	
22:            	
23:                // NOSC HFINTOSC; NDIV 1; 
24:                OSCCON1 = 0x60;
126F4  0E60     MOVLW 0x60
126F6  010E     MOVLB 0xE
126F8  6F43     MOVWF 0x43, BANKED
25:                // CSWHOLD may proceed; SOSCPWR Low power; 
26:                OSCCON3 = 0x00;
126FA  0E00     MOVLW 0x0
126FC  6F45     MOVWF 0x45, BANKED
27:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
28:                OSCEN = 0x00;
126FE  0E00     MOVLW 0x0
12700  6F47     MOVWF 0x47, BANKED
29:                // HFFRQ 16_MHz; 
30:                OSCFRQ = 0x05;
12702  0E05     MOVLW 0x5
12704  6F49     MOVWF 0x49, BANKED
31:                // TUN 0; 
32:                OSCTUNE = 0x00;
12706  0E00     MOVLW 0x0
12708  6F48     MOVWF 0x48, BANKED
33:            }
1270A  0012     RETURN 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/swMatrix.c  ---------------------------------
1:             /*
2:              * File:   swMatrix.c
3:              * Author: imada
4:              *
5:              * Created on May 30, 2018, 7:46 PM
6:              */
7:             
8:             #include <xc.h>         /* XC8 General Include File */
9:             
10:            //#include <stdint.h>         /* For uint8_t definition */
11:            //#include <stdbool.h>        /* For true/false definition */
12:            //#include <stdlib.h>        
13:            
14:            #include "user.h"
15:            #include "swMatrix.h"
16:            #include "keys.h"
17:            
18:            #define	ON_COUNT	5
19:            
20:            #define N_PUSHABLE	10
21:            
22:            //#define	N_COL		16		//fixed  16
23:            
24:            
25:            #ifdef MICRO_QWERTY
26:            #define NO_DIODE
27:            #define	N_ROW		6
28:            #define	swInput	((~(((unsigned short)bitOrderSwap[PORTE] << 8) | bitOrderSwap[PORTB])) & 0x0fff)
29:            #endif
30:            
31:            #ifdef	REMOTE_CONTROL
32:            #define NO_DIODE
33:            #define	N_ROW		3
34:            #define	swInput (~bitOrderSwap[PORTB&0x20|(PORTB&0x90>>1)|(PORTB&0x48)<<1]))
35:            #endif
36:            
37:            #ifdef ORIGINAL
38:            //#define NO_DIODE
39:            #define	N_ROW		6
40:            #define	swInput	((~(((unsigned short)bitOrderSwap[PORTE] << 8) | bitOrderSwap[PORTB])) & 0xffff)
41:            #endif
42:            
43:            static const unsigned char rowTable[] = {~0x01, ~0x02, ~0x40, ~0x80, ~0x04, ~0x08, ~0x10, ~0x20};
44:            
45:            #define B2(n) n,     n+1,     n+1,     n+2
46:            #define B4(n) B2(n), B2(n+1), B2(n+1), B2(n+2)
47:            #define B6(n) B4(n), B4(n+1), B4(n+1), B4(n+2)
48:            static const unsigned char popCount8bits[] = {
49:            	B6(0), B6(1), B6(1), B6(2)
50:            };
51:            
52:            static const unsigned char bitOrderSwap[] = {
53:            	0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
54:            	0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
55:            	0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
56:            	0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
57:            	0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
58:            	0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
59:            	0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
60:            	0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
61:            	0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
62:            	0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
63:            	0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
64:            	0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
65:            	0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
66:            	0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
67:            	0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
68:            	0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
69:            };
70:            
71:            #define	popCount16bits(x)	(popCount8bits[(unsigned char)x]+popCount8bits[(unsigned char)(x >> 8)])
72:            
73:            struct MoniteringSwitch mSw[N_PUSHABLE];
74:            unsigned char firstPush = 0xff;
75:            unsigned char lastPush = 0xff;
76:            
77:            unsigned short sw[N_ROW];
78:            
79:            
80:            /******************************************************************************/
81:            /* User Functions                                                             */
82:            /******************************************************************************/
83:            /* <Initialize variables in user.h and insert code for user algorithms.> */
84:            void InitUiBoardIO(void)
85:            {
86:            	unsigned char c;
87:            
88:            	TRISD |= 0x03;
11AA0  0E03     MOVLW 0x3
11AA2  1284     IORWF TRISD, F, ACCESS
89:            	TRISB = PORTBMASK;
11AA4  6882     SETF TRISB, ACCESS
90:            	TRISC = 0x00;
11AA6  0E00     MOVLW 0x0
11AA8  6E83     MOVWF TRISC, ACCESS
91:            	TRISE = PORTEMASK;
11AAA  0EF0     MOVLW 0xF0
11AAC  6E85     MOVWF TRISE, ACCESS
92:            
93:            	WPUB = PORTBMASK;
11AAE  010E     MOVLB 0xE
11AB0  6999     SETF 0x99, BANKED
94:            	WPUC = 0x00;
11AB2  0E00     MOVLW 0x0
11AB4  6FA1     MOVWF 0xA1, BANKED
95:            	WPUE = PORTEMASK;
11AB6  0EF0     MOVLW 0xF0
11AB8  6FAE     MOVWF 0xAE, BANKED
96:            
97:            	//	IOCBP = IOCBN = PORTBMASK;
98:            	//	IOCEP = IOCEN = PORTEMASK;
99:            	//
100:           	//	IOCBF = 0x00;
101:           	//	IOCEF = 0x00;
102:           	//	PIE0bits.IOCIE = 1;
103:           	//	IPR0bits.IOCIP = 0;
104:           
105:           	for (c = 0; c < N_ROW; c++)
11ABA  0E00     MOVLW 0x0
11ABC  0100     MOVLB 0x0
11ABE  6F79     MOVWF multiplier, BANKED
11AC0  0E05     MOVLW 0x5
11AC2  6579     CPFSGT multiplier, BANKED
11AC4  D001     BRA 0x1AC8
11AC6  D00E     BRA 0x1AE4
11AE0  2B79     INCF multiplier, F, BANKED
11AE2  D7EE     BRA 0x1AC0
106:           	{
107:           		sw[c] = 0;
11AC8  5179     MOVF multiplier, W, BANKED
11ACA  0D02     MULLW 0x2
11ACC  0EA0     MOVLW 0xA0
11ACE  24F3     ADDWF PROD, W, ACCESS
11AD0  6ED9     MOVWF FSR2, ACCESS
11AD2  0E00     MOVLW 0x0
11AD4  20F4     ADDWFC PRODH, W, ACCESS
11AD6  6EDA     MOVWF FSR2H, ACCESS
11AD8  0E00     MOVLW 0x0
11ADA  6EDE     MOVWF POSTINC2, ACCESS
11ADC  0E00     MOVLW 0x0
11ADE  6EDD     MOVWF POSTDEC2, ACCESS
108:           	}
109:           	for (c = 0; c < N_PUSHABLE; c++)
11AE4  0E00     MOVLW 0x0
11AE6  6F79     MOVWF multiplier, BANKED
11AE8  0E09     MOVLW 0x9
11AEA  6579     CPFSGT multiplier, BANKED
11AEC  D001     BRA 0x1AF0
11AEE  0012     RETURN 0
11B40  2B79     INCF multiplier, F, BANKED
110:           	{
111:           		mSw[c].count = 0;
11AF0  5179     MOVF multiplier, W, BANKED
11AF2  0D07     MULLW 0x7
11AF4  0E00     MOVLW 0x0
11AF6  24F3     ADDWF PROD, W, ACCESS
11AF8  6ED9     MOVWF FSR2, ACCESS
11AFA  0E01     MOVLW 0x1
11AFC  20F4     ADDWFC PRODH, W, ACCESS
11AFE  6EDA     MOVWF FSR2H, ACCESS
11B00  0E00     MOVLW 0x0
11B02  6EDF     MOVWF INDF2, ACCESS
112:           		mSw[c].num = 0xff;
11B04  5179     MOVF multiplier, W, BANKED
11B06  0D07     MULLW 0x7
11B08  0E02     MOVLW 0x2
11B0A  26F3     ADDWF PROD, F, ACCESS
11B0C  0E00     MOVLW 0x0
11B0E  22F4     ADDWFC PRODH, F, ACCESS
11B10  0E00     MOVLW 0x0
11B12  24F3     ADDWF PROD, W, ACCESS
11B14  6ED9     MOVWF FSR2, ACCESS
11B16  0E01     MOVLW 0x1
11B18  20F4     ADDWFC PRODH, W, ACCESS
11B1A  6EDA     MOVWF FSR2H, ACCESS
11B1C  0EFF     MOVLW 0xFF
11B1E  6EDF     MOVWF INDF2, ACCESS
113:           		mSw[c].kc = 0;
11B20  5179     MOVF multiplier, W, BANKED
11B22  0D07     MULLW 0x7
11B24  0E05     MOVLW 0x5
11B26  26F3     ADDWF PROD, F, ACCESS
11B28  0E00     MOVLW 0x0
11B2A  22F4     ADDWFC PRODH, F, ACCESS
11B2C  0E00     MOVLW 0x0
11B2E  24F3     ADDWF PROD, W, ACCESS
11B30  6ED9     MOVWF FSR2, ACCESS
11B32  0E01     MOVLW 0x1
11B34  20F4     ADDWFC PRODH, W, ACCESS
11B36  6EDA     MOVWF FSR2H, ACCESS
11B38  0E00     MOVLW 0x0
11B3A  6EDE     MOVWF POSTINC2, ACCESS
11B3C  0E00     MOVLW 0x0
11B3E  6EDD     MOVWF POSTDEC2, ACCESS
11B40  2B79     INCF multiplier, F, BANKED
11B42  D7D2     BRA 0x1AE8
114:           	}
115:           }
116:           
117:           void StandbyUiBoardIO(void)
118:           {
119:           	//Set to lowest power consumption state!
120:           
121:           	LATB = PORTBMASK; //SWs
124E6  687A     SETF LATB, ACCESS
122:           	LATC = 0x00; //SWs common
124E8  0E00     MOVLW 0x0
124EA  6E7B     MOVWF LATC, ACCESS
123:           	LATE = PORTEMASK; //SWs & LEDs
124EC  0EF0     MOVLW 0xF0
124EE  6E7D     MOVWF LATE, ACCESS
124:           
125:           	TRISB = PORTBMASK;
124F0  6882     SETF TRISB, ACCESS
126:           	TRISC = 0x00;
124F2  0E00     MOVLW 0x0
124F4  6E83     MOVWF TRISC, ACCESS
127:           	TRISE = PORTEMASK;
124F6  0EF0     MOVLW 0xF0
124F8  6E85     MOVWF TRISE, ACCESS
128:           
129:           	ANSELB = 0x00;
124FA  0E00     MOVLW 0x0
124FC  010E     MOVLB 0xE
124FE  6F9A     MOVWF 0x9A, BANKED
130:           	ANSELE = 0x00;
12500  0E00     MOVLW 0x0
12502  6FAF     MOVWF 0xAF, BANKED
131:           
132:           	WPUB = PORTBMASK;
12504  6999     SETF 0x99, BANKED
133:           	WPUC = 0x00;
12506  0E00     MOVLW 0x0
12508  6FA1     MOVWF 0xA1, BANKED
134:           	WPUE = PORTEMASK;
1250A  0EF0     MOVLW 0xF0
1250C  6FAE     MOVWF 0xAE, BANKED
135:           
136:           	INLVLB = 0xff;
1250E  6996     SETF 0x96, BANKED
137:           	INLVLC = 0xff;
12510  699E     SETF c, BANKED
138:           	INLVLE = 0xff;
12512  69AB     SETF 0xAB, BANKED
139:           
140:           	SLRCONB = 0xff;
12514  6997     SETF 0x97, BANKED
141:           	SLRCONC = 0xff;
12516  699F     SETF c, BANKED
142:           	SLRCONE = 0xff;
12518  69AC     SETF led, BANKED
143:           
144:           	ODCONB = 0x00;
1251A  0E00     MOVLW 0x0
1251C  6F98     MOVWF 0x98, BANKED
145:           	ODCONC = 0xff;
1251E  69A0     SETF sw, BANKED
146:           	ODCONE = 0x00;
12520  0E00     MOVLW 0x0
12522  6FAD     MOVWF 0xAD, BANKED
147:           }
12524  0012     RETURN 0
148:           
149:           void swUnregister(unsigned char c)
113CC  0100     MOVLB 0x0
113CE  6F80     MOVWF kc, BANKED
150:           {
151:           	swRelease(c);
113D0  0100     MOVLB 0x0
113D2  5180     MOVF kc, W, BANKED
113D4  ECC8     CALL 0x11590, 0
113D6  F08A     NOP
152:           	mSw[c].state = 0;
113D8  0100     MOVLB 0x0
113DA  5180     MOVF kc, W, BANKED
113DC  0D07     MULLW 0x7
113DE  0E01     MOVLW 0x1
113E0  26F3     ADDWF PROD, F, ACCESS
113E2  0E00     MOVLW 0x0
113E4  22F4     ADDWFC PRODH, F, ACCESS
113E6  0E00     MOVLW 0x0
113E8  24F3     ADDWF PROD, W, ACCESS
113EA  6ED9     MOVWF FSR2, ACCESS
113EC  0E01     MOVLW 0x1
113EE  20F4     ADDWFC PRODH, W, ACCESS
113F0  6EDA     MOVWF FSR2H, ACCESS
113F2  0E00     MOVLW 0x0
113F4  6EDF     MOVWF INDF2, ACCESS
153:           	mSw[c].num = 0xff;
113F6  5180     MOVF kc, W, BANKED
113F8  0D07     MULLW 0x7
113FA  0E02     MOVLW 0x2
113FC  26F3     ADDWF PROD, F, ACCESS
113FE  0E00     MOVLW 0x0
11400  22F4     ADDWFC PRODH, F, ACCESS
11402  0E00     MOVLW 0x0
11404  24F3     ADDWF PROD, W, ACCESS
11406  6ED9     MOVWF FSR2, ACCESS
11408  0E01     MOVLW 0x1
1140A  20F4     ADDWFC PRODH, W, ACCESS
1140C  6EDA     MOVWF FSR2H, ACCESS
1140E  0EFF     MOVLW 0xFF
11410  6EDF     MOVWF INDF2, ACCESS
154:           	mSw[c].kc = 0;
11412  5180     MOVF kc, W, BANKED
11414  0D07     MULLW 0x7
11416  0E05     MOVLW 0x5
11418  26F3     ADDWF PROD, F, ACCESS
1141A  0E00     MOVLW 0x0
1141C  22F4     ADDWFC PRODH, F, ACCESS
1141E  0E00     MOVLW 0x0
11420  24F3     ADDWF PROD, W, ACCESS
11422  6ED9     MOVWF FSR2, ACCESS
11424  0E01     MOVLW 0x1
11426  20F4     ADDWFC PRODH, W, ACCESS
11428  6EDA     MOVWF FSR2H, ACCESS
1142A  0E00     MOVLW 0x0
1142C  6EDE     MOVWF POSTINC2, ACCESS
1142E  0E00     MOVLW 0x0
11430  6EDD     MOVWF POSTDEC2, ACCESS
155:           
156:           	if (mSw[c].next == 0xff)
11432  5180     MOVF kc, W, BANKED
11434  0D07     MULLW 0x7
11436  0E04     MOVLW 0x4
11438  26F3     ADDWF PROD, F, ACCESS
1143A  0E00     MOVLW 0x0
1143C  22F4     ADDWFC PRODH, F, ACCESS
1143E  0E00     MOVLW 0x0
11440  24F3     ADDWF PROD, W, ACCESS
11442  6ED9     MOVWF FSR2, ACCESS
11444  0E01     MOVLW 0x1
11446  20F4     ADDWFC PRODH, W, ACCESS
11448  6EDA     MOVWF FSR2H, ACCESS
1144A  28DE     INCF POSTINC2, W, ACCESS
1144C  A4D8     BTFSS STATUS, 2, ACCESS
1144E  D020     BRA 0x1490
157:           	{
158:           		lastPush = mSw[c].pre;
11450  5180     MOVF kc, W, BANKED
11452  0D07     MULLW 0x7
11454  0E03     MOVLW 0x3
11456  26F3     ADDWF PROD, F, ACCESS
11458  0E00     MOVLW 0x0
1145A  22F4     ADDWFC PRODH, F, ACCESS
1145C  0E00     MOVLW 0x0
1145E  24F3     ADDWF PROD, W, ACCESS
11460  6ED9     MOVWF FSR2, ACCESS
11462  0E01     MOVLW 0x1
11464  20F4     ADDWFC PRODH, W, ACCESS
11466  6EDA     MOVWF FSR2H, ACCESS
11468  50DF     MOVF INDF2, W, ACCESS
1146A  6FDE     MOVWF lastPush, BANKED
159:           		if (lastPush != 0xff)
1146C  29DE     INCF lastPush, W, BANKED
1146E  B4D8     BTFSC STATUS, 2, ACCESS
11470  D037     BRA 0x14E0
160:           		{
161:           			mSw[lastPush].next = 0xff;
11472  51DE     MOVF lastPush, W, BANKED
11474  0D07     MULLW 0x7
11476  0E04     MOVLW 0x4
11478  26F3     ADDWF PROD, F, ACCESS
1147A  0E00     MOVLW 0x0
1147C  22F4     ADDWFC PRODH, F, ACCESS
1147E  0E00     MOVLW 0x0
11480  24F3     ADDWF PROD, W, ACCESS
11482  6ED9     MOVWF FSR2, ACCESS
11484  0E01     MOVLW 0x1
11486  20F4     ADDWFC PRODH, W, ACCESS
11488  6EDA     MOVWF FSR2H, ACCESS
1148A  0EFF     MOVLW 0xFF
1148C  6EDF     MOVWF INDF2, ACCESS
162:           		}
163:           	}
1148E  D028     BRA 0x14E0
164:           	else
165:           	{
166:           		mSw[mSw[c].next].pre = mSw[c].pre;
11490  5180     MOVF kc, W, BANKED
11492  0D07     MULLW 0x7
11494  0E03     MOVLW 0x3
11496  26F3     ADDWF PROD, F, ACCESS
11498  0E00     MOVLW 0x0
1149A  22F4     ADDWFC PRODH, F, ACCESS
1149C  0E00     MOVLW 0x0
1149E  24F3     ADDWF PROD, W, ACCESS
114A0  6ED9     MOVWF FSR2, ACCESS
114A2  0E01     MOVLW 0x1
114A4  20F4     ADDWFC PRODH, W, ACCESS
114A6  6EDA     MOVWF FSR2H, ACCESS
114A8  5180     MOVF kc, W, BANKED
114AA  0D07     MULLW 0x7
114AC  0E04     MOVLW 0x4
114AE  26F3     ADDWF PROD, F, ACCESS
114B0  0E00     MOVLW 0x0
114B2  22F4     ADDWFC PRODH, F, ACCESS
114B4  0E00     MOVLW 0x0
114B6  24F3     ADDWF PROD, W, ACCESS
114B8  6EE1     MOVWF FSR1, ACCESS
114BA  0E01     MOVLW 0x1
114BC  20F4     ADDWFC PRODH, W, ACCESS
114BE  6EE2     MOVWF FSR1H, ACCESS
114C0  50E7     MOVF INDF1, W, ACCESS
114C2  6F7F     MOVWF d, BANKED
114C4  517F     MOVF d, W, BANKED
114C6  0D07     MULLW 0x7
114C8  0E03     MOVLW 0x3
114CA  26F3     ADDWF PROD, F, ACCESS
114CC  0E00     MOVLW 0x0
114CE  22F4     ADDWFC PRODH, F, ACCESS
114D0  0E00     MOVLW 0x0
114D2  24F3     ADDWF PROD, W, ACCESS
114D4  6EE1     MOVWF FSR1, ACCESS
114D6  0E01     MOVLW 0x1
114D8  20F4     ADDWFC PRODH, W, ACCESS
114DA  6EE2     MOVWF FSR1H, ACCESS
114DC  CFDF     MOVFF INDF2, INDF1
114DE  FFE7     NOP
167:           	}
168:           
169:           	if (mSw[c].pre == 0xff)
114E0  5180     MOVF kc, W, BANKED
114E2  0D07     MULLW 0x7
114E4  0E03     MOVLW 0x3
114E6  26F3     ADDWF PROD, F, ACCESS
114E8  0E00     MOVLW 0x0
114EA  22F4     ADDWFC PRODH, F, ACCESS
114EC  0E00     MOVLW 0x0
114EE  24F3     ADDWF PROD, W, ACCESS
114F0  6ED9     MOVWF FSR2, ACCESS
114F2  0E01     MOVLW 0x1
114F4  20F4     ADDWFC PRODH, W, ACCESS
114F6  6EDA     MOVWF FSR2H, ACCESS
114F8  28DE     INCF POSTINC2, W, ACCESS
114FA  A4D8     BTFSS STATUS, 2, ACCESS
114FC  D020     BRA 0x153E
170:           	{
171:           		firstPush = mSw[c].next;
114FE  5180     MOVF kc, W, BANKED
11500  0D07     MULLW 0x7
11502  0E04     MOVLW 0x4
11504  26F3     ADDWF PROD, F, ACCESS
11506  0E00     MOVLW 0x0
11508  22F4     ADDWFC PRODH, F, ACCESS
1150A  0E00     MOVLW 0x0
1150C  24F3     ADDWF PROD, W, ACCESS
1150E  6ED9     MOVWF FSR2, ACCESS
11510  0E01     MOVLW 0x1
11512  20F4     ADDWFC PRODH, W, ACCESS
11514  6EDA     MOVWF FSR2H, ACCESS
11516  50DF     MOVF INDF2, W, ACCESS
11518  6FDF     MOVWF firstPush, BANKED
172:           		if (firstPush != 0xff)
1151A  29DF     INCF firstPush, W, BANKED
1151C  B4D8     BTFSC STATUS, 2, ACCESS
1151E  0012     RETURN 0
173:           		{
174:           			mSw[firstPush].pre = 0xff;
11520  51DF     MOVF firstPush, W, BANKED
11522  0D07     MULLW 0x7
11524  0E03     MOVLW 0x3
11526  26F3     ADDWF PROD, F, ACCESS
11528  0E00     MOVLW 0x0
1152A  22F4     ADDWFC PRODH, F, ACCESS
1152C  0E00     MOVLW 0x0
1152E  24F3     ADDWF PROD, W, ACCESS
11530  6ED9     MOVWF FSR2, ACCESS
11532  0E01     MOVLW 0x1
11534  20F4     ADDWFC PRODH, W, ACCESS
11536  6EDA     MOVWF FSR2H, ACCESS
11538  0EFF     MOVLW 0xFF
1153A  6EDF     MOVWF INDF2, ACCESS
175:           		}
176:           	}
1153C  0012     RETURN 0
177:           	else
178:           	{
179:           		mSw[mSw[c].pre].next = mSw[c].next;
1153E  5180     MOVF kc, W, BANKED
11540  0D07     MULLW 0x7
11542  0E04     MOVLW 0x4
11544  26F3     ADDWF PROD, F, ACCESS
11546  0E00     MOVLW 0x0
11548  22F4     ADDWFC PRODH, F, ACCESS
1154A  0E00     MOVLW 0x0
1154C  24F3     ADDWF PROD, W, ACCESS
1154E  6ED9     MOVWF FSR2, ACCESS
11550  0E01     MOVLW 0x1
11552  20F4     ADDWFC PRODH, W, ACCESS
11554  6EDA     MOVWF FSR2H, ACCESS
11556  5180     MOVF kc, W, BANKED
11558  0D07     MULLW 0x7
1155A  0E03     MOVLW 0x3
1155C  26F3     ADDWF PROD, F, ACCESS
1155E  0E00     MOVLW 0x0
11560  22F4     ADDWFC PRODH, F, ACCESS
11562  0E00     MOVLW 0x0
11564  24F3     ADDWF PROD, W, ACCESS
11566  6EE1     MOVWF FSR1, ACCESS
11568  0E01     MOVLW 0x1
1156A  20F4     ADDWFC PRODH, W, ACCESS
1156C  6EE2     MOVWF FSR1H, ACCESS
1156E  50E7     MOVF INDF1, W, ACCESS
11570  6F7F     MOVWF d, BANKED
11572  517F     MOVF d, W, BANKED
11574  0D07     MULLW 0x7
11576  0E04     MOVLW 0x4
11578  26F3     ADDWF PROD, F, ACCESS
1157A  0E00     MOVLW 0x0
1157C  22F4     ADDWFC PRODH, F, ACCESS
1157E  0E00     MOVLW 0x0
11580  24F3     ADDWF PROD, W, ACCESS
11582  6EE1     MOVWF FSR1, ACCESS
11584  0E01     MOVLW 0x1
11586  20F4     ADDWFC PRODH, W, ACCESS
11588  6EE2     MOVWF FSR1H, ACCESS
1158A  CFDF     MOVFF INDF2, INDF1
1158C  FFE7     NOP
1158E  0012     RETURN 0
180:           	}
181:           }
182:           
183:           void swRegister(unsigned char n)
10F5E  0100     MOVLB 0x0
10F60  6F7D     MOVWF multiplicand, BANKED
184:           {
185:           	unsigned char c;
186:           #ifdef NO_DIODE
187:           	unsigned char sameCol = 0;
10F62  0E00     MOVLW 0x0
10F64  0100     MOVLB 0x0
10F66  6F7B     MOVWF kc, BANKED
188:           	unsigned char sameRow = 0;
10F68  0E00     MOVLW 0x0
10F6A  6F7C     MOVWF sameRow, BANKED
189:           #endif
190:           	for (c = 0; c < N_PUSHABLE; c++)
10F6C  0E00     MOVLW 0x0
10F6E  6F80     MOVWF kc, BANKED
10F70  0E09     MOVLW 0x9
10F72  6580     CPFSGT kc, BANKED
10F74  D001     BRA 0xF78
10F76  D012     BRA 0xF9C
10F98  2B80     INCF kc, F, BANKED
10F9A  D7EA     BRA 0xF70
191:           	{
192:           		if (mSw[c].num == n)
10F78  5180     MOVF kc, W, BANKED
10F7A  0D07     MULLW 0x7
10F7C  0E02     MOVLW 0x2
10F7E  26F3     ADDWF PROD, F, ACCESS
10F80  0E00     MOVLW 0x0
10F82  22F4     ADDWFC PRODH, F, ACCESS
10F84  0E00     MOVLW 0x0
10F86  24F3     ADDWF PROD, W, ACCESS
10F88  6ED9     MOVWF FSR2, ACCESS
10F8A  0E01     MOVLW 0x1
10F8C  20F4     ADDWFC PRODH, W, ACCESS
10F8E  6EDA     MOVWF FSR2H, ACCESS
10F90  517D     MOVF multiplicand, W, BANKED
10F92  18DE     XORWF POSTINC2, W, ACCESS
10F94  B4D8     BTFSC STATUS, 2, ACCESS
10F96  0012     RETURN 0
193:           		{
194:           			return; //Already registered
195:           		}
196:           	}
197:           #ifdef NO_DIODE
198:           	for (c = 0; c < N_PUSHABLE; c++)
10F9C  0E00     MOVLW 0x0
10F9E  6F80     MOVWF kc, BANKED
10FA0  0E09     MOVLW 0x9
10FA2  6580     CPFSGT kc, BANKED
10FA4  D001     BRA 0xFA8
10FA6  D086     BRA 0x10B4
110B0  2B80     INCF kc, F, BANKED
110B2  D776     BRA 0xFA0
199:           	{
200:           		if (((mSw[c].num ^ n) & 0x0f) == 0)
10FA8  5180     MOVF kc, W, BANKED
10FAA  0D07     MULLW 0x7
10FAC  0E02     MOVLW 0x2
10FAE  26F3     ADDWF PROD, F, ACCESS
10FB0  0E00     MOVLW 0x0
10FB2  22F4     ADDWFC PRODH, F, ACCESS
10FB4  0E00     MOVLW 0x0
10FB6  24F3     ADDWF PROD, W, ACCESS
10FB8  6ED9     MOVWF FSR2, ACCESS
10FBA  0E01     MOVLW 0x1
10FBC  20F4     ADDWFC PRODH, W, ACCESS
10FBE  6EDA     MOVWF FSR2H, ACCESS
10FC0  50DF     MOVF INDF2, W, ACCESS
10FC2  197D     XORWF multiplicand, W, BANKED
10FC4  6F79     MOVWF multiplier, BANKED
10FC6  0E0F     MOVLW 0xF
10FC8  1779     ANDWF multiplier, F, BANKED
10FCA  A4D8     BTFSS STATUS, 2, ACCESS
10FCC  D02F     BRA 0x102C
201:           		{
202:           			unsigned char d;
203:           			sameCol = 1;
10FCE  0E01     MOVLW 0x1
10FD0  6F7B     MOVWF kc, BANKED
204:           			for (d = 0; d < N_PUSHABLE; d++)
10FD2  0E00     MOVLW 0x0
10FD4  6F7E     MOVWF c, BANKED
10FD6  0E09     MOVLW 0x9
10FD8  657E     CPFSGT c, BANKED
10FDA  D001     BRA 0xFDE
10FDC  D069     BRA 0x10B0
205:           			{
206:           				if (((mSw[c].num ^ mSw[d].num) & 0xf0) == 0)
10FDE  517E     MOVF c, W, BANKED
10FE0  0D07     MULLW 0x7
10FE2  0E02     MOVLW 0x2
10FE4  26F3     ADDWF PROD, F, ACCESS
10FE6  0E00     MOVLW 0x0
10FE8  22F4     ADDWFC PRODH, F, ACCESS
10FEA  0E00     MOVLW 0x0
10FEC  24F3     ADDWF PROD, W, ACCESS
10FEE  6ED9     MOVWF FSR2, ACCESS
10FF0  0E01     MOVLW 0x1
10FF2  20F4     ADDWFC PRODH, W, ACCESS
10FF4  6EDA     MOVWF FSR2H, ACCESS
10FF6  50DF     MOVF INDF2, W, ACCESS
10FF8  6F79     MOVWF multiplier, BANKED
10FFA  5180     MOVF kc, W, BANKED
10FFC  0D07     MULLW 0x7
10FFE  0E02     MOVLW 0x2
11000  26F3     ADDWF PROD, F, ACCESS
11002  0E00     MOVLW 0x0
11004  22F4     ADDWFC PRODH, F, ACCESS
11006  0E00     MOVLW 0x0
11008  24F3     ADDWF PROD, W, ACCESS
1100A  6ED9     MOVWF FSR2, ACCESS
1100C  0E01     MOVLW 0x1
1100E  20F4     ADDWFC PRODH, W, ACCESS
11010  6EDA     MOVWF FSR2H, ACCESS
11012  50DF     MOVF INDF2, W, ACCESS
11014  1979     XORWF multiplier, W, BANKED
11016  6F7A     MOVWF e, BANKED
11018  0EF0     MOVLW 0xF0
1101A  177A     ANDWF e, F, BANKED
1101C  A4D8     BTFSS STATUS, 2, ACCESS
1101E  D004     BRA 0x1028
207:           				{
208:           					if (d != c)
11020  5180     MOVF kc, W, BANKED
11022  197E     XORWF c, W, BANKED
11024  A4D8     BTFSS STATUS, 2, ACCESS
11026  0012     RETURN 0
209:           					{
210:           						return; //Ghost
211:           					}
11028  2B7E     INCF c, F, BANKED
1102A  D7D5     BRA 0xFD6
212:           				}
213:           			}
214:           		}
215:           		else if (((mSw[c].num ^ n) & 0xf0) == 0)
1102C  5180     MOVF kc, W, BANKED
1102E  0D07     MULLW 0x7
11030  0E02     MOVLW 0x2
11032  26F3     ADDWF PROD, F, ACCESS
11034  0E00     MOVLW 0x0
11036  22F4     ADDWFC PRODH, F, ACCESS
11038  0E00     MOVLW 0x0
1103A  24F3     ADDWF PROD, W, ACCESS
1103C  6ED9     MOVWF FSR2, ACCESS
1103E  0E01     MOVLW 0x1
11040  20F4     ADDWFC PRODH, W, ACCESS
11042  6EDA     MOVWF FSR2H, ACCESS
11044  50DF     MOVF INDF2, W, ACCESS
11046  197D     XORWF multiplicand, W, BANKED
11048  6F79     MOVWF multiplier, BANKED
1104A  0EF0     MOVLW 0xF0
1104C  1779     ANDWF multiplier, F, BANKED
1104E  A4D8     BTFSS STATUS, 2, ACCESS
11050  D02F     BRA 0x10B0
216:           		{
217:           			unsigned char d;
218:           			sameRow = 1;
11052  0E01     MOVLW 0x1
11054  6F7C     MOVWF sameRow, BANKED
219:           			for (d = 0; d < N_PUSHABLE; d++)
11056  0E00     MOVLW 0x0
11058  6F7F     MOVWF d, BANKED
1105A  0E09     MOVLW 0x9
1105C  657F     CPFSGT d, BANKED
1105E  D001     BRA 0x1062
11060  D027     BRA 0x10B0
220:           			{
221:           				if (((mSw[c].num ^ mSw[d].num) & 0x0f) == 0)
11062  517F     MOVF d, W, BANKED
11064  0D07     MULLW 0x7
11066  0E02     MOVLW 0x2
11068  26F3     ADDWF PROD, F, ACCESS
1106A  0E00     MOVLW 0x0
1106C  22F4     ADDWFC PRODH, F, ACCESS
1106E  0E00     MOVLW 0x0
11070  24F3     ADDWF PROD, W, ACCESS
11072  6ED9     MOVWF FSR2, ACCESS
11074  0E01     MOVLW 0x1
11076  20F4     ADDWFC PRODH, W, ACCESS
11078  6EDA     MOVWF FSR2H, ACCESS
1107A  50DF     MOVF INDF2, W, ACCESS
1107C  6F79     MOVWF multiplier, BANKED
1107E  5180     MOVF kc, W, BANKED
11080  0D07     MULLW 0x7
11082  0E02     MOVLW 0x2
11084  26F3     ADDWF PROD, F, ACCESS
11086  0E00     MOVLW 0x0
11088  22F4     ADDWFC PRODH, F, ACCESS
1108A  0E00     MOVLW 0x0
1108C  24F3     ADDWF PROD, W, ACCESS
1108E  6ED9     MOVWF FSR2, ACCESS
11090  0E01     MOVLW 0x1
11092  20F4     ADDWFC PRODH, W, ACCESS
11094  6EDA     MOVWF FSR2H, ACCESS
11096  50DF     MOVF INDF2, W, ACCESS
11098  1979     XORWF multiplier, W, BANKED
1109A  6F7A     MOVWF e, BANKED
1109C  0E0F     MOVLW 0xF
1109E  177A     ANDWF e, F, BANKED
110A0  A4D8     BTFSS STATUS, 2, ACCESS
110A2  D004     BRA 0x10AC
222:           				{
223:           					if (d != c)
110A4  5180     MOVF kc, W, BANKED
110A6  197F     XORWF d, W, BANKED
110A8  A4D8     BTFSS STATUS, 2, ACCESS
110AA  0012     RETURN 0
224:           					{
225:           						return; //Ghost
226:           					}
110AC  2B7F     INCF d, F, BANKED
110AE  D7D5     BRA 0x105A
227:           				}
228:           			}
229:           		}
230:           	}
231:           	if (sameCol && sameRow)
110B4  517B     MOVF kc, W, BANKED
110B6  B4D8     BTFSC STATUS, 2, ACCESS
110B8  D003     BRA 0x10C0
110BA  517C     MOVF sameRow, W, BANKED
110BC  A4D8     BTFSS STATUS, 2, ACCESS
110BE  0012     RETURN 0
232:           	{
233:           		return; //Ghost
234:           	}
235:           #endif
236:           	for (c = 0; c < N_PUSHABLE; c++)
110C0  0E00     MOVLW 0x0
110C2  6F80     MOVWF kc, BANKED
110C4  0E09     MOVLW 0x9
110C6  6580     CPFSGT kc, BANKED
110C8  D001     BRA 0x10CC
110CA  0012     RETURN 0
237:           	{
238:           		if (mSw[c].num == 0xff)
110CC  5180     MOVF kc, W, BANKED
110CE  0D07     MULLW 0x7
110D0  0E02     MOVLW 0x2
110D2  26F3     ADDWF PROD, F, ACCESS
110D4  0E00     MOVLW 0x0
110D6  22F4     ADDWFC PRODH, F, ACCESS
110D8  0E00     MOVLW 0x0
110DA  24F3     ADDWF PROD, W, ACCESS
110DC  6ED9     MOVWF FSR2, ACCESS
110DE  0E01     MOVLW 0x1
110E0  20F4     ADDWFC PRODH, W, ACCESS
110E2  6EDA     MOVWF FSR2H, ACCESS
110E4  28DE     INCF POSTINC2, W, ACCESS
110E6  A4D8     BTFSS STATUS, 2, ACCESS
110E8  D059     BRA 0x119C
239:           		{
240:           			mSw[c].num = n;
110EA  5180     MOVF kc, W, BANKED
110EC  0D07     MULLW 0x7
110EE  0E02     MOVLW 0x2
110F0  26F3     ADDWF PROD, F, ACCESS
110F2  0E00     MOVLW 0x0
110F4  22F4     ADDWFC PRODH, F, ACCESS
110F6  0E00     MOVLW 0x0
110F8  24F3     ADDWF PROD, W, ACCESS
110FA  6ED9     MOVWF FSR2, ACCESS
110FC  0E01     MOVLW 0x1
110FE  20F4     ADDWFC PRODH, W, ACCESS
11100  6EDA     MOVWF FSR2H, ACCESS
11102  C07D     MOVFF multiplicand, INDF2
11104  FFDF     NOP
241:           			mSw[c].count = 1;
11106  5180     MOVF kc, W, BANKED
11108  0D07     MULLW 0x7
1110A  0E00     MOVLW 0x0
1110C  24F3     ADDWF PROD, W, ACCESS
1110E  6ED9     MOVWF FSR2, ACCESS
11110  0E01     MOVLW 0x1
11112  20F4     ADDWFC PRODH, W, ACCESS
11114  6EDA     MOVWF FSR2H, ACCESS
11116  0E01     MOVLW 0x1
11118  6EDF     MOVWF INDF2, ACCESS
242:           			mSw[c].next = 0xff;
1111A  5180     MOVF kc, W, BANKED
1111C  0D07     MULLW 0x7
1111E  0E04     MOVLW 0x4
11120  26F3     ADDWF PROD, F, ACCESS
11122  0E00     MOVLW 0x0
11124  22F4     ADDWFC PRODH, F, ACCESS
11126  0E00     MOVLW 0x0
11128  24F3     ADDWF PROD, W, ACCESS
1112A  6ED9     MOVWF FSR2, ACCESS
1112C  0E01     MOVLW 0x1
1112E  20F4     ADDWFC PRODH, W, ACCESS
11130  6EDA     MOVWF FSR2H, ACCESS
11132  0EFF     MOVLW 0xFF
11134  6EDF     MOVWF INDF2, ACCESS
243:           			if (firstPush == 0xff)
11136  29DF     INCF firstPush, W, BANKED
11138  A4D8     BTFSS STATUS, 2, ACCESS
1113A  D011     BRA 0x115E
244:           			{
245:           				firstPush = c;
1113C  C080     MOVFF kc, firstPush
1113E  F0DF     NOP
246:           				mSw[c].pre = 0xff;
11140  5180     MOVF kc, W, BANKED
11142  0D07     MULLW 0x7
11144  0E03     MOVLW 0x3
11146  26F3     ADDWF PROD, F, ACCESS
11148  0E00     MOVLW 0x0
1114A  22F4     ADDWFC PRODH, F, ACCESS
1114C  0E00     MOVLW 0x0
1114E  24F3     ADDWF PROD, W, ACCESS
11150  6ED9     MOVWF FSR2, ACCESS
11152  0E01     MOVLW 0x1
11154  20F4     ADDWFC PRODH, W, ACCESS
11156  6EDA     MOVWF FSR2H, ACCESS
11158  0EFF     MOVLW 0xFF
1115A  6EDF     MOVWF INDF2, ACCESS
247:           			}
1115C  D01C     BRA 0x1196
248:           			else
249:           			{
250:           				mSw[lastPush].next = c;
1115E  51DE     MOVF lastPush, W, BANKED
11160  0D07     MULLW 0x7
11162  0E04     MOVLW 0x4
11164  26F3     ADDWF PROD, F, ACCESS
11166  0E00     MOVLW 0x0
11168  22F4     ADDWFC PRODH, F, ACCESS
1116A  0E00     MOVLW 0x0
1116C  24F3     ADDWF PROD, W, ACCESS
1116E  6ED9     MOVWF FSR2, ACCESS
11170  0E01     MOVLW 0x1
11172  20F4     ADDWFC PRODH, W, ACCESS
11174  6EDA     MOVWF FSR2H, ACCESS
11176  C080     MOVFF kc, INDF2
11178  FFDF     NOP
251:           				mSw[c].pre = lastPush;
1117A  5180     MOVF kc, W, BANKED
1117C  0D07     MULLW 0x7
1117E  0E03     MOVLW 0x3
11180  26F3     ADDWF PROD, F, ACCESS
11182  0E00     MOVLW 0x0
11184  22F4     ADDWFC PRODH, F, ACCESS
11186  0E00     MOVLW 0x0
11188  24F3     ADDWF PROD, W, ACCESS
1118A  6ED9     MOVWF FSR2, ACCESS
1118C  0E01     MOVLW 0x1
1118E  20F4     ADDWFC PRODH, W, ACCESS
11190  6EDA     MOVWF FSR2H, ACCESS
11192  C0DE     MOVFF lastPush, INDF2
11194  FFDF     NOP
252:           			}
253:           			lastPush = c;
11196  C080     MOVFF kc, lastPush
11198  F0DE     NOP
254:           			return;
1119A  0012     RETURN 0
255:           		}
1119C  2B80     INCF kc, F, BANKED
1119E  D792     BRA 0x10C4
256:           	}
257:           }
258:           
259:           void swProcess(void)
260:           {
261:           	unsigned char c;
262:           	unsigned char row;
263:           	//	unsigned char countOfPushing = 0;
264:           
265:           	LATC = 0x00;
10A38  0E00     MOVLW 0x0
10A3A  6E7B     MOVWF LATC, ACCESS
266:           	Nop();
10A3C  F000     NOP
267:           
268:           	if (swInput)
10A3E  0EFF     MOVLW 0xFF
10A40  0100     MOVLB 0x0
10A42  6F85     MOVWF b, BANKED
10A44  0E0F     MOVLW 0xF
10A46  6F86     MOVWF c, BANKED
10A48  508D     MOVF PORTE, W, ACCESS
10A4A  0D01     MULLW 0x1
10A4C  0E33     MOVLW 0x33
10A4E  24F3     ADDWF PROD, W, ACCESS
10A50  6EF6     MOVWF TBLPTR, ACCESS
10A52  0EF9     MOVLW 0xF9
10A54  20F4     ADDWFC PRODH, W, ACCESS
10A56  6EF7     MOVWF TBLPTRH, ACCESS
10A58  6AF8     CLRF TBLPTRU, ACCESS
10A5A  0E00     MOVLW 0x0
10A5C  22F8     ADDWFC TBLPTRU, F, ACCESS
10A5E  0008     TBLRD*
10A60  50F5     MOVF TABLAT, W, ACCESS
10A62  6F88     MOVWF t, BANKED
10A64  6B87     CLRF d, BANKED
10A66  508A     MOVF PORTB, W, ACCESS
10A68  0D01     MULLW 0x1
10A6A  0E33     MOVLW 0x33
10A6C  24F3     ADDWF PROD, W, ACCESS
10A6E  6EF6     MOVWF TBLPTR, ACCESS
10A70  0EF9     MOVLW 0xF9
10A72  20F4     ADDWFC PRODH, W, ACCESS
10A74  6EF7     MOVWF TBLPTRH, ACCESS
10A76  6AF8     CLRF TBLPTRU, ACCESS
10A78  0E00     MOVLW 0x0
10A7A  22F8     ADDWFC TBLPTRU, F, ACCESS
10A7C  0008     TBLRD*
10A7E  50F5     MOVF TABLAT, W, ACCESS
10A80  1387     IORWF d, F, BANKED
10A82  0E00     MOVLW 0x0
10A84  1388     IORWF t, F, BANKED
10A86  1D87     COMF d, W, BANKED
10A88  6F89     MOVWF 0x89, BANKED
10A8A  1D88     COMF t, W, BANKED
10A8C  6F8A     MOVWF 0x8A, BANKED
10A8E  5185     MOVF b, W, BANKED
10A90  1789     ANDWF 0x89, F, BANKED
10A92  5186     MOVF c, W, BANKED
10A94  178A     ANDWF 0x8A, F, BANKED
10A96  5189     MOVF 0x89, W, BANKED
10A98  118A     IORWF 0x8A, W, BANKED
10A9A  B4D8     BTFSC STATUS, 2, ACCESS
10A9C  D081     BRA 0xBA0
269:           	{
270:           		//switch(es) is(are) ON
271:           		for (row = 0; row < N_ROW; row++)
10A9E  0E00     MOVLW 0x0
10AA0  6F8E     MOVWF row, BANKED
10AA2  0E05     MOVLW 0x5
10AA4  658E     CPFSGT row, BANKED
10AA6  D001     BRA 0xAAA
10AA8  D051     BRA 0xB4C
10B48  2B8E     INCF row, F, BANKED
10B4A  D7AB     BRA 0xAA2
272:           		{
273:           			LATC = 0xff;
10AAA  687B     SETF LATC, ACCESS
274:           
275:           			TRISB &= ~PORTBMASK;
10AAC  0E00     MOVLW 0x0
10AAE  6E82     MOVWF TRISB, ACCESS
276:           			TRISE &= ~PORTEMASK;
10AB0  0E0F     MOVLW 0xF
10AB2  1685     ANDWF TRISE, F, ACCESS
277:           			TRISB |= PORTBMASK;
10AB4  6882     SETF TRISB, ACCESS
278:           			TRISE |= PORTEMASK;
10AB6  0EF0     MOVLW 0xF0
10AB8  1285     IORWF TRISE, F, ACCESS
279:           
280:           			LATC = rowTable[row];
10ABA  518E     MOVF row, W, BANKED
10ABC  0D01     MULLW 0x1
10ABE  0E5B     MOVLW 0x5B
10AC0  24F3     ADDWF PROD, W, ACCESS
10AC2  6EF6     MOVWF TBLPTR, ACCESS
10AC4  0EFB     MOVLW 0xFB
10AC6  20F4     ADDWFC PRODH, W, ACCESS
10AC8  6EF7     MOVWF TBLPTRH, ACCESS
10ACA  6AF8     CLRF TBLPTRU, ACCESS
10ACC  0E00     MOVLW 0x0
10ACE  22F8     ADDWFC TBLPTRU, F, ACCESS
10AD0  0008     TBLRD*
10AD2  CFF5     MOVFF TABLAT, LATC
10AD4  FF7B     NOP
281:           			Nop();
10AD6  F000     NOP
282:           			sw[row] = swInput;
10AD8  0EFF     MOVLW 0xFF
10ADA  0100     MOVLB 0x0
10ADC  6F85     MOVWF b, BANKED
10ADE  0E0F     MOVLW 0xF
10AE0  6F86     MOVWF c, BANKED
10AE2  508D     MOVF PORTE, W, ACCESS
10AE4  0D01     MULLW 0x1
10AE6  0E33     MOVLW 0x33
10AE8  24F3     ADDWF PROD, W, ACCESS
10AEA  6EF6     MOVWF TBLPTR, ACCESS
10AEC  0EF9     MOVLW 0xF9
10AEE  20F4     ADDWFC PRODH, W, ACCESS
10AF0  6EF7     MOVWF TBLPTRH, ACCESS
10AF2  6AF8     CLRF TBLPTRU, ACCESS
10AF4  0E00     MOVLW 0x0
10AF6  22F8     ADDWFC TBLPTRU, F, ACCESS
10AF8  0008     TBLRD*
10AFA  50F5     MOVF TABLAT, W, ACCESS
10AFC  6F88     MOVWF t, BANKED
10AFE  6B87     CLRF d, BANKED
10B00  508A     MOVF PORTB, W, ACCESS
10B02  0D01     MULLW 0x1
10B04  0E33     MOVLW 0x33
10B06  24F3     ADDWF PROD, W, ACCESS
10B08  6EF6     MOVWF TBLPTR, ACCESS
10B0A  0EF9     MOVLW 0xF9
10B0C  20F4     ADDWFC PRODH, W, ACCESS
10B0E  6EF7     MOVWF TBLPTRH, ACCESS
10B10  6AF8     CLRF TBLPTRU, ACCESS
10B12  0E00     MOVLW 0x0
10B14  22F8     ADDWFC TBLPTRU, F, ACCESS
10B16  0008     TBLRD*
10B18  50F5     MOVF TABLAT, W, ACCESS
10B1A  1387     IORWF d, F, BANKED
10B1C  0E00     MOVLW 0x0
10B1E  1388     IORWF t, F, BANKED
10B20  1D87     COMF d, W, BANKED
10B22  6F89     MOVWF 0x89, BANKED
10B24  1D88     COMF t, W, BANKED
10B26  6F8A     MOVWF 0x8A, BANKED
10B28  5185     MOVF b, W, BANKED
10B2A  1789     ANDWF 0x89, F, BANKED
10B2C  5186     MOVF c, W, BANKED
10B2E  178A     ANDWF 0x8A, F, BANKED
10B30  518E     MOVF row, W, BANKED
10B32  0D02     MULLW 0x2
10B34  0EA0     MOVLW 0xA0
10B36  24F3     ADDWF PROD, W, ACCESS
10B38  6ED9     MOVWF FSR2, ACCESS
10B3A  0E00     MOVLW 0x0
10B3C  20F4     ADDWFC PRODH, W, ACCESS
10B3E  6EDA     MOVWF FSR2H, ACCESS
10B40  C089     MOVFF 0x89, POSTINC2
10B42  FFDE     NOP
10B44  C08A     MOVFF 0x8A, POSTDEC2
10B46  FFDD     NOP
283:           		}
284:           
285:           		LATC = 0x00;
10B4C  0E00     MOVLW 0x0
10B4E  6E7B     MOVWF LATC, ACCESS
286:           		//		IOCBF = 0x00;
287:           		//		IOCEF = 0x00;
288:           
289:           		for (row = 0; row < N_ROW; row++)
10B50  0E00     MOVLW 0x0
10B52  6F8E     MOVWF row, BANKED
10B54  0E05     MOVLW 0x5
10B56  658E     CPFSGT row, BANKED
10B58  D001     BRA 0xB5C
10B5A  D036     BRA 0xBC8
10B9C  2B8E     INCF row, F, BANKED
10B9E  D7DA     BRA 0xB54
290:           		{
291:           			unsigned short sw2 = sw[row];
10B5C  518E     MOVF row, W, BANKED
10B5E  0D02     MULLW 0x2
10B60  0EA0     MOVLW 0xA0
10B62  24F3     ADDWF PROD, W, ACCESS
10B64  6ED9     MOVWF FSR2, ACCESS
10B66  0E00     MOVLW 0x0
10B68  20F4     ADDWFC PRODH, W, ACCESS
10B6A  6EDA     MOVWF FSR2H, ACCESS
10B6C  CFDE     MOVFF POSTINC2, sw2
10B6E  F08C     NOP
10B70  CFDD     MOVFF POSTDEC2, v
10B72  F08D     NOP
292:           			unsigned char col = 0;
10B74  0E00     MOVLW 0x0
10B76  6F8B     MOVWF col, BANKED
293:           			while (sw2)
10B78  D00D     BRA 0xB94
294:           			{
295:           				if (sw2 & 1)
10B7A  A18C     BTFSS sw2, 0, BANKED
10B7C  D006     BRA 0xB8A
296:           				{
297:           					swRegister(row * 16 + col);
10B7E  518E     MOVF row, W, BANKED
10B80  0D10     MULLW 0x10
10B82  50F3     MOVF PROD, W, ACCESS
10B84  258B     ADDWF col, W, BANKED
10B86  ECAF     CALL 0x10F5E, 0
10B88  F087     NOP
298:           				}
299:           				sw2 >>= 1;
10B8A  0100     MOVLB 0x0
10B8C  90D8     BCF STATUS, 0, ACCESS
10B8E  338D     RRCF v, F, BANKED
10B90  338C     RRCF sw2, F, BANKED
300:           				col++;
10B92  2B8B     INCF col, F, BANKED
301:           			}
10B94  518C     MOVF sw2, W, BANKED
10B96  118D     IORWF v, W, BANKED
10B98  A4D8     BTFSS STATUS, 2, ACCESS
10B9A  D7EF     BRA 0xB7A
302:           		}
303:           	}
304:           	else
305:           	{
306:           		//all switches are OFF
307:           		for (row = 0; row < N_ROW; row++)
10BA0  0E00     MOVLW 0x0
10BA2  6F8E     MOVWF row, BANKED
10BA4  0E05     MOVLW 0x5
10BA6  658E     CPFSGT row, BANKED
10BA8  D001     BRA 0xBAC
10BAA  D00E     BRA 0xBC8
10BC4  2B8E     INCF row, F, BANKED
10BC6  D7EE     BRA 0xBA4
308:           		{
309:           			sw[row] = 0x0000;
10BAC  518E     MOVF row, W, BANKED
10BAE  0D02     MULLW 0x2
10BB0  0EA0     MOVLW 0xA0
10BB2  24F3     ADDWF PROD, W, ACCESS
10BB4  6ED9     MOVWF FSR2, ACCESS
10BB6  0E00     MOVLW 0x0
10BB8  20F4     ADDWFC PRODH, W, ACCESS
10BBA  6EDA     MOVWF FSR2H, ACCESS
10BBC  0E00     MOVLW 0x0
10BBE  6EDE     MOVWF POSTINC2, ACCESS
10BC0  0E00     MOVLW 0x0
10BC2  6EDD     MOVWF POSTDEC2, ACCESS
310:           		}
311:           	}
312:           
313:           	for (c = 0; c < N_PUSHABLE; c++)
10BC8  0E00     MOVLW 0x0
10BCA  6F8F     MOVWF c, BANKED
10BCC  0E09     MOVLW 0x9
10BCE  658F     CPFSGT c, BANKED
10BD0  D001     BRA 0xBD4
10BD2  0012     RETURN 0
314:           	{
315:           		if (mSw[c].num != 0xff)
10BD4  518F     MOVF c, W, BANKED
10BD6  0D07     MULLW 0x7
10BD8  0E02     MOVLW 0x2
10BDA  26F3     ADDWF PROD, F, ACCESS
10BDC  0E00     MOVLW 0x0
10BDE  22F4     ADDWFC PRODH, F, ACCESS
10BE0  0E00     MOVLW 0x0
10BE2  24F3     ADDWF PROD, W, ACCESS
10BE4  6ED9     MOVWF FSR2, ACCESS
10BE6  0E01     MOVLW 0x1
10BE8  20F4     ADDWFC PRODH, W, ACCESS
10BEA  6EDA     MOVWF FSR2H, ACCESS
10BEC  28DE     INCF POSTINC2, W, ACCESS
10BEE  B4D8     BTFSC STATUS, 2, ACCESS
10BF0  D08A     BRA 0xD06
316:           		{
317:           			if ((sw[mSw[c].num >> 4] >> (mSw[c].num & 0x0f))& 1) //ON
10BF2  518F     MOVF c, W, BANKED
10BF4  0D07     MULLW 0x7
10BF6  0E02     MOVLW 0x2
10BF8  26F3     ADDWF PROD, F, ACCESS
10BFA  0E00     MOVLW 0x0
10BFC  22F4     ADDWFC PRODH, F, ACCESS
10BFE  0E00     MOVLW 0x0
10C00  24F3     ADDWF PROD, W, ACCESS
10C02  6ED9     MOVWF FSR2, ACCESS
10C04  0E01     MOVLW 0x1
10C06  20F4     ADDWFC PRODH, W, ACCESS
10C08  6EDA     MOVWF FSR2H, ACCESS
10C0A  50DF     MOVF INDF2, W, ACCESS
10C0C  6F85     MOVWF b, BANKED
10C0E  0E0F     MOVLW 0xF
10C10  1785     ANDWF b, F, BANKED
10C12  518F     MOVF c, W, BANKED
10C14  0D07     MULLW 0x7
10C16  0E02     MOVLW 0x2
10C18  26F3     ADDWF PROD, F, ACCESS
10C1A  0E00     MOVLW 0x0
10C1C  22F4     ADDWFC PRODH, F, ACCESS
10C1E  0E00     MOVLW 0x0
10C20  24F3     ADDWF PROD, W, ACCESS
10C22  6ED9     MOVWF FSR2, ACCESS
10C24  0E01     MOVLW 0x1
10C26  20F4     ADDWFC PRODH, W, ACCESS
10C28  6EDA     MOVWF FSR2H, ACCESS
10C2A  50DF     MOVF INDF2, W, ACCESS
10C2C  6F86     MOVWF c, BANKED
10C2E  3986     SWAPF c, W, BANKED
10C30  0B0F     ANDLW 0xF
10C32  6F87     MOVWF d, BANKED
10C34  6B88     CLRF t, BANKED
10C36  90D8     BCF STATUS, 0, ACCESS
10C38  3787     RLCF d, F, BANKED
10C3A  3788     RLCF t, F, BANKED
10C3C  0EA0     MOVLW 0xA0
10C3E  2587     ADDWF d, W, BANKED
10C40  6ED9     MOVWF FSR2, ACCESS
10C42  0E00     MOVLW 0x0
10C44  2188     ADDWFC t, W, BANKED
10C46  6EDA     MOVWF FSR2H, ACCESS
10C48  CFDE     MOVFF POSTINC2, 0x89
10C4A  F089     NOP
10C4C  CFDD     MOVFF POSTDEC2, 0x8A
10C4E  F08A     NOP
10C50  2B85     INCF b, F, BANKED
10C52  D003     BRA 0xC5A
10C54  90D8     BCF STATUS, 0, ACCESS
10C56  338A     RRCF 0x8A, F, BANKED
10C58  3389     RRCF 0x89, F, BANKED
10C5A  2F85     DECFSZ b, F, BANKED
10C5C  D7FB     BRA 0xC54
10C5E  0100     MOVLB 0x0
10C60  A189     BTFSS 0x89, 0, BANKED
10C62  D038     BRA 0xCD4
318:           			{
319:           				if (mSw[c].count == ON_COUNT)
10C64  518F     MOVF c, W, BANKED
10C66  0D07     MULLW 0x7
10C68  0E00     MOVLW 0x0
10C6A  24F3     ADDWF PROD, W, ACCESS
10C6C  6ED9     MOVWF FSR2, ACCESS
10C6E  0E01     MOVLW 0x1
10C70  20F4     ADDWFC PRODH, W, ACCESS
10C72  6EDA     MOVWF FSR2H, ACCESS
10C74  0E05     MOVLW 0x5
10C76  18DE     XORWF POSTINC2, W, ACCESS
10C78  A4D8     BTFSS STATUS, 2, ACCESS
10C7A  D021     BRA 0xCBE
320:           				{
321:           					if (!mSw[c].state)
10C7C  518F     MOVF c, W, BANKED
10C7E  0D07     MULLW 0x7
10C80  0E01     MOVLW 0x1
10C82  26F3     ADDWF PROD, F, ACCESS
10C84  0E00     MOVLW 0x0
10C86  22F4     ADDWFC PRODH, F, ACCESS
10C88  0E00     MOVLW 0x0
10C8A  24F3     ADDWF PROD, W, ACCESS
10C8C  6ED9     MOVWF FSR2, ACCESS
10C8E  0E01     MOVLW 0x1
10C90  20F4     ADDWFC PRODH, W, ACCESS
10C92  6EDA     MOVWF FSR2H, ACCESS
10C94  50DF     MOVF INDF2, W, ACCESS
10C96  A4D8     BTFSS STATUS, 2, ACCESS
10C98  D036     BRA 0xD06
322:           					{
323:           						mSw[c].state = 1;
10C9A  518F     MOVF c, W, BANKED
10C9C  0D07     MULLW 0x7
10C9E  0E01     MOVLW 0x1
10CA0  26F3     ADDWF PROD, F, ACCESS
10CA2  0E00     MOVLW 0x0
10CA4  22F4     ADDWFC PRODH, F, ACCESS
10CA6  0E00     MOVLW 0x0
10CA8  24F3     ADDWF PROD, W, ACCESS
10CAA  6ED9     MOVWF FSR2, ACCESS
10CAC  0E01     MOVLW 0x1
10CAE  20F4     ADDWFC PRODH, W, ACCESS
10CB0  6EDA     MOVWF FSR2H, ACCESS
10CB2  0E01     MOVLW 0x1
10CB4  6EDF     MOVWF INDF2, ACCESS
324:           						swPush(c);
10CB6  518F     MOVF c, W, BANKED
10CB8  ECF0     CALL 0x105E0, 0
10CBA  F082     NOP
325:           					}
326:           				}
10CBC  D024     BRA 0xD06
327:           				else
328:           				{
329:           					mSw[c].count++;
10CBE  0100     MOVLB 0x0
10CC0  518F     MOVF c, W, BANKED
10CC2  0D07     MULLW 0x7
10CC4  0E00     MOVLW 0x0
10CC6  24F3     ADDWF PROD, W, ACCESS
10CC8  6ED9     MOVWF FSR2, ACCESS
10CCA  0E01     MOVLW 0x1
10CCC  20F4     ADDWFC PRODH, W, ACCESS
10CCE  6EDA     MOVWF FSR2H, ACCESS
10CD0  2ADF     INCF INDF2, F, ACCESS
330:           				}
331:           			}
10CD2  D019     BRA 0xD06
332:           			else //OFF
333:           			{
334:           				if (mSw[c].count == 0)
10CD4  518F     MOVF c, W, BANKED
10CD6  0D07     MULLW 0x7
10CD8  0E00     MOVLW 0x0
10CDA  24F3     ADDWF PROD, W, ACCESS
10CDC  6ED9     MOVWF FSR2, ACCESS
10CDE  0E01     MOVLW 0x1
10CE0  20F4     ADDWFC PRODH, W, ACCESS
10CE2  6EDA     MOVWF FSR2H, ACCESS
10CE4  50DF     MOVF INDF2, W, ACCESS
10CE6  A4D8     BTFSS STATUS, 2, ACCESS
10CE8  D004     BRA 0xCF2
335:           				{
336:           					swUnregister(c);
10CEA  518F     MOVF c, W, BANKED
10CEC  ECE6     CALL 0x113CC, 0
10CEE  F089     NOP
337:           				}
10CF0  D00A     BRA 0xD06
338:           				else
339:           				{
340:           					mSw[c].count--;
10CF2  0100     MOVLB 0x0
10CF4  518F     MOVF c, W, BANKED
10CF6  0D07     MULLW 0x7
10CF8  0E00     MOVLW 0x0
10CFA  24F3     ADDWF PROD, W, ACCESS
10CFC  6ED9     MOVWF FSR2, ACCESS
10CFE  0E01     MOVLW 0x1
10D00  20F4     ADDWFC PRODH, W, ACCESS
10D02  6EDA     MOVWF FSR2H, ACCESS
10D04  06DF     DECF INDF2, F, ACCESS
341:           				}
10D06  0100     MOVLB 0x0
10D08  2B8F     INCF c, F, BANKED
10D0A  D760     BRA 0xBCC
342:           			}
343:           		}
344:           	}
345:           }
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/ringBuffer.c  -------------------------------
1:             #include <xc.h>
2:             #include "ringBuffer.h"
3:             #include "RN42.h"
4:             #include "FT230X.h"
5:             
6:             void bufWrite(struct ringBuf *b, unsigned char d)
7:             {
8:             	b->buffer[b->writeIndex++] = d;
120A8  0100     MOVLB 0x0
120AA  EE20     LFSR 2, 0x2
120AC  F002     NOP
120AE  5185     MOVF b, W, BANKED
120B0  26D9     ADDWF FSR2, F, ACCESS
120B2  5186     MOVF c, W, BANKED
120B4  22DA     ADDWFC FSR2H, F, ACCESS
120B6  50DF     MOVF INDF2, W, ACCESS
120B8  6F88     MOVWF t, BANKED
120BA  5188     MOVF t, W, BANKED
120BC  0D01     MULLW 0x1
120BE  C085     MOVFF b, FSR2
120C0  FFD9     NOP
120C2  C086     MOVFF c, FSR2H
120C4  FFDA     NOP
120C6  CFDE     MOVFF POSTINC2, 0x89
120C8  F089     NOP
120CA  CFDD     MOVFF POSTDEC2, 0x8A
120CC  F08A     NOP
120CE  50F3     MOVF PROD, W, ACCESS
120D0  2589     ADDWF 0x89, W, BANKED
120D2  6ED9     MOVWF FSR2, ACCESS
120D4  50F4     MOVF PRODH, W, ACCESS
120D6  218A     ADDWFC 0x8A, W, BANKED
120D8  6EDA     MOVWF FSR2H, ACCESS
120DA  C087     MOVFF d, INDF2
120DC  FFDF     NOP
120DE  EE20     LFSR 2, 0x2
120E0  F002     NOP
120E2  5185     MOVF b, W, BANKED
120E4  26D9     ADDWF FSR2, F, ACCESS
120E6  5186     MOVF c, W, BANKED
120E8  22DA     ADDWFC FSR2H, F, ACCESS
120EA  2ADF     INCF INDF2, F, ACCESS
9:             
10:            #ifndef BUF256
11:            	if (b->writeIndex == b->size)
12:            	{
13:            		b->writeIndex = 0;
14:            	}
15:            #endif
16:            	if (BT_Ready)PIE3bits.TX2IE = 1;
120EC  B48E     BTFSC PORTF, 2, ACCESS
120EE  D002     BRA 0x20F4
120F0  010E     MOVLB 0xE
120F2  8D2C     BSF 0x2C, 6, BANKED
17:            	if (USB_Host )//&& USB_Ready)
120F4  BC8E     BTFSC PORTF, 6, ACCESS
120F6  0012     RETURN 0
120F8  AE8E     BTFSS PORTF, 7, ACCESS
120FA  0012     RETURN 0
120FC  BA8E     BTFSC PORTF, 5, ACCESS
120FE  0012     RETURN 0
18:            		PIE4bits.TX5IE = 1;
12100  010E     MOVLB 0xE
12102  892D     BSF 0x2D, 4, BANKED
12104  0012     RETURN 0
19:            }
20:            
21:            void bufWriteIntH(struct ringBuf *b, unsigned char d)
22:            {
23:            	b->buffer[b->writeIndex++] = d;
12106  0100     MOVLB 0x0
12108  EE20     LFSR 2, 0x2
1210A  F002     NOP
1210C  5179     MOVF multiplier, W, BANKED
1210E  26D9     ADDWF FSR2, F, ACCESS
12110  517A     MOVF e, W, BANKED
12112  22DA     ADDWFC FSR2H, F, ACCESS
12114  50DF     MOVF INDF2, W, ACCESS
12116  6F7C     MOVWF sameRow, BANKED
12118  517C     MOVF sameRow, W, BANKED
1211A  0D01     MULLW 0x1
1211C  C079     MOVFF multiplier, FSR2
1211E  FFD9     NOP
12120  C07A     MOVFF e, FSR2H
12122  FFDA     NOP
12124  CFDE     MOVFF POSTINC2, multiplicand
12126  F07D     NOP
12128  CFDD     MOVFF POSTDEC2, c
1212A  F07E     NOP
1212C  50F3     MOVF PROD, W, ACCESS
1212E  257D     ADDWF multiplicand, W, BANKED
12130  6ED9     MOVWF FSR2, ACCESS
12132  50F4     MOVF PRODH, W, ACCESS
12134  217E     ADDWFC c, W, BANKED
12136  6EDA     MOVWF FSR2H, ACCESS
12138  C07B     MOVFF kc, INDF2
1213A  FFDF     NOP
1213C  EE20     LFSR 2, 0x2
1213E  F002     NOP
12140  5179     MOVF multiplier, W, BANKED
12142  26D9     ADDWF FSR2, F, ACCESS
12144  517A     MOVF e, W, BANKED
12146  22DA     ADDWFC FSR2H, F, ACCESS
12148  2ADF     INCF INDF2, F, ACCESS
12164  EE20     LFSR 2, 0x2
24:            
25:            #ifndef BUF256
26:            	if (b->writeIndex == b->size)
27:            	{
28:            		b->writeIndex = 0;
29:            	}
30:            #endif
31:            	if (BT_Ready)PIE3bits.TX2IE = 1;
1214A  B48E     BTFSC PORTF, 2, ACCESS
1214C  D002     BRA 0x2152
1214E  010E     MOVLB 0xE
12150  8D2C     BSF 0x2C, 6, BANKED
121A6  B48E     BTFSC PORTF, 2, ACCESS
121A8  D002     BRA 0x21AE
121AA  010E     MOVLB 0xE
121AC  8D2C     BSF 0x2C, 6, BANKED
32:            	if (USB_Host )//&& USB_Ready)
12152  BC8E     BTFSC PORTF, 6, ACCESS
12154  0012     RETURN 0
12156  AE8E     BTFSS PORTF, 7, ACCESS
12158  0012     RETURN 0
1215A  BA8E     BTFSC PORTF, 5, ACCESS
1215C  0012     RETURN 0
121AE  BC8E     BTFSC PORTF, 6, ACCESS
121B0  0012     RETURN 0
121B2  AE8E     BTFSS PORTF, 7, ACCESS
121B4  0012     RETURN 0
121B6  BA8E     BTFSC PORTF, 5, ACCESS
121B8  0012     RETURN 0
33:            		PIE4bits.TX5IE = 1;
1215E  010E     MOVLB 0xE
12160  892D     BSF 0x2D, 4, BANKED
12162  0012     RETURN 0
121BA  010E     MOVLB 0xE
121BC  892D     BSF 0x2D, 4, BANKED
121BE  0012     RETURN 0
34:            }
35:            
36:            unsigned char bufRead(struct ringBuf *b)
37:            {
38:            	unsigned char d;
39:            
40:            	d = b->buffer[b->readIndex++];
1230E  EE20     LFSR 2, 0x3
12310  F003     NOP
12312  503F     MOVF txData, W, ACCESS
12314  26D9     ADDWF FSR2, F, ACCESS
12316  5040     MOVF d, W, ACCESS
12318  22DA     ADDWFC FSR2H, F, ACCESS
1231A  50DF     MOVF INDF2, W, ACCESS
1231C  0100     MOVLB 0x0
1231E  6F60     MOVWF __pcstackBANK0, BANKED
12320  5160     MOVF __pcstackBANK0, W, BANKED
12322  0D01     MULLW 0x1
12324  C03F     MOVFF txData, FSR2
12326  FFD9     NOP
12328  C040     MOVFF d, FSR2H
1232A  FFDA     NOP
1232C  CFDE     MOVFF POSTINC2, 0x61
1232E  F061     NOP
12330  CFDD     MOVFF POSTDEC2, 0x62
12332  F062     NOP
12334  50F3     MOVF PROD, W, ACCESS
12336  2561     ADDWF 0x61, W, BANKED
12338  6ED9     MOVWF FSR2, ACCESS
1233A  50F4     MOVF PRODH, W, ACCESS
1233C  2162     ADDWFC 0x62, W, BANKED
1233E  6EDA     MOVWF FSR2H, ACCESS
12340  50DF     MOVF INDF2, W, ACCESS
12342  6F63     MOVWF d, BANKED
12344  EE20     LFSR 2, 0x3
12346  F003     NOP
12348  503F     MOVF txData, W, ACCESS
1234A  26D9     ADDWF FSR2, F, ACCESS
1234C  5040     MOVF d, W, ACCESS
1234E  22DA     ADDWFC FSR2H, F, ACCESS
12350  2ADF     INCF INDF2, F, ACCESS
41:            
42:            #ifndef BUF256
43:            	if (b->readIndex == b->size)
44:            	{
45:            		b->readIndex = 0;
46:            	}
47:            #endif
48:            	return d;
12352  5163     MOVF d, W, BANKED
12354  0012     RETURN 0
49:            }
50:            
51:            //unsigned char bufDataExist(struct ringBuf *b) {
52:            //	return (unsigned char)(b->writeIndex != b->readIndex);
53:            //}
54:            
55:            void bufClear(struct ringBuf *b)
56:            {
57:            	b->readIndex != b->writeIndex;
58:            }
127CA  0012     RETURN 0
59:            
60:            #ifdef BUF256
61:            void bufInit(struct ringBuf *b, unsigned char *buf)
62:            #else
63:            void bufInit(struct ringBuf *b, unsigned char *buf, unsigned char size)
64:            #endif
65:            {
66:            	b->buffer = buf;
1259A  C079     MOVFF multiplier, FSR2
1259C  FFD9     NOP
1259E  C07A     MOVFF e, FSR2H
125A0  FFDA     NOP
125A2  C07B     MOVFF kc, POSTINC2
125A4  FFDE     NOP
125A6  C07C     MOVFF sameRow, POSTDEC2
125A8  FFDD     NOP
67:            	b->writeIndex = 0;
125AA  0100     MOVLB 0x0
125AC  EE20     LFSR 2, 0x2
125AE  F002     NOP
125B0  5179     MOVF multiplier, W, BANKED
125B2  26D9     ADDWF FSR2, F, ACCESS
125B4  517A     MOVF e, W, BANKED
125B6  22DA     ADDWFC FSR2H, F, ACCESS
125B8  0E00     MOVLW 0x0
125BA  6EDF     MOVWF INDF2, ACCESS
68:            	b->readIndex = 0;
125BC  EE20     LFSR 2, 0x3
125BE  F003     NOP
125C0  5179     MOVF multiplier, W, BANKED
125C2  26D9     ADDWF FSR2, F, ACCESS
125C4  517A     MOVF e, W, BANKED
125C6  22DA     ADDWFC FSR2H, F, ACCESS
125C8  0E00     MOVLW 0x0
125CA  6EDF     MOVWF INDF2, ACCESS
69:            #ifndef BUF256
70:            	b->size = size;
71:            #endif
72:            }
125CC  0012     RETURN 0
73:            
74:            
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/main.c  -------------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             #include <xc.h>        /* XC8 General Include File */
5:             
6:             #include <stdint.h>        /* For uint8_t definition */
7:             #include <stdbool.h>       /* For true/false definition */
8:             
9:             #include "system.h"        /* System funct/params, like osc/peripheral config */
10:            #include "user.h"          /* User funct/params, such as InitApp */
11:            #include "eusart2.h"
12:            #include "eusart5.h"
13:            #include "adcc.h"
14:            #include "RN42.h"
15:            #include "FT230X.h"
16:            #include "main.h"
17:            #include "keys.h"
18:            #include "swMatrix.h"
19:            #include "ringBuffer.h"
20:            #include "EEPROM.h"
21:            
22:            
23:            /******************************************************************************/
24:            /* User Global Variable Declaration                                           */
25:            /******************************************************************************/
26:            unsigned short volt = 65535;
27:            unsigned long time = 0;
28:            unsigned char sawToothWave = 0;
29:            
30:            //unsigned char sw1Flag = 0;
31:            //unsigned char sw1FlagLong = 0;
32:            
33:            //unsigned char FlagU2Send = 0;
34:            //unsigned char FlagU5Send = 0;
35:            //unsigned char FlagCheckSwMatrix = 0;
36:            
37:            //unsigned char FlagShowBatteryState = 0;
38:            
39:            union MainFlags mainFlags;
40:            
41:            struct ringBuf bufU2_intH;
42:            //struct ringBuf bufU2_intL;
43:            struct ringBuf bufU2_main;
44:            struct ringBuf bufU5_intH;
45:            //struct ringBuf bufU5_intL;
46:            struct ringBuf bufU5_main;
47:            
48:            unsigned char b1[256];
49:            //unsigned char b2[256];
50:            unsigned char b3[256];
51:            unsigned char b4[256];
52:            //unsigned char b5[256];
53:            unsigned char b6[256];
54:            
55:            /******************************************************************************/
56:            /* Main Program                                                               */
57:            
58:            /******************************************************************************/
59:            void main(void)
60:            {
61:            	/* Configure the oscillator for the device */
62:            
63:            	/* Initialize I/O and Peripherals for application */
64:            	InitApp();
10000  EC86     CALL 0x1270C, 0
10002  F093     NOP
65:            	waitBootTrigger();
10004  EC93     CALL 0x12526, 0
10006  F092     NOP
66:            	InitApp2();
10008  EC03     CALL 0x11E06, 0
1000A  F08F     NOP
67:            
68:            	bufInit(&bufU2_intH, b1);
1000C  0E19     MOVLW 0x19
1000E  0100     MOVLB 0x0
10010  6F79     MOVWF multiplier, BANKED
10012  0E00     MOVLW 0x0
10014  6F7A     MOVWF e, BANKED
10016  0E00     MOVLW 0x0
10018  6F7B     MOVWF kc, BANKED
1001A  0E02     MOVLW 0x2
1001C  6F7C     MOVWF sameRow, BANKED
1001E  ECCD     CALL 0x1259A, 0
10020  F092     NOP
69:            	//	bufInit(&bufU2_intL, b2, sizeof (b2));
70:            	bufInit(&bufU2_main, b3);
10022  0E15     MOVLW 0x15
10024  0100     MOVLB 0x0
10026  6F79     MOVWF multiplier, BANKED
10028  0E00     MOVLW 0x0
1002A  6F7A     MOVWF e, BANKED
1002C  0E00     MOVLW 0x0
1002E  6F7B     MOVWF kc, BANKED
10030  0E03     MOVLW 0x3
10032  6F7C     MOVWF sameRow, BANKED
10034  ECCD     CALL 0x1259A, 0
10036  F092     NOP
71:            	bufInit(&bufU5_intH, b4);
10038  0E1D     MOVLW 0x1D
1003A  0100     MOVLB 0x0
1003C  6F79     MOVWF multiplier, BANKED
1003E  0E00     MOVLW 0x0
10040  6F7A     MOVWF e, BANKED
10042  0E00     MOVLW 0x0
10044  6F7B     MOVWF kc, BANKED
10046  0E04     MOVLW 0x4
10048  6F7C     MOVWF sameRow, BANKED
1004A  ECCD     CALL 0x1259A, 0
1004C  F092     NOP
72:            	//	bufInit(&bufU5_intL, b5, sizeof (b5));
73:            	bufInit(&bufU5_main, b6);
1004E  0E11     MOVLW 0x11
10050  0100     MOVLB 0x0
10052  6F79     MOVWF multiplier, BANKED
10054  0E00     MOVLW 0x0
10056  6F7A     MOVWF e, BANKED
10058  0E00     MOVLW 0x0
1005A  6F7B     MOVWF kc, BANKED
1005C  0E05     MOVLW 0x5
1005E  6F7C     MOVWF sameRow, BANKED
10060  ECCD     CALL 0x1259A, 0
10062  F092     NOP
74:            
75:            	keyMode = ReadEEPROM(0);
10064  0E00     MOVLW 0x0
10066  0100     MOVLB 0x0
10068  6F7A     MOVWF e, BANKED
1006A  0E00     MOVLW 0x0
1006C  6F79     MOVWF multiplier, BANKED
1006E  ECB2     CALL 0x12564, 0
10070  F092     NOP
10072  0100     MOVLB 0x0
10074  6FCD     MOVWF keyMode, BANKED
76:            	if (keyMode == 0xff)
10076  29CD     INCF keyMode, W, BANKED
10078  A4D8     BTFSS STATUS, 2, ACCESS
1007A  D002     BRA 0x80
77:            	{
78:            		keyMode = 0;
1007C  0E00     MOVLW 0x0
1007E  6FCD     MOVWF keyMode, BANKED
79:            	}
80:            
81:            #ifdef MICRO_QWERTY
82:            	fnEnableLatch = ReadEEPROM(1);
10080  0E00     MOVLW 0x0
10082  6F7A     MOVWF e, BANKED
10084  0E01     MOVLW 0x1
10086  6F79     MOVWF multiplier, BANKED
10088  ECB2     CALL 0x12564, 0
1008A  F092     NOP
1008C  0100     MOVLB 0x0
1008E  6FCC     MOVWF fnEnableLatch, BANKED
83:            	if (fnEnableLatch > 1)
10090  0E01     MOVLW 0x1
10092  65CC     CPFSGT fnEnableLatch, BANKED
10094  D002     BRA 0x9A
84:            	{
85:            		fnEnableLatch = 0;
10096  0E00     MOVLW 0x0
10098  6FCC     MOVWF fnEnableLatch, BANKED
86:            	}
87:            #endif
88:            
89:            	setSleepDelay(300);
1009A  0E01     MOVLW 0x1
1009C  6F86     MOVWF c, BANKED
1009E  0E2C     MOVLW 0x2C
100A0  6F85     MOVWF b, BANKED
100A2  ECEA     CALL 0x11FD4, 0
100A4  F08F     NOP
90:            	INTCONbits.GIE = 1;
100A6  8EF2     BSF INTCON, 7, ACCESS
91:            	//	mainFlags.connect = 1;
92:            	connect();
100A8  EC47     CALL 0x1268E, 0
100AA  F093     NOP
93:            
94:            	for (unsigned char c = 0; c < LEDNUM; c++)
100AC  0E00     MOVLW 0x0
100AE  0100     MOVLB 0x0
100B0  6F9B     MOVWF c, BANKED
100B2  0E0B     MOVLW 0xB
100B4  659B     CPFSGT c, BANKED
100B6  D001     BRA 0xBA
100B8  D00C     BRA 0xD2
100CE  2B9B     INCF c, F, BANKED
100D0  D7F0     BRA 0xB2
95:            	{
96:            		led[c] = 0;
100BA  519B     MOVF c, W, BANKED
100BC  0D01     MULLW 0x1
100BE  0EAC     MOVLW 0xAC
100C0  24F3     ADDWF PROD, W, ACCESS
100C2  6ED9     MOVWF FSR2, ACCESS
100C4  0E00     MOVLW 0x0
100C6  20F4     ADDWFC PRODH, W, ACCESS
100C8  6EDA     MOVWF FSR2H, ACCESS
100CA  0E00     MOVLW 0x0
100CC  6EDF     MOVWF INDF2, ACCESS
97:            	}
98:            	waitMs(200);
100D2  0EC8     MOVLW 0xC8
100D4  6F79     MOVWF multiplier, BANKED
100D6  0E00     MOVLW 0x0
100D8  6F7A     MOVWF e, BANKED
100DA  0E00     MOVLW 0x0
100DC  6F7B     MOVWF kc, BANKED
100DE  0E00     MOVLW 0x0
100E0  6F7C     MOVWF sameRow, BANKED
100E2  EC11     CALL 0x12422, 0
100E4  F092     NOP
99:            	for (unsigned char c = 0; c < LEDNUM; c++)
100E6  0E00     MOVLW 0x0
100E8  0100     MOVLB 0x0
100EA  6F9C     MOVWF c, BANKED
100EC  0E0B     MOVLW 0xB
100EE  659C     CPFSGT c, BANKED
100F0  D001     BRA 0xF4
100F2  D017     BRA 0x122
1011C  0100     MOVLB 0x0
1011E  2B9C     INCF c, F, BANKED
10120  D7E5     BRA 0xEC
100:           	{
101:           		led[c] = 1;
100F4  519C     MOVF c, W, BANKED
100F6  0D01     MULLW 0x1
100F8  0EAC     MOVLW 0xAC
100FA  24F3     ADDWF PROD, W, ACCESS
100FC  6ED9     MOVWF FSR2, ACCESS
100FE  0E00     MOVLW 0x0
10100  20F4     ADDWFC PRODH, W, ACCESS
10102  6EDA     MOVWF FSR2H, ACCESS
10104  0E01     MOVLW 0x1
10106  6EDF     MOVWF INDF2, ACCESS
102:           		waitMs(100);
10108  0E64     MOVLW 0x64
1010A  6F79     MOVWF multiplier, BANKED
1010C  0E00     MOVLW 0x0
1010E  6F7A     MOVWF e, BANKED
10110  0E00     MOVLW 0x0
10112  6F7B     MOVWF kc, BANKED
10114  0E00     MOVLW 0x0
10116  6F7C     MOVWF sameRow, BANKED
10118  EC11     CALL 0x12422, 0
1011A  F092     NOP
103:           	}
104:           	waitMs(200);
10122  0EC8     MOVLW 0xC8
10124  6F79     MOVWF multiplier, BANKED
10126  0E00     MOVLW 0x0
10128  6F7A     MOVWF e, BANKED
1012A  0E00     MOVLW 0x0
1012C  6F7B     MOVWF kc, BANKED
1012E  0E00     MOVLW 0x0
10130  6F7C     MOVWF sameRow, BANKED
10132  EC11     CALL 0x12422, 0
10134  F092     NOP
105:           	for (unsigned char c = 0; c < LEDNUM; c++)
10136  0E00     MOVLW 0x0
10138  0100     MOVLB 0x0
1013A  6F9D     MOVWF c, BANKED
1013C  0E0B     MOVLW 0xB
1013E  659D     CPFSGT c, BANKED
10140  D001     BRA 0x144
10142  D017     BRA 0x172
1016C  0100     MOVLB 0x0
1016E  2B9D     INCF c, F, BANKED
10170  D7E5     BRA 0x13C
106:           	{
107:           		led[c] = 0;
10144  519D     MOVF c, W, BANKED
10146  0D01     MULLW 0x1
10148  0EAC     MOVLW 0xAC
1014A  24F3     ADDWF PROD, W, ACCESS
1014C  6ED9     MOVWF FSR2, ACCESS
1014E  0E00     MOVLW 0x0
10150  20F4     ADDWFC PRODH, W, ACCESS
10152  6EDA     MOVWF FSR2H, ACCESS
10154  0E00     MOVLW 0x0
10156  6EDF     MOVWF INDF2, ACCESS
108:           		waitMs(10);
10158  0E0A     MOVLW 0xA
1015A  6F79     MOVWF multiplier, BANKED
1015C  0E00     MOVLW 0x0
1015E  6F7A     MOVWF e, BANKED
10160  0E00     MOVLW 0x0
10162  6F7B     MOVWF kc, BANKED
10164  0E00     MOVLW 0x0
10166  6F7C     MOVWF sameRow, BANKED
10168  EC11     CALL 0x12422, 0
1016A  F092     NOP
109:           	}
110:           	waitMs(20);
10172  0E14     MOVLW 0x14
10174  6F79     MOVWF multiplier, BANKED
10176  0E00     MOVLW 0x0
10178  6F7A     MOVWF e, BANKED
1017A  0E00     MOVLW 0x0
1017C  6F7B     MOVWF kc, BANKED
1017E  0E00     MOVLW 0x0
10180  6F7C     MOVWF sameRow, BANKED
10182  EC11     CALL 0x12422, 0
10184  F092     NOP
111:           	showText("Hello!!!!!!");
10186  0EED     MOVLW 0xED
10188  0100     MOVLB 0x0
1018A  6F8B     MOVWF col, BANKED
1018C  0EFF     MOVLW 0xFF
1018E  6F8C     MOVWF sw2, BANKED
10190  EC53     CALL 0x124A6, 0
10192  F092     NOP
112:           	WriteEEPROM(2, 0x55);
10194  0E00     MOVLW 0x0
10196  0100     MOVLB 0x0
10198  6F7A     MOVWF e, BANKED
1019A  0E02     MOVLW 0x2
1019C  6F79     MOVWF multiplier, BANKED
1019E  0E55     MOVLW 0x55
101A0  6F7B     MOVWF kc, BANKED
101A2  ECEF     CALL 0x123DE, 0
101A4  F091     NOP
113:           	showHex2(ReadEEPROM(2));
101A6  0E00     MOVLW 0x0
101A8  0100     MOVLB 0x0
101AA  6F7A     MOVWF e, BANKED
101AC  0E02     MOVLW 0x2
101AE  6F79     MOVWF multiplier, BANKED
101B0  ECB2     CALL 0x12564, 0
101B2  F092     NOP
101B4  ECFE     CALL 0x119FC, 0
101B6  F08C     NOP
114:           	WriteEEPROM(3, 0xff);
101B8  0E00     MOVLW 0x0
101BA  0100     MOVLB 0x0
101BC  6F7A     MOVWF e, BANKED
101BE  0E03     MOVLW 0x3
101C0  6F79     MOVWF multiplier, BANKED
101C2  0EFF     MOVLW 0xFF
101C4  6F7B     MOVWF kc, BANKED
101C6  ECEF     CALL 0x123DE, 0
101C8  F091     NOP
115:           	showHex2(ReadEEPROM(3));
101CA  0E00     MOVLW 0x0
101CC  0100     MOVLB 0x0
101CE  6F7A     MOVWF e, BANKED
101D0  0E03     MOVLW 0x3
101D2  6F79     MOVWF multiplier, BANKED
101D4  ECB2     CALL 0x12564, 0
101D6  F092     NOP
101D8  ECFE     CALL 0x119FC, 0
101DA  F08C     NOP
116:           	WriteEEPROM(4, 0x00);
101DC  0E00     MOVLW 0x0
101DE  0100     MOVLB 0x0
101E0  6F7A     MOVWF e, BANKED
101E2  0E04     MOVLW 0x4
101E4  6F79     MOVWF multiplier, BANKED
101E6  0E00     MOVLW 0x0
101E8  6F7B     MOVWF kc, BANKED
101EA  ECEF     CALL 0x123DE, 0
101EC  F091     NOP
117:           	showHex2(ReadEEPROM(4));
101EE  0E00     MOVLW 0x0
101F0  0100     MOVLB 0x0
101F2  6F7A     MOVWF e, BANKED
101F4  0E04     MOVLW 0x4
101F6  6F79     MOVWF multiplier, BANKED
101F8  ECB2     CALL 0x12564, 0
101FA  F092     NOP
101FC  ECFE     CALL 0x119FC, 0
101FE  F08C     NOP
118:           	showHex2(ReadEEPROM(5));
10200  0E00     MOVLW 0x0
10202  0100     MOVLB 0x0
10204  6F7A     MOVWF e, BANKED
10206  0E05     MOVLW 0x5
10208  6F79     MOVWF multiplier, BANKED
1020A  ECB2     CALL 0x12564, 0
1020C  F092     NOP
1020E  ECFE     CALL 0x119FC, 0
10210  F08C     NOP
119:           	mainFlags.cycle33s = 1;
10212  8E0B     BSF mainFlags, 7, ACCESS
120:           
121:           	while (1)
105DE  D61A     BRA 0x214
122:           	{
123:           		LED1 = BT_GPIO5;
10214  A28E     BTFSS PORTF, 1, ACCESS
10216  D002     BRA 0x21C
10218  8E8C     BSF PORTD, 7, ACCESS
1021A  D001     BRA 0x21E
1021C  9E8C     BCF PORTD, 7, ACCESS
124:           
125:           #ifdef MICRO_QWERTY
126:           		led[LED_FNL] = led[LED_FNR] = fnEnable | fnEnableLatch;
1021E  0100     MOVLB 0x0
10220  51CB     MOVF fnEnable, W, BANKED
10222  11CC     IORWF fnEnableLatch, W, BANKED
10224  6FB0     MOVWF 0xB0, BANKED
10226  C0B0     MOVFF 0xB0, 0xAF
10228  F0AF     NOP
127:           		led[LED_ALT] = keyReport.modifierLatch.bits.AltL | keyReport.modifier.bits.AltL | keyReport.modifier2.bits.AltL;
1022A  A5BA     BTFSS 0xBA, 2, BANKED
1022C  D003     BRA 0x234
1022E  6B91     CLRF 0x91, BANKED
10230  2B91     INCF 0x91, F, BANKED
10232  D002     BRA 0x238
10234  0100     MOVLB 0x0
10236  6B91     CLRF 0x91, BANKED
10238  A5B9     BTFSS 0xB9, 2, BANKED
1023A  D003     BRA 0x242
1023C  6B92     CLRF 0x92, BANKED
1023E  2B92     INCF 0x92, F, BANKED
10240  D002     BRA 0x246
10242  0100     MOVLB 0x0
10244  6B92     CLRF 0x92, BANKED
10246  A5B8     BTFSS keyReport, 2, BANKED
10248  D002     BRA 0x24E
1024A  0E01     MOVLW 0x1
1024C  D001     BRA 0x250
1024E  0E00     MOVLW 0x0
10250  1192     IORWF 0x92, W, BANKED
10252  1191     IORWF 0x91, W, BANKED
10254  6FB2     MOVWF 0xB2, BANKED
128:           		led[LED_GUI] = keyReport.modifierLatch.bits.GuiL | keyReport.modifier.bits.GuiL | keyReport.modifier2.bits.GuiL;
10256  A7BA     BTFSS 0xBA, 3, BANKED
10258  D003     BRA 0x260
1025A  6B91     CLRF 0x91, BANKED
1025C  2B91     INCF 0x91, F, BANKED
1025E  D002     BRA 0x264
10260  0100     MOVLB 0x0
10262  6B91     CLRF 0x91, BANKED
10264  A7B9     BTFSS 0xB9, 3, BANKED
10266  D003     BRA 0x26E
10268  6B92     CLRF 0x92, BANKED
1026A  2B92     INCF 0x92, F, BANKED
1026C  D002     BRA 0x272
1026E  0100     MOVLB 0x0
10270  6B92     CLRF 0x92, BANKED
10272  A7B8     BTFSS keyReport, 3, BANKED
10274  D002     BRA 0x27A
10276  0E01     MOVLW 0x1
10278  D001     BRA 0x27C
1027A  0E00     MOVLW 0x0
1027C  1192     IORWF 0x92, W, BANKED
1027E  1191     IORWF 0x91, W, BANKED
10280  6FB3     MOVWF 0xB3, BANKED
129:           		led[LED_CTL] = keyReport.modifierLatch.bits.CtrlL | keyReport.modifier.bits.CtrlL | keyReport.modifier2.bits.CtrlL;
10282  A1BA     BTFSS 0xBA, 0, BANKED
10284  D003     BRA 0x28C
10286  6B91     CLRF 0x91, BANKED
10288  2B91     INCF 0x91, F, BANKED
1028A  D002     BRA 0x290
1028C  0100     MOVLB 0x0
1028E  6B91     CLRF 0x91, BANKED
10290  A1B9     BTFSS 0xB9, 0, BANKED
10292  D003     BRA 0x29A
10294  6B92     CLRF 0x92, BANKED
10296  2B92     INCF 0x92, F, BANKED
10298  D002     BRA 0x29E
1029A  0100     MOVLB 0x0
1029C  6B92     CLRF 0x92, BANKED
1029E  A1B8     BTFSS keyReport, 0, BANKED
102A0  D002     BRA 0x2A6
102A2  0E01     MOVLW 0x1
102A4  D001     BRA 0x2A8
102A6  0E00     MOVLW 0x0
102A8  1192     IORWF 0x92, W, BANKED
102AA  1191     IORWF 0x91, W, BANKED
102AC  6FB1     MOVWF 0xB1, BANKED
130:           		led[LED_SHL] = led[LED_SHR] = keyReport.modifierLatch.bits.ShiftL | keyReport.modifierLatch.bits.ShiftR | keyReport.modifier.bits.ShiftL | keyReport.modifier.bits.ShiftR | keyReport.modifier2.bits.ShiftL | keyReport.modifier2.bits.ShiftR;
102AE  ABBA     BTFSS 0xBA, 5, BANKED
102B0  D003     BRA 0x2B8
102B2  6B91     CLRF 0x91, BANKED
102B4  2B91     INCF 0x91, F, BANKED
102B6  D002     BRA 0x2BC
102B8  0100     MOVLB 0x0
102BA  6B91     CLRF 0x91, BANKED
102BC  A3BA     BTFSS 0xBA, 1, BANKED
102BE  D003     BRA 0x2C6
102C0  6B92     CLRF 0x92, BANKED
102C2  2B92     INCF 0x92, F, BANKED
102C4  D002     BRA 0x2CA
102C6  0100     MOVLB 0x0
102C8  6B92     CLRF 0x92, BANKED
102CA  ABB9     BTFSS 0xB9, 5, BANKED
102CC  D003     BRA 0x2D4
102CE  6B93     CLRF 0x93, BANKED
102D0  2B93     INCF 0x93, F, BANKED
102D2  D002     BRA 0x2D8
102D4  0100     MOVLB 0x0
102D6  6B93     CLRF 0x93, BANKED
102D8  A3B9     BTFSS 0xB9, 1, BANKED
102DA  D003     BRA 0x2E2
102DC  6B94     CLRF 0x94, BANKED
102DE  2B94     INCF 0x94, F, BANKED
102E0  D002     BRA 0x2E6
102E2  0100     MOVLB 0x0
102E4  6B94     CLRF 0x94, BANKED
102E6  ABB8     BTFSS keyReport, 5, BANKED
102E8  D003     BRA 0x2F0
102EA  6B95     CLRF 0x95, BANKED
102EC  2B95     INCF 0x95, F, BANKED
102EE  D002     BRA 0x2F4
102F0  0100     MOVLB 0x0
102F2  6B95     CLRF 0x95, BANKED
102F4  A3B8     BTFSS keyReport, 1, BANKED
102F6  D002     BRA 0x2FC
102F8  0E01     MOVLW 0x1
102FA  D001     BRA 0x2FE
102FC  0E00     MOVLW 0x0
102FE  1195     IORWF 0x95, W, BANKED
10300  1194     IORWF 0x94, W, BANKED
10302  1193     IORWF 0x93, W, BANKED
10304  1192     IORWF 0x92, W, BANKED
10306  1191     IORWF 0x91, W, BANKED
10308  6FB5     MOVWF 0xB5, BANKED
1030A  C0B5     MOVFF 0xB5, 0xB4
1030C  F0B4     NOP
131:           		led[LED_M1] = keyMode == 0 && BtConnected ^ BT_GPIO5;
1030E  0E00     MOVLW 0x0
10310  6F97     MOVWF 0x97, BANKED
10312  51CD     MOVF keyMode, W, BANKED
10314  A4D8     BTFSS STATUS, 2, ACCESS
10316  D011     BRA 0x33A
10318  A28E     BTFSS PORTF, 1, ACCESS
1031A  D002     BRA 0x320
1031C  0E01     MOVLW 0x1
1031E  D001     BRA 0x322
10320  0E00     MOVLW 0x0
10322  C0CA     MOVFF BtConnected, 0x91
10324  F091     NOP
10326  6B92     CLRF 0x92, BANKED
10328  1B91     XORWF 0x91, F, BANKED
1032A  0E00     MOVLW 0x0
1032C  1B92     XORWF 0x92, F, BANKED
1032E  5191     MOVF 0x91, W, BANKED
10330  1192     IORWF 0x92, W, BANKED
10332  B4D8     BTFSC STATUS, 2, ACCESS
10334  D002     BRA 0x33A
10336  0E01     MOVLW 0x1
10338  6F97     MOVWF 0x97, BANKED
1033A  C097     MOVFF 0x97, led
1033C  F0AC     NOP
132:           		led[LED_M2] = keyMode == 1 && BtConnected ^ BT_GPIO5;
1033E  0E00     MOVLW 0x0
10340  6F98     MOVWF 0x98, BANKED
10342  05CD     DECF keyMode, W, BANKED
10344  A4D8     BTFSS STATUS, 2, ACCESS
10346  D011     BRA 0x36A
10348  A28E     BTFSS PORTF, 1, ACCESS
1034A  D002     BRA 0x350
1034C  0E01     MOVLW 0x1
1034E  D001     BRA 0x352
10350  0E00     MOVLW 0x0
10352  C0CA     MOVFF BtConnected, 0x91
10354  F091     NOP
10356  6B92     CLRF 0x92, BANKED
10358  1B91     XORWF 0x91, F, BANKED
1035A  0E00     MOVLW 0x0
1035C  1B92     XORWF 0x92, F, BANKED
1035E  5191     MOVF 0x91, W, BANKED
10360  1192     IORWF 0x92, W, BANKED
10362  B4D8     BTFSC STATUS, 2, ACCESS
10364  D002     BRA 0x36A
10366  0E01     MOVLW 0x1
10368  6F98     MOVWF 0x98, BANKED
1036A  C098     MOVFF 0x98, 0xAD
1036C  F0AD     NOP
133:           		led[LED_M3] = keyMode == 2 && BtConnected ^ BT_GPIO5;
1036E  0E00     MOVLW 0x0
10370  6F99     MOVWF 0x99, BANKED
10372  0E02     MOVLW 0x2
10374  19CD     XORWF keyMode, W, BANKED
10376  A4D8     BTFSS STATUS, 2, ACCESS
10378  D011     BRA 0x39C
1037A  A28E     BTFSS PORTF, 1, ACCESS
1037C  D002     BRA 0x382
1037E  0E01     MOVLW 0x1
10380  D001     BRA 0x384
10382  0E00     MOVLW 0x0
10384  C0CA     MOVFF BtConnected, 0x91
10386  F091     NOP
10388  6B92     CLRF 0x92, BANKED
1038A  1B91     XORWF 0x91, F, BANKED
1038C  0E00     MOVLW 0x0
1038E  1B92     XORWF 0x92, F, BANKED
10390  5191     MOVF 0x91, W, BANKED
10392  1192     IORWF 0x92, W, BANKED
10394  B4D8     BTFSC STATUS, 2, ACCESS
10396  D002     BRA 0x39C
10398  0E01     MOVLW 0x1
1039A  6F99     MOVWF 0x99, BANKED
1039C  C099     MOVFF 0x99, 0xAE
1039E  F0AE     NOP
134:           		led[LED_CUL] = GetChgState();
103A0  ECE7     CALL 0x125CE, 0
103A2  F092     NOP
103A4  0100     MOVLB 0x0
103A6  6FB6     MOVWF 0xB6, BANKED
135:           		led[LED_CUR] = (volt * 2 - 560) > sawToothWave;
103A8  0ED0     MOVLW 0xD0
103AA  6F91     MOVWF 0x91, BANKED
103AC  0EFD     MOVLW 0xFD
103AE  6F92     MOVWF 0x92, BANKED
103B0  C0DC     MOVFF volt, 0x93
103B2  F093     NOP
103B4  C0DD     MOVFF 0xDD, 0x94
103B6  F094     NOP
103B8  90D8     BCF STATUS, 0, ACCESS
103BA  3793     RLCF 0x93, F, BANKED
103BC  3794     RLCF 0x94, F, BANKED
103BE  5191     MOVF 0x91, W, BANKED
103C0  2793     ADDWF 0x93, F, BANKED
103C2  5192     MOVF 0x92, W, BANKED
103C4  2394     ADDWFC 0x94, F, BANKED
103C6  51CE     MOVF sawToothWave, W, BANKED
103C8  6F95     MOVWF 0x95, BANKED
103CA  6B96     CLRF 0x96, BANKED
103CC  5193     MOVF 0x93, W, BANKED
103CE  5D95     SUBWF 0x95, W, BANKED
103D0  5194     MOVF 0x94, W, BANKED
103D2  5996     SUBWFB 0x96, W, BANKED
103D4  B0D8     BTFSC STATUS, 0, ACCESS
103D6  D002     BRA 0x3DC
103D8  0E01     MOVLW 0x1
103DA  D001     BRA 0x3DE
103DC  0E00     MOVLW 0x0
103DE  6FB7     MOVWF 0xB7, BANKED
136:           #endif
137:           
138:           		//SW1
139:           		sw1Process();
103E0  EC78     CALL 0x11EF0, 0
103E2  F08F     NOP
140:           
141:           		//SW101-172
142:           		swProcess();
103E4  EC1C     CALL 0x10A38, 0
103E6  F085     NOP
143:           
144:           		if (mainFlags.cycle33s)
103E8  AE0B     BTFSS mainFlags, 7, ACCESS
103EA  D007     BRA 0x3FA
145:           		{
146:           			volt = GetFuel();
103EC  EC3E     CALL 0x11E7C, 0
103EE  F08F     NOP
103F0  C07F     MOVFF d, volt
103F2  F0DC     NOP
103F4  C080     MOVFF kc, 0xDD
103F6  F0DD     NOP
147:           			mainFlags.cycle33s = 0;
103F8  9E0B     BCF mainFlags, 7, ACCESS
148:           		}
149:           
150:           		if (mainFlags.cycle052s)
103FA  A00C     BTFSS 0xC, 0, ACCESS
103FC  D010     BRA 0x41E
151:           		{
152:           			//BT connection status
153:           			checkBtState();
103FE  EC9B     CALL 0x12736, 0
10400  F093     NOP
154:           
155:           			//Battery charge current
156:           			Chg400mAEn(USB_UpTo400mA);
10402  0E00     MOVLW 0x0
10404  0100     MOVLB 0x0
10406  6F9A     MOVWF 0x9A, BANKED
10408  AC8E     BTFSS PORTF, 6, ACCESS
1040A  AE8E     BTFSS PORTF, 7, ACCESS
1040C  D002     BRA 0x412
1040E  0E01     MOVLW 0x1
10410  6F9A     MOVWF 0x9A, BANKED
10412  B19A     BTFSC 0x9A, 0, BANKED
10414  D002     BRA 0x41A
10416  987E     BCF LATF, 4, ACCESS
10418  D001     BRA 0x41C
1041A  887E     BSF LATF, 4, ACCESS
157:           
158:           			//DEBUG
159:           			//			//						showHex4(keyReport.modifier.byte << 8 | keyReport.modifierLatch.byte);
160:           			//			//						showHex4(keyReport.modifier2.byte << 8 | keyReport.modifier2delay.byte);
161:           			//			showHex2(keyReport.modifier.byte | keyReport.modifier2.byte | keyReport.modifier2delay.byte | keyReport.modifierLatch.byte);
162:           			//			showHex2(keyReport.scanCodes[0]);
163:           			//			showHex2(keyReport.scanCodes[1]);
164:           			//			showHex2(keyReport.scanCodes[2]);
165:           			//			showHex2(mSw[0].kc);
166:           			//			showHex2(mSw[1].kc);
167:           			//			showHex2(mSw[2].kc);
168:           			//			showHex2(mSw[0].num);
169:           			//			showHex2(mSw[1].num);
170:           			//			showHex2(mSw[2].num);
171:           			//			showHex2(mSw[0].state);
172:           			//			showHex2(mSw[1].state);
173:           			//			showHex2(mSw[2].state);
174:           			//			showText("\r\n");
175:           			mainFlags.cycle052s = 0;
1041C  900C     BCF 0xC, 0, ACCESS
176:           		}
177:           
178:           
179:           		if (mainFlags.sendComsumerKeyReport)
1041E  A20C     BTFSS 0xC, 1, ACCESS
10420  D00A     BRA 0x436
180:           		{
181:           			sendConsumerReport();
10422  EC21     CALL 0x12042, 0
10424  F090     NOP
182:           			setSleepDelay(1000);
10426  0E03     MOVLW 0x3
10428  0100     MOVLB 0x0
1042A  6F86     MOVWF c, BANKED
1042C  0EE8     MOVLW 0xE8
1042E  6F85     MOVWF b, BANKED
10430  ECEA     CALL 0x11FD4, 0
10432  F08F     NOP
183:           			mainFlags.sendComsumerKeyReport = 0;
10434  920C     BCF 0xC, 1, ACCESS
184:           		}
185:           
186:           		if (mainFlags.sendKeyReport)
10436  A40C     BTFSS 0xC, 2, ACCESS
10438  D010     BRA 0x45A
187:           		{
188:           			setScanCodes();
1043A  EC1F     CALL 0x1183E, 0
1043C  F08C     NOP
189:           			sendKey();
1043E  EC92     CALL 0x11924, 0
10440  F08C     NOP
190:           			setSleepDelay(300);
10442  0E01     MOVLW 0x1
10444  0100     MOVLB 0x0
10446  6F86     MOVWF c, BANKED
10448  0E2C     MOVLW 0x2C
1044A  6F85     MOVWF b, BANKED
1044C  ECEA     CALL 0x11FD4, 0
1044E  F08F     NOP
191:           			if (keyReport.modifier2delay.byte == keyReport.modifier2.byte)
10450  0100     MOVLB 0x0
10452  51BA     MOVF 0xBA, W, BANKED
10454  19BB     XORWF 0xBB, W, BANKED
10456  B4D8     BTFSC STATUS, 2, ACCESS
192:           			{
193:           				mainFlags.sendKeyReport = 0;
10458  940C     BCF 0xC, 2, ACCESS
194:           			}
195:           		}
196:           
197:           		if (mainFlags.sendToggleKey)
1045A  A60C     BTFSS 0xC, 3, ACCESS
1045C  D00A     BRA 0x472
198:           		{
199:           			sendToggle();
1045E  EC38     CALL 0x12670, 0
10460  F093     NOP
200:           			setSleepDelay(300);
10462  0E01     MOVLW 0x1
10464  0100     MOVLB 0x0
10466  6F86     MOVWF c, BANKED
10468  0E2C     MOVLW 0x2C
1046A  6F85     MOVWF b, BANKED
1046C  ECEA     CALL 0x11FD4, 0
1046E  F08F     NOP
201:           			mainFlags.sendToggleKey = 0;
10470  960C     BCF 0xC, 3, ACCESS
202:           		}
203:           
204:           		if (mainFlags.sendMouseReport)
10472  A80C     BTFSS 0xC, 4, ACCESS
10474  D015     BRA 0x4A0
205:           		{
206:           			setXY();
10476  ECD0     CALL 0x111A0, 0
10478  F088     NOP
207:           			sendMouse();
1047A  EC3B     CALL 0x11C76, 0
1047C  F08E     NOP
208:           			setSleepDelay(300);
1047E  0E01     MOVLW 0x1
10480  0100     MOVLB 0x0
10482  6F86     MOVWF c, BANKED
10484  0E2C     MOVLW 0x2C
10486  6F85     MOVWF b, BANKED
10488  ECEA     CALL 0x11FD4, 0
1048A  F08F     NOP
209:           			if (!mouseReport.X && !mouseReport.Y && !mouseReport.W)
1048C  0100     MOVLB 0x0
1048E  51C3     MOVF 0xC3, W, BANKED
10490  A4D8     BTFSS STATUS, 2, ACCESS
10492  D006     BRA 0x4A0
10494  51C4     MOVF 0xC4, W, BANKED
10496  A4D8     BTFSS STATUS, 2, ACCESS
10498  D003     BRA 0x4A0
1049A  51C5     MOVF 0xC5, W, BANKED
1049C  B4D8     BTFSC STATUS, 2, ACCESS
210:           			{
211:           				mainFlags.sendMouseReport = 0;
1049E  980C     BCF 0xC, 4, ACCESS
212:           			}
213:           		}
214:           
215:           		if (mainFlags.sw1Pushed)
104A0  A00B     BTFSS mainFlags, 0, ACCESS
104A2  D008     BRA 0x4B4
216:           		{
217:           			setSleepDelay(300);
104A4  0E01     MOVLW 0x1
104A6  0100     MOVLB 0x0
104A8  6F86     MOVWF c, BANKED
104AA  0E2C     MOVLW 0x2C
104AC  6F85     MOVWF b, BANKED
104AE  ECEA     CALL 0x11FD4, 0
104B0  F08F     NOP
218:           			mainFlags.sw1Pushed = 0;
104B2  900B     BCF mainFlags, 0, ACCESS
219:           		}
220:           
221:           		if (mainFlags.sw1LongPushing)
104B4  A20B     BTFSS mainFlags, 1, ACCESS
104B6  D009     BRA 0x4CA
222:           		{
223:           			//Toggle Pair mode/Connect mode
224:           			mainFlags.connectToggle = 1;
104B8  8A0B     BSF mainFlags, 5, ACCESS
225:           			setSleepDelay(300);
104BA  0E01     MOVLW 0x1
104BC  0100     MOVLB 0x0
104BE  6F86     MOVWF c, BANKED
104C0  0E2C     MOVLW 0x2C
104C2  6F85     MOVWF b, BANKED
104C4  ECEA     CALL 0x11FD4, 0
104C6  F08F     NOP
226:           			mainFlags.sw1LongPushing = 0;
104C8  920B     BCF mainFlags, 1, ACCESS
227:           		}
228:           
229:           		if (mainFlags.showBattery)
104CA  AC0B     BTFSS mainFlags, 6, ACCESS
104CC  D00A     BRA 0x4E2
230:           		{
231:           			showBatteryState();
104CE  ECC3     CALL 0x11D86, 0
104D0  F08E     NOP
232:           			setSleepDelay(300);
104D2  0E01     MOVLW 0x1
104D4  0100     MOVLB 0x0
104D6  6F86     MOVWF c, BANKED
104D8  0E2C     MOVLW 0x2C
104DA  6F85     MOVWF b, BANKED
104DC  ECEA     CALL 0x11FD4, 0
104DE  F08F     NOP
233:           			mainFlags.showBattery = 0;
104E0  9C0B     BCF mainFlags, 6, ACCESS
234:           		}
235:           
236:           		if (mainFlags.enterCommand)
104E2  A60B     BTFSS mainFlags, 3, ACCESS
104E4  D00A     BRA 0x4FA
237:           		{
238:           			enterCommand();
104E6  EC0C     CALL 0x12218, 0
104E8  F091     NOP
239:           			setSleepDelay(600);
104EA  0E02     MOVLW 0x2
104EC  0100     MOVLB 0x0
104EE  6F86     MOVWF c, BANKED
104F0  0E58     MOVLW 0x58
104F2  6F85     MOVWF b, BANKED
104F4  ECEA     CALL 0x11FD4, 0
104F6  F08F     NOP
240:           			mainFlags.enterCommand = 0;
104F8  960B     BCF mainFlags, 3, ACCESS
241:           		}
242:           
243:           		if (mainFlags.connected)
104FA  A80B     BTFSS mainFlags, 4, ACCESS
104FC  D00A     BRA 0x512
244:           		{
245:           			connected();
104FE  ECCF     CALL 0x1279E, 0
10500  F093     NOP
246:           			setSleepDelay(300);
10502  0E01     MOVLW 0x1
10504  0100     MOVLB 0x0
10506  6F86     MOVWF c, BANKED
10508  0E2C     MOVLW 0x2C
1050A  6F85     MOVWF b, BANKED
1050C  ECEA     CALL 0x11FD4, 0
1050E  F08F     NOP
247:           			mainFlags.connected = 0;
10510  980B     BCF mainFlags, 4, ACCESS
248:           		}
249:           
250:           		if (mainFlags.connectToggle)
10512  AA0B     BTFSS mainFlags, 5, ACCESS
10514  D00A     BRA 0x52A
251:           		{
252:           			connectToggle();
10516  EC91     CALL 0x12722, 0
10518  F093     NOP
253:           			setSleepDelay(300);
1051A  0E01     MOVLW 0x1
1051C  0100     MOVLB 0x0
1051E  6F86     MOVWF c, BANKED
10520  0E2C     MOVLW 0x2C
10522  6F85     MOVWF b, BANKED
10524  ECEA     CALL 0x11FD4, 0
10526  F08F     NOP
254:           			mainFlags.connectToggle = 0;
10528  9A0B     BCF mainFlags, 5, ACCESS
255:           		}
256:           
257:           		//		if (!mainFlags.all && TX5STAbits.TRMT && TX2STAbits.TRMT)
258:           		//		{
259:           		//			IDLEN = 1;
260:           		//			Sleep();
261:           		//		}
262:           
263:           		if (mainFlags.shutdown)
1052A  A40B     BTFSS mainFlags, 2, ACCESS
1052C  D673     BRA 0x214
264:           		{
265:           			WriteEEPROM(0, keyMode);
1052E  0E00     MOVLW 0x0
10530  0100     MOVLB 0x0
10532  6F7A     MOVWF e, BANKED
10534  0E00     MOVLW 0x0
10536  6F79     MOVWF multiplier, BANKED
10538  C0CD     MOVFF keyMode, kc
1053A  F07B     NOP
1053C  ECEF     CALL 0x123DE, 0
1053E  F091     NOP
266:           #ifdef MICRO_QWERTY
267:           			WriteEEPROM(1, fnEnableLatch);
10540  0E00     MOVLW 0x0
10542  0100     MOVLB 0x0
10544  6F7A     MOVWF e, BANKED
10546  0E01     MOVLW 0x1
10548  6F79     MOVWF multiplier, BANKED
1054A  C0CC     MOVFF fnEnableLatch, kc
1054C  F07B     NOP
1054E  ECEF     CALL 0x123DE, 0
10550  F091     NOP
268:           #endif
269:           
270:           			for (unsigned char c = 0; c < LEDNUM; c++)
10552  0E00     MOVLW 0x0
10554  0100     MOVLB 0x0
10556  6F9E     MOVWF c, BANKED
10558  0E0B     MOVLW 0xB
1055A  659E     CPFSGT c, BANKED
1055C  D001     BRA 0x560
1055E  D00C     BRA 0x578
10574  2B9E     INCF c, F, BANKED
10576  D7F0     BRA 0x558
271:           			{
272:           				led[c] = 0;
10560  519E     MOVF c, W, BANKED
10562  0D01     MULLW 0x1
10564  0EAC     MOVLW 0xAC
10566  24F3     ADDWF PROD, W, ACCESS
10568  6ED9     MOVWF FSR2, ACCESS
1056A  0E00     MOVLW 0x0
1056C  20F4     ADDWFC PRODH, W, ACCESS
1056E  6EDA     MOVWF FSR2H, ACCESS
10570  0E00     MOVLW 0x0
10572  6EDF     MOVWF INDF2, ACCESS
273:           			}
274:           			waitMs(200);
10578  0EC8     MOVLW 0xC8
1057A  6F79     MOVWF multiplier, BANKED
1057C  0E00     MOVLW 0x0
1057E  6F7A     MOVWF e, BANKED
10580  0E00     MOVLW 0x0
10582  6F7B     MOVWF kc, BANKED
10584  0E00     MOVLW 0x0
10586  6F7C     MOVWF sameRow, BANKED
10588  EC11     CALL 0x12422, 0
1058A  F092     NOP
275:           			for (unsigned char c = 0; c < LEDNUM; c++)
1058C  0E00     MOVLW 0x0
1058E  0100     MOVLB 0x0
10590  6F9F     MOVWF c, BANKED
10592  0E0B     MOVLW 0xB
10594  659F     CPFSGT c, BANKED
10596  D001     BRA 0x59A
10598  D017     BRA 0x5C8
105C2  0100     MOVLB 0x0
105C4  2B9F     INCF c, F, BANKED
105C6  D7E5     BRA 0x592
276:           			{
277:           				led[c] = 1;
1059A  519F     MOVF c, W, BANKED
1059C  0D01     MULLW 0x1
1059E  0EAC     MOVLW 0xAC
105A0  24F3     ADDWF PROD, W, ACCESS
105A2  6ED9     MOVWF FSR2, ACCESS
105A4  0E00     MOVLW 0x0
105A6  20F4     ADDWFC PRODH, W, ACCESS
105A8  6EDA     MOVWF FSR2H, ACCESS
105AA  0E01     MOVLW 0x1
105AC  6EDF     MOVWF INDF2, ACCESS
278:           				waitMs(100);
105AE  0E64     MOVLW 0x64
105B0  6F79     MOVWF multiplier, BANKED
105B2  0E00     MOVLW 0x0
105B4  6F7A     MOVWF e, BANKED
105B6  0E00     MOVLW 0x0
105B8  6F7B     MOVWF kc, BANKED
105BA  0E00     MOVLW 0x0
105BC  6F7C     MOVWF sameRow, BANKED
105BE  EC11     CALL 0x12422, 0
105C0  F092     NOP
279:           			}
280:           			waitMs(200);
105C8  0EC8     MOVLW 0xC8
105CA  6F79     MOVWF multiplier, BANKED
105CC  0E00     MOVLW 0x0
105CE  6F7A     MOVWF e, BANKED
105D0  0E00     MOVLW 0x0
105D2  6F7B     MOVWF kc, BANKED
105D4  0E00     MOVLW 0x0
105D6  6F7C     MOVWF sameRow, BANKED
105D8  EC11     CALL 0x12422, 0
105DA  F092     NOP
281:           			Reset();
105DC  00FF     RESET
105DE  D61A     BRA 0x214
282:           		}
283:           	}
284:           }
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/keys.c  -------------------------------------
1:             /*
2:              * File:   keys.c
3:              * Author: imada
4:              *
5:              * Created on May 30, 2018, 7:46 PM
6:              */
7:             
8:             #include <xc.h>         /* XC8 General Include File */
9:             
10:            #include <stdint.h>         /* For uint8_t definition */
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdlib.h>        
13:            
14:            #include "user.h"
15:            #include "keys.h"
16:            #include "swMatrix.h"
17:            #include "RN42.h"
18:            #include "HID_Define.h"
19:            #include "FT230X.h"
20:            #include "main.h"
21:            
22:            #define getKeyGroup(kc) (kc & 0xf000)
23:            
24:            #define	ON_COUNT	5
25:            
26:            #define N_PUSHABLE	10
27:            
28:            #define	N_COL		16
29:            
30:            
31:            #ifdef MICRO_QWERTY
32:            #define	getKeyCode(x)	keyMapList[(fnEnable|fnEnableLatch) + keyMode*2][x]
33:            
34:            static const unsigned short keyMap1[] = {
35:            	//0     1     2     3     4     5     6     7     8     9     A     B
36:            	__1_, __2_, __3_, __4_, __5_, __6_, __7_, __8_, __9_, __0_, MIN_, EQU_, ____, ____, ____, ____, //0x0n
37:            	__Q_, __W_, __E_, __R_, __T_, __Y_, __U_, __I_, __O_, __P_, DEL_, BSP_, ____, ____, ____, ____, //0x1n
38:            	__A_, __S_, __D_, __F_, __G_, __H_, __J_, __K_, __L_, BR_L, BR_R, ENT_, ____, ____, ____, ____, //0x2n
39:            	SHLL, __Z_, __X_, __C_, __V_, __B_, __N_, __M_, SEMI, APOS, C_UP, SHRL, ____, ____, ____, ____, //0x3n
40:            	CTLL, GULL, ALLL, FNLL, _SP_, TAB_, COMM, DOT_, FNRL, C_LT, C_DN, C_RT, ____, ____, ____, ____, //0x4n
41:            	NEXT, PREV, ESC_, CAPS, SLAS, BSLA, GRAV, PREV, PLAY, NEXT, V_DN, V_UP, ____, ____, ____, ____, //0x5n
42:            };
43:            
44:            static const unsigned short keyMap1Fn[] = {
45:            	//0     1     2     3     4     5     6     7     8     9     A     B
46:            	_F1_, _F2_, _F3_, _F4_, _F5_, _F6_, _F7_, _F8_, _F9_, F10_, F11_, F12_, ____, ____, ____, ____, //0x0n
47:            	__Q_, __W_, __E_, __R_, __T_, __Y_, __U_, __I_, __O_, __P_, DEL_, BSP_, ____, ____, ____, ____, //0x1n
48:            	__A_, __S_, __D_, __F_, __G_, __H_, __J_, __K_, __L_, BR_L, BR_R, ENT_, ____, ____, ____, ____, //0x2n
49:            	SHLL, __Z_, __X_, __C_, __V_, __B_, __N_, __M_, SEMI, APOS, P_UP, SHRL, ____, ____, ____, ____, //0x3n
50:            	CTLL, GULL, ALLL, FNLL, _SP_, TAB_, COMM, DOT_, FNRL, HOME, P_DN, END_, ____, ____, ____, ____, //0x4n
51:            	CONN, SHDN, BATT, CAPS, SLAS, BSLA, GRAV, MD_1, MD_2, MD_3, MUTE, PLAY, ____, ____, ____, ____, //0x5n
52:            };
53:            
54:            static const unsigned short keyMap2[] = {
55:            	//0     1     2     3     4     5     6     7     8     9     A     B
56:            	____, M_UL, M_UU, M_UU, M_UU, M_UR, ____, CL_L, CL_L, CL_L, CL_R, CL_R, ____, ____, ____, ____, //0x0n
57:            	____, M_LL, m_UL, m_UU, m_UR, M_RR, ____, CL_L, CL_L, CL_L, CL_R, CL_R, ____, ____, ____, ____, //0x1n
58:            	____, M_LL, m_LL, ____, m_RR, M_RR, ____, CL_L, CL_L, CL_L, CL_R, CL_R, ____, ____, ____, ____, //0x2n
59:            	____, M_LL, m_DL, m_DD, m_DR, M_RR, ____, ____, ____, ____, CL_M, CL_M, ____, ____, ____, ____, //0x3n
60:            	____, M_DL, M_DD, M_DD, M_DD, M_DR, ____, S_UP, FNRL, ____, CL_M, CL_M, ____, ____, ____, ____, //0x4n
61:            	S_UP, S_DN, ____, ____, ____, ____, ____, S_DN, ____, ____, S_DN, S_UP, ____, ____, ____, ____, //0x5n
62:            };
63:            
64:            static const unsigned short keyMap2Fn[] = {
65:            	//0     1     2     3     4     5     6     7     8     9     A     B
66:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, M_FT, ____, ____, ____, ____, //0x0n
67:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, M_SW, ____, ____, ____, ____, //0x1n
68:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
69:            	____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x3n
70:            	____, ____, ____, ____, ____, ____, ____, ____, FNRL, ____, ____, ____, ____, ____, ____, ____, //0x4n
71:            	CONN, SHDN, ____, ____, ____, ____, ____, MD_1, MD_2, MD_3, V_DN, V_UP, ____, ____, ____, ____, //0x5n
72:            };
73:            
74:            static const unsigned short keyMap3[] = {
75:            	//0     1     2     3     4     5     6     7     8     9     A     B
76:            	PREV, PREV, PREV, PREV, V_UP, V_UP, V_UP, V_UP, NEXT, NEXT, NEXT, NEXT, ____, ____, ____, ____, //0x0n
77:            	PREV, PREV, PREV, PREV, V_UP, V_UP, V_UP, V_UP, NEXT, NEXT, NEXT, NEXT, ____, ____, ____, ____, //0x1n
78:            	PREV, PREV, PREV, PREV, PLAY, PLAY, PLAY, PLAY, NEXT, NEXT, NEXT, NEXT, ____, ____, ____, ____, //0x2n
79:            	PREV, PREV, PREV, PREV, PLAY, PLAY, PLAY, PLAY, NEXT, NEXT, NEXT, NEXT, ____, ____, ____, ____, //0x3n
80:            	PREV, PREV, PREV, PREV, V_DN, V_DN, V_DN, V_DN, FNRL, NEXT, NEXT, NEXT, ____, ____, ____, ____, //0x4n
81:            	____, ____, PREV, PREV, V_DN, V_DN, V_DN, V_DN, ____, ____, V_DN, V_UP, ____, ____, ____, ____, //0x5n
82:            };
83:            
84:            static const unsigned short keyMap3Fn[] = {
85:            	//0     1     2     3     4     5     6     7     8     9     A     B
86:            	NBAK, NBAK, NBAK, NBAK, V_UP, V_UP, V_UP, V_UP, NFWD, NFWD, NFWD, NFWD, ____, ____, ____, ____, //0x0n
87:            	NBAK, NBAK, NBAK, NBAK, V_UP, V_UP, V_UP, V_UP, NFWD, NFWD, NFWD, NFWD, ____, ____, ____, ____, //0x1n
88:            	NBAK, NBAK, NBAK, NBAK, _SP_, _SP_, _SP_, _SP_, NFWD, NFWD, NFWD, NFWD, ____, ____, ____, ____, //0x2n
89:            	NBAK, NBAK, NBAK, NBAK, _SP_, _SP_, _SP_, _SP_, NFWD, NFWD, NFWD, NFWD, ____, ____, ____, ____, //0x3n
90:            	NBAK, NBAK, NBAK, NBAK, V_DN, V_DN, V_DN, V_DN, FNRL, NFWD, NFWD, NFWD, ____, ____, ____, ____, //0x4n
91:            	CONN, SHDN, NBAK, NBAK, V_DN, V_DN, V_DN, MD_1, MD_2, MD_3, V_DN, V_UP, ____, ____, ____, ____, //0x5n
92:            };
93:            static const unsigned short* keyMapList[] = {
94:            	keyMap1, keyMap1Fn,
95:            	keyMap2, keyMap2Fn,
96:            	keyMap3, keyMap3Fn,
97:            };
98:            #endif
99:            #ifdef REMOTE_CONTROL
100:           #define	getKeyCode(x)	((fnEnable|fnEnableLatch) ? keyMapMouseFn[x] : keyMapMouse[x])
101:           static const unsigned short keyMapMouse[] = {
102:           	//0     1     2     3     4
103:           	____, ____, PREV, M_LL, CL_L, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
104:           	FN_L, ____, NEXT, M_DD, M_UU, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
105:           	V_DN, V_UP, PLAY, M_RR, CL_R, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
106:           };
107:           static const unsigned short keyMapMouseFn[] = {
108:           	//0     1     2     3     4
109:           	____, ____, PREV, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
110:           	FN_L, ____, NEXT, ____, CL_M, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
111:           	V_DN, V_UP, PLAY, S_DN, S_UP, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
112:           };
113:           static const unsigned short keyMapCursor[] = {
114:           	//0     1     2     3     4
115:           	____, ____, PREV, ____, CONN, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
116:           	FN_L, ____, NEXT, ____, DISC, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
117:           	V_DN, V_UP, PLAY, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
118:           };
119:           static const unsigned short keyMapCursorFn[] = {
120:           	//0     1     2     3     4
121:           	____, ____, PRE, CON, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x0n
122:           	____, FNL, NXT, DIS, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x1n
123:           	VUP, VDN, PaP, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, //0x2n
124:           };
125:           #endif
126:           #ifdef ORIGINAL
127:           #define	getKeyCode(x)	keyMapList[fnEnable][x]
128:           static const unsigned short keyMap1[] = {
129:           	//0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
130:           	ESC_, _F1_, _F2_, _F3_, _F4_, _F5_, _F6_, _F7_, _F8_, _F9_, F10_, F11_, F12_, DEL_, ____, ____, //0x0n
131:           	GRAV, __1_, __2_, __3_, __4_, __5_, __6_, __7_, __8_, __9_, __0_, MIN_, EQU_, BSP_, ____, ____, //0x1n
132:           	TAB_, __Q_, __W_, __E_, __R_, __T_, __Y_, __U_, __I_, __O_, __P_, BR_L, BR_R, BSLA, ____, ____, //0x2n
133:           	CAPS, __A_, __S_, __D_, __F_, __G_, __H_, __J_, __K_, __L_, SEMI, APOS, ____, ENT_, ____, ____, //0x3n
134:           	SH_L, __Z_, __X_, __C_, __V_, __B_, __N_, __M_, COMM, DOT_, SLAS, ____, C_UP, SH_R, ____, ____, //0x4n
135:           	CT_L, GU_L, AL_L, FN_L, ____, ____, _SP_, FN_R, ____, ____, ____, C_LT, C_DN, C_RT, ____, ____, //0x5n
136:           };
137:           
138:           static const unsigned short keyMap1Fn[] = {
139:           	//0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
140:           	SHDN, ____, ____, ____, ____, ____, ____, MUTE, V_DN, V_UP, PREV, PLAY, NEXT, DEL_, ____, ____, //0x0n
141:           	CONN, __1_, __2_, __3_, __4_, __5_, __6_, __7_, __8_, __9_, __0_, MIN_, EQU_, BSP_, ____, ____, //0x1n
142:           	TAB_, __Q_, __W_, __E_, __R_, __T_, __Y_, __U_, __I_, __O_, __P_, BR_L, BR_R, BSLA, ____, ____, //0x2n
143:           	CAPS, __A_, __S_, __D_, __F_, __G_, __H_, __J_, __K_, __L_, SEMI, APOS, ____, ENT_, ____, ____, //0x3n
144:           	SH_L, __Z_, __X_, __C_, __V_, __B_, __N_, __M_, COMM, DOT_, SLAS, ____, P_UP, SH_R, ____, ____, //0x4n
145:           	CT_L, GU_L, AL_L, FN_L, ____, ____, _SP_, FN_R, ____, ____, ____, HOME, P_DN, END_, ____, ____, //0x5n
146:           };
147:           static const unsigned short* keyMapList[] = {
148:           	keyMap1, keyMap1Fn,
149:           };
150:           #endif
151:           
152:           void setScanCodes(void);
153:           
154:           
155:           unsigned char keyMode = 0;
156:           unsigned char fnEnable = 0;
157:           unsigned char fnEnableLatch = 0;
158:           struct KeyReport keyReport;
159:           
160:           /******************************************************************************/
161:           /* User Functions                                                             */
162:           /******************************************************************************/
163:           
164:           void swPush(unsigned char c)
105E0  0100     MOVLB 0x0
105E2  6F84     MOVWF c, BANKED
165:           {
166:           	mSw[c].kc = getKeyCode(mSw[c].num);
105E4  0100     MOVLB 0x0
105E6  5184     MOVF c, W, BANKED
105E8  0D07     MULLW 0x7
105EA  0E02     MOVLW 0x2
105EC  26F3     ADDWF PROD, F, ACCESS
105EE  0E00     MOVLW 0x0
105F0  22F4     ADDWFC PRODH, F, ACCESS
105F2  0E00     MOVLW 0x0
105F4  24F3     ADDWF PROD, W, ACCESS
105F6  6ED9     MOVWF FSR2, ACCESS
105F8  0E01     MOVLW 0x1
105FA  20F4     ADDWFC PRODH, W, ACCESS
105FC  6EDA     MOVWF FSR2H, ACCESS
105FE  50DF     MOVF INDF2, W, ACCESS
10600  6F79     MOVWF multiplier, BANKED
10602  5179     MOVF multiplier, W, BANKED
10604  0D02     MULLW 0x2
10606  51CD     MOVF keyMode, W, BANKED
10608  6F7A     MOVWF e, BANKED
1060A  6B7B     CLRF kc, BANKED
1060C  90D8     BCF STATUS, 0, ACCESS
1060E  377A     RLCF e, F, BANKED
10610  377B     RLCF kc, F, BANKED
10612  51CB     MOVF fnEnable, W, BANKED
10614  11CC     IORWF fnEnableLatch, W, BANKED
10616  6F7C     MOVWF sameRow, BANKED
10618  6B7D     CLRF multiplicand, BANKED
1061A  517A     MOVF e, W, BANKED
1061C  277C     ADDWF sameRow, F, BANKED
1061E  517B     MOVF kc, W, BANKED
10620  237D     ADDWFC multiplicand, F, BANKED
10622  90D8     BCF STATUS, 0, ACCESS
10624  377C     RLCF sameRow, F, BANKED
10626  377D     RLCF multiplicand, F, BANKED
10628  0ED0     MOVLW 0xD0
1062A  257C     ADDWF sameRow, W, BANKED
1062C  6ED9     MOVWF FSR2, ACCESS
1062E  0E00     MOVLW 0x0
10630  217D     ADDWFC multiplicand, W, BANKED
10632  6EDA     MOVWF FSR2H, ACCESS
10634  CFDE     MOVFF POSTINC2, c
10636  F07E     NOP
10638  CFDD     MOVFF POSTDEC2, d
1063A  F07F     NOP
1063C  50F3     MOVF PROD, W, ACCESS
1063E  277E     ADDWF c, F, BANKED
10640  50F4     MOVF PRODH, W, ACCESS
10642  237F     ADDWFC d, F, BANKED
10644  C07E     MOVFF c, TBLPTR
10646  FFF6     NOP
10648  C07F     MOVFF d, TBLPTRH
1064A  FFF7     NOP
1064C  0E00     MOVLW 0x0
1064E  6EF8     MOVWF TBLPTRU, ACCESS
10650  5184     MOVF c, W, BANKED
10652  0D07     MULLW 0x7
10654  0E05     MOVLW 0x5
10656  26F3     ADDWF PROD, F, ACCESS
10658  0E00     MOVLW 0x0
1065A  22F4     ADDWFC PRODH, F, ACCESS
1065C  0E00     MOVLW 0x0
1065E  24F3     ADDWF PROD, W, ACCESS
10660  6ED9     MOVWF FSR2, ACCESS
10662  0E01     MOVLW 0x1
10664  20F4     ADDWFC PRODH, W, ACCESS
10666  6EDA     MOVWF FSR2H, ACCESS
10668  0009     TBLRD*+
1066A  CFF5     MOVFF TABLAT, POSTINC2
1066C  FFDE     NOP
1066E  0008     TBLRD*
10670  CFF5     MOVFF TABLAT, POSTDEC2
10672  FFDD     NOP
167:           	switch (getKeyGroup(mSw[c].kc))
10674  D18F     BRA 0x994
10994  0E00     MOVLW 0x0
168:           	{
169:           	case KEY_NORMAL: //Normal keys
170:           		keyReport.modifierLatch.byte &= ~keyReport.modifier.byte;
10676  51B9     MOVF 0xB9, W, BANKED
10678  0AFF     XORLW 0xFF
1067A  17B8     ANDWF keyReport, F, BANKED
171:           		fnEnableLatch &= ~fnEnable;
1067C  51CB     MOVF fnEnable, W, BANKED
1067E  0AFF     XORLW 0xFF
10680  17CC     ANDWF fnEnableLatch, F, BANKED
172:           		mainFlags.sendKeyReport = 1;
10682  840C     BSF 0xC, 2, ACCESS
173:           		break;
10684  0012     RETURN 0
174:           	case KEY_MODIFIER_LATCH: //Modifier keys
175:           		if (mSw[c].kc == SHLL && keyReport.modifierLatch.bits.ShiftR)
10686  5184     MOVF c, W, BANKED
10688  0D07     MULLW 0x7
1068A  0E05     MOVLW 0x5
1068C  26F3     ADDWF PROD, F, ACCESS
1068E  0E00     MOVLW 0x0
10690  22F4     ADDWFC PRODH, F, ACCESS
10692  0E00     MOVLW 0x0
10694  24F3     ADDWF PROD, W, ACCESS
10696  6ED9     MOVWF FSR2, ACCESS
10698  0E01     MOVLW 0x1
1069A  20F4     ADDWFC PRODH, W, ACCESS
1069C  6EDA     MOVWF FSR2H, ACCESS
1069E  50DE     MOVF POSTINC2, W, ACCESS
106A0  E106     BNZ 0x6AE
106A2  0E10     MOVLW 0x10
106A4  18DE     XORWF POSTINC2, W, ACCESS
106A6  A4D8     BTFSS STATUS, 2, ACCESS
106A8  D002     BRA 0x6AE
106AA  0E01     MOVLW 0x1
106AC  D001     BRA 0x6B0
106AE  0E00     MOVLW 0x0
106B0  6F7B     MOVWF kc, BANKED
106B2  6B7C     CLRF sameRow, BANKED
106B4  0E01     MOVLW 0x1
106B6  137B     IORWF kc, F, BANKED
106B8  0E00     MOVLW 0x0
106BA  137C     IORWF sameRow, F, BANKED
106BC  517B     MOVF kc, W, BANKED
106BE  117C     IORWF sameRow, W, BANKED
106C0  A4D8     BTFSS STATUS, 2, ACCESS
106C2  ABB8     BTFSS keyReport, 5, BANKED
106C4  D002     BRA 0x6CA
176:           		{
177:           			keyReport.modifierLatch.bits.ShiftR = 0;
106C6  9BB8     BCF keyReport, 5, BANKED
178:           		}
106C8  D03D     BRA 0x744
179:           		else if (mSw[c].kc == SHRL && keyReport.modifierLatch.bits.ShiftL)
106CA  5184     MOVF c, W, BANKED
106CC  0D07     MULLW 0x7
106CE  0E05     MOVLW 0x5
106D0  26F3     ADDWF PROD, F, ACCESS
106D2  0E00     MOVLW 0x0
106D4  22F4     ADDWFC PRODH, F, ACCESS
106D6  0E00     MOVLW 0x0
106D8  24F3     ADDWF PROD, W, ACCESS
106DA  6ED9     MOVWF FSR2, ACCESS
106DC  0E01     MOVLW 0x1
106DE  20F4     ADDWFC PRODH, W, ACCESS
106E0  6EDA     MOVWF FSR2H, ACCESS
106E2  50DE     MOVF POSTINC2, W, ACCESS
106E4  E106     BNZ 0x6F2
106E6  0E10     MOVLW 0x10
106E8  18DE     XORWF POSTINC2, W, ACCESS
106EA  A4D8     BTFSS STATUS, 2, ACCESS
106EC  D002     BRA 0x6F2
106EE  0E01     MOVLW 0x1
106F0  D001     BRA 0x6F4
106F2  0E00     MOVLW 0x0
106F4  6F7B     MOVWF kc, BANKED
106F6  6B7C     CLRF sameRow, BANKED
106F8  0E05     MOVLW 0x5
106FA  137B     IORWF kc, F, BANKED
106FC  0E00     MOVLW 0x0
106FE  137C     IORWF sameRow, F, BANKED
10700  517B     MOVF kc, W, BANKED
10702  117C     IORWF sameRow, W, BANKED
10704  A4D8     BTFSS STATUS, 2, ACCESS
10706  A3B8     BTFSS keyReport, 1, BANKED
10708  D002     BRA 0x70E
180:           		{
181:           			keyReport.modifierLatch.bits.ShiftL = 0;
1070A  93B8     BCF keyReport, 1, BANKED
182:           		}
1070C  D01B     BRA 0x744
183:           		else
184:           		{
185:           			keyReport.modifierLatch.byte ^= 1 << (mSw[c].kc & 0x07);
1070E  5184     MOVF c, W, BANKED
10710  0D07     MULLW 0x7
10712  0E05     MOVLW 0x5
10714  26F3     ADDWF PROD, F, ACCESS
10716  0E00     MOVLW 0x0
10718  22F4     ADDWFC PRODH, F, ACCESS
1071A  0E00     MOVLW 0x0
1071C  24F3     ADDWF PROD, W, ACCESS
1071E  6ED9     MOVWF FSR2, ACCESS
10720  0E01     MOVLW 0x1
10722  20F4     ADDWFC PRODH, W, ACCESS
10724  6EDA     MOVWF FSR2H, ACCESS
10726  50DF     MOVF INDF2, W, ACCESS
10728  6F79     MOVWF multiplier, BANKED
1072A  0E07     MOVLW 0x7
1072C  1779     ANDWF multiplier, F, BANKED
1072E  0E01     MOVLW 0x1
10730  6F7A     MOVWF e, BANKED
10732  2B79     INCF multiplier, F, BANKED
10734  D002     BRA 0x73A
10736  90D8     BCF STATUS, 0, ACCESS
10738  377A     RLCF e, F, BANKED
1073A  2F79     DECFSZ multiplier, F, BANKED
1073C  D7FC     BRA 0x736
1073E  0100     MOVLB 0x0
10740  517A     MOVF e, W, BANKED
10742  1BB8     XORWF keyReport, F, BANKED
186:           		}
187:           		keyReport.modifier.byte |= 1 << (mSw[c].kc & 0x07);
10744  5184     MOVF c, W, BANKED
10746  0D07     MULLW 0x7
10748  0E05     MOVLW 0x5
1074A  26F3     ADDWF PROD, F, ACCESS
1074C  0E00     MOVLW 0x0
1074E  22F4     ADDWFC PRODH, F, ACCESS
10750  0E00     MOVLW 0x0
10752  24F3     ADDWF PROD, W, ACCESS
10754  6ED9     MOVWF FSR2, ACCESS
10756  0E01     MOVLW 0x1
10758  20F4     ADDWFC PRODH, W, ACCESS
1075A  6EDA     MOVWF FSR2H, ACCESS
1075C  50DF     MOVF INDF2, W, ACCESS
1075E  6F79     MOVWF multiplier, BANKED
10760  0E07     MOVLW 0x7
10762  1779     ANDWF multiplier, F, BANKED
10764  0E01     MOVLW 0x1
10766  6F7A     MOVWF e, BANKED
10768  2B79     INCF multiplier, F, BANKED
1076A  D002     BRA 0x770
1076C  90D8     BCF STATUS, 0, ACCESS
1076E  377A     RLCF e, F, BANKED
10770  2F79     DECFSZ multiplier, F, BANKED
10772  D7FC     BRA 0x76C
10774  0100     MOVLB 0x0
10776  517A     MOVF e, W, BANKED
10778  13B9     IORWF 0xB9, F, BANKED
188:           		mainFlags.sendKeyReport = 1;
1077A  840C     BSF 0xC, 2, ACCESS
189:           		break;
1077C  0012     RETURN 0
190:           	case KEY_MODIFIER: //Modifier keys
191:           		keyReport.modifier.byte |= 1 << (mSw[c].kc & 0x07);
1077E  5184     MOVF c, W, BANKED
10780  0D07     MULLW 0x7
10782  0E05     MOVLW 0x5
10784  26F3     ADDWF PROD, F, ACCESS
10786  0E00     MOVLW 0x0
10788  22F4     ADDWFC PRODH, F, ACCESS
1078A  0E00     MOVLW 0x0
1078C  24F3     ADDWF PROD, W, ACCESS
1078E  6ED9     MOVWF FSR2, ACCESS
10790  0E01     MOVLW 0x1
10792  20F4     ADDWFC PRODH, W, ACCESS
10794  6EDA     MOVWF FSR2H, ACCESS
10796  50DF     MOVF INDF2, W, ACCESS
10798  6F79     MOVWF multiplier, BANKED
1079A  0E07     MOVLW 0x7
1079C  1779     ANDWF multiplier, F, BANKED
1079E  0E01     MOVLW 0x1
107A0  6F7A     MOVWF e, BANKED
107A2  2B79     INCF multiplier, F, BANKED
107A4  D002     BRA 0x7AA
107A6  90D8     BCF STATUS, 0, ACCESS
107A8  377A     RLCF e, F, BANKED
107AA  2F79     DECFSZ multiplier, F, BANKED
107AC  D7FC     BRA 0x7A6
107AE  0100     MOVLB 0x0
107B0  517A     MOVF e, W, BANKED
107B2  13B9     IORWF 0xB9, F, BANKED
192:           		mainFlags.sendKeyReport = 1;
107B4  840C     BSF 0xC, 2, ACCESS
193:           		break;
107B6  0012     RETURN 0
194:           	case KEY_MEDIA: //Consumer report keys
195:           		consumerKey |= 0x01 << (unsigned char) mSw[c].kc;
107B8  5184     MOVF c, W, BANKED
107BA  0D07     MULLW 0x7
107BC  0E05     MOVLW 0x5
107BE  26F3     ADDWF PROD, F, ACCESS
107C0  0E00     MOVLW 0x0
107C2  22F4     ADDWFC PRODH, F, ACCESS
107C4  0E00     MOVLW 0x0
107C6  24F3     ADDWF PROD, W, ACCESS
107C8  6ED9     MOVWF FSR2, ACCESS
107CA  0E01     MOVLW 0x1
107CC  20F4     ADDWFC PRODH, W, ACCESS
107CE  6EDA     MOVWF FSR2H, ACCESS
107D0  50DF     MOVF INDF2, W, ACCESS
107D2  6F79     MOVWF multiplier, BANKED
107D4  0E01     MOVLW 0x1
107D6  6F7A     MOVWF e, BANKED
107D8  0E00     MOVLW 0x0
107DA  6F7B     MOVWF kc, BANKED
107DC  2B79     INCF multiplier, F, BANKED
107DE  D003     BRA 0x7E6
107E0  90D8     BCF STATUS, 0, ACCESS
107E2  377A     RLCF e, F, BANKED
107E4  377B     RLCF kc, F, BANKED
107E6  2F79     DECFSZ multiplier, F, BANKED
107E8  D7FB     BRA 0x7E0
107EA  0100     MOVLB 0x0
107EC  517A     MOVF e, W, BANKED
107EE  13C8     IORWF consumerKey, F, BANKED
107F0  517B     MOVF kc, W, BANKED
107F2  13C9     IORWF 0xC9, F, BANKED
196:           		mainFlags.sendComsumerKeyReport = 1;
107F4  820C     BSF 0xC, 1, ACCESS
197:           		break;
107F6  0012     RETURN 0
198:           	case KEY_MOUSE: //Mouse keys
199:           		switch (mSw[c].kc)
1089A  5184     MOVF c, W, BANKED
1089C  0D07     MULLW 0x7
1089E  0E05     MOVLW 0x5
108A0  26F3     ADDWF PROD, F, ACCESS
108A2  0E00     MOVLW 0x0
108A4  22F4     ADDWFC PRODH, F, ACCESS
108A6  0E00     MOVLW 0x0
108A8  24F3     ADDWF PROD, W, ACCESS
108AA  6ED9     MOVWF FSR2, ACCESS
108AC  0E01     MOVLW 0x1
108AE  20F4     ADDWFC PRODH, W, ACCESS
108B0  6EDA     MOVWF FSR2H, ACCESS
108B2  CFDE     MOVFF POSTINC2, multiplier
108B4  F079     NOP
108B6  CFDD     MOVFF POSTDEC2, e
108B8  F07A     NOP
108BA  517A     MOVF e, W, BANKED
108BC  0A50     XORLW 0x50
108BE  A4D8     BTFSS STATUS, 2, ACCESS
108C0  D010     BRA 0x8E2
108C2  5179     MOVF multiplier, W, BANKED
108C4  0A01     XORLW 0x1
108C6  B4D8     BTFSC STATUS, 2, ACCESS
108C8  D797     BRA 0x7F8
108CA  0A03     XORLW 0x3
108CC  B4D8     BTFSC STATUS, 2, ACCESS
108CE  D796     BRA 0x7FC
108D0  0A01     XORLW 0x1
108D2  B4D8     BTFSC STATUS, 2, ACCESS
108D4  D795     BRA 0x800
108D6  0A07     XORLW 0x7
108D8  B4D8     BTFSC STATUS, 2, ACCESS
108DA  D794     BRA 0x804
108DC  0A01     XORLW 0x1
108DE  B4D8     BTFSC STATUS, 2, ACCESS
108E0  D7B3     BRA 0x848
200:           		{
201:           		case CL_L:
202:           			mouseReport.mouseButton.bits.Left = 1;
107F8  81C2     BSF mouseReport, 0, BANKED
203:           			break;
107FA  D073     BRA 0x8E2
204:           		case CL_M:
205:           			mouseReport.mouseButton.bits.Middle = 1;
107FC  85C2     BSF mouseReport, 2, BANKED
206:           			break;
107FE  D071     BRA 0x8E2
207:           		case CL_R:
208:           			mouseReport.mouseButton.bits.Right = 1;
10800  83C2     BSF mouseReport, 1, BANKED
209:           			break;
10802  D06F     BRA 0x8E2
210:           		case M_FT:
211:           			mouseSpeed = min(mouseSpeed + 1, MOUSE_S_MAX);
10804  C0E0     MOVFF mouseSpeed, multiplier
10806  F079     NOP
10808  6B7A     CLRF e, BANKED
1080A  BF79     BTFSC multiplier, 7, BANKED
1080C  077A     DECF e, F, BANKED
1080E  0E01     MOVLW 0x1
10810  2779     ADDWF multiplier, F, BANKED
10812  0E00     MOVLW 0x0
10814  237A     ADDWFC e, F, BANKED
10816  BF7A     BTFSC e, 7, BANKED
10818  D00B     BRA 0x830
1081A  517A     MOVF e, W, BANKED
1081C  E104     BNZ 0x826
1081E  0E08     MOVLW 0x8
10820  5D79     SUBWF multiplier, W, BANKED
10822  A0D8     BTFSS STATUS, 0, ACCESS
10824  D005     BRA 0x830
10826  0E00     MOVLW 0x0
10828  6F81     MOVWF product, BANKED
1082A  0E08     MOVLW 0x8
1082C  6F80     MOVWF kc, BANKED
1082E  D009     BRA 0x842
10830  0E01     MOVLW 0x1
10832  25E0     ADDWF mouseSpeed, W, BANKED
10834  6F80     MOVWF kc, BANKED
10836  6AE8     CLRF WREG, ACCESS
10838  B0D8     BTFSC STATUS, 0, ACCESS
1083A  2AE8     INCF WREG, F, ACCESS
1083C  BFE0     BTFSC mouseSpeed, 7, BANKED
1083E  06E8     DECF WREG, F, ACCESS
10840  6F81     MOVWF product, BANKED
10842  C080     MOVFF kc, mouseSpeed
10844  F0E0     NOP
212:           			break;
10846  D04D     BRA 0x8E2
213:           		case M_SW:
214:           			mouseSpeed = max(mouseSpeed - 1, MOUSE_S_MIN);
10848  0EFF     MOVLW 0xFF
1084A  6F79     MOVWF multiplier, BANKED
1084C  0EFF     MOVLW 0xFF
1084E  6F7A     MOVWF e, BANKED
10850  C0E0     MOVFF mouseSpeed, kc
10852  F07B     NOP
10854  6B7C     CLRF sameRow, BANKED
10856  BF7B     BTFSC kc, 7, BANKED
10858  077C     DECF sameRow, F, BANKED
1085A  5179     MOVF multiplier, W, BANKED
1085C  277B     ADDWF kc, F, BANKED
1085E  517A     MOVF e, W, BANKED
10860  237C     ADDWFC sameRow, F, BANKED
10862  BF7C     BTFSC sameRow, 7, BANKED
10864  D006     BRA 0x872
10866  517C     MOVF sameRow, W, BANKED
10868  E109     BNZ 0x87C
1086A  0E04     MOVLW 0x4
1086C  5D7B     SUBWF kc, W, BANKED
1086E  B0D8     BTFSC STATUS, 0, ACCESS
10870  D005     BRA 0x87C
10872  0E00     MOVLW 0x0
10874  6F83     MOVWF 0x83, BANKED
10876  0E03     MOVLW 0x3
10878  6F82     MOVWF c, BANKED
1087A  D00C     BRA 0x894
1087C  0EFF     MOVLW 0xFF
1087E  6F79     MOVWF multiplier, BANKED
10880  0EFF     MOVLW 0xFF
10882  6F7A     MOVWF e, BANKED
10884  5179     MOVF multiplier, W, BANKED
10886  25E0     ADDWF mouseSpeed, W, BANKED
10888  6F82     MOVWF c, BANKED
1088A  0E00     MOVLW 0x0
1088C  BFE0     BTFSC mouseSpeed, 7, BANKED
1088E  0EFF     MOVLW 0xFF
10890  217A     ADDWFC e, W, BANKED
10892  6F83     MOVWF 0x83, BANKED
10894  C082     MOVFF c, mouseSpeed
10896  F0E0     NOP
215:           			break;
216:           		}
10898  D024     BRA 0x8E2
217:           		mainFlags.sendMouseReport = 1;
108E2  880C     BSF 0xC, 4, ACCESS
218:           		break;
108E4  0012     RETURN 0
219:           	case KEY_MOUSE_AXIS: //Mouse keys
220:           		mainFlags.sendMouseReport = 1;
108E6  880C     BSF 0xC, 4, ACCESS
221:           		break;
108E8  0012     RETURN 0
222:           	case KEY_SPECIAL: //Special keyboard keys
223:           		switch (mSw[c].kc)
10926  5184     MOVF c, W, BANKED
10928  0D07     MULLW 0x7
1092A  0E05     MOVLW 0x5
1092C  26F3     ADDWF PROD, F, ACCESS
1092E  0E00     MOVLW 0x0
10930  22F4     ADDWFC PRODH, F, ACCESS
10932  0E00     MOVLW 0x0
10934  24F3     ADDWF PROD, W, ACCESS
10936  6ED9     MOVWF FSR2, ACCESS
10938  0E01     MOVLW 0x1
1093A  20F4     ADDWFC PRODH, W, ACCESS
1093C  6EDA     MOVWF FSR2H, ACCESS
1093E  CFDE     MOVFF POSTINC2, multiplier
10940  F079     NOP
10942  CFDD     MOVFF POSTDEC2, e
10944  F07A     NOP
10946  517A     MOVF e, W, BANKED
10948  0AF0     XORLW 0xF0
1094A  A4D8     BTFSS STATUS, 2, ACCESS
1094C  0012     RETURN 0
1094E  5179     MOVF multiplier, W, BANKED
10950  0A00     XORLW 0x0
10952  B4D8     BTFSC STATUS, 2, ACCESS
10954  D7CA     BRA 0x8EA
10956  0A01     XORLW 0x1
10958  B4D8     BTFSC STATUS, 2, ACCESS
1095A  D7C7     BRA 0x8EA
1095C  0A03     XORLW 0x3
1095E  B4D8     BTFSC STATUS, 2, ACCESS
10960  D7C7     BRA 0x8F0
10962  0A01     XORLW 0x1
10964  B4D8     BTFSC STATUS, 2, ACCESS
10966  D7C4     BRA 0x8F0
10968  0A0E     XORLW 0xE
1096A  B4D8     BTFSC STATUS, 2, ACCESS
1096C  D7DA     BRA 0x922
1096E  0A1D     XORLW 0x1D
10970  B4D8     BTFSC STATUS, 2, ACCESS
10972  D7C8     BRA 0x904
10974  0A01     XORLW 0x1
10976  B4D8     BTFSC STATUS, 2, ACCESS
10978  D7C8     BRA 0x90A
1097A  0A03     XORLW 0x3
1097C  B4D8     BTFSC STATUS, 2, ACCESS
1097E  D7C8     BRA 0x910
10980  0A32     XORLW 0x32
10982  B4D8     BTFSC STATUS, 2, ACCESS
10984  D7CA     BRA 0x91A
10986  0A02     XORLW 0x2
10988  B4D8     BTFSC STATUS, 2, ACCESS
1098A  D7C9     BRA 0x91E
1098C  0A01     XORLW 0x1
1098E  A4D8     BTFSS STATUS, 2, ACCESS
10992  D7C1     BRA 0x916
224:           		{
225:           		case FN_L:
226:           		case FN_R:
227:           			fnEnable = 1;
108EA  0E01     MOVLW 0x1
108EC  6FCB     MOVWF fnEnable, BANKED
228:           			break;
108EE  0012     RETURN 0
229:           		case FNLL:
230:           		case FNRL:
231:           			fnEnable = 1;
108F0  0E01     MOVLW 0x1
108F2  6FCB     MOVWF fnEnable, BANKED
232:           			fnEnableLatch = !fnEnableLatch;
108F4  51CC     MOVF fnEnableLatch, W, BANKED
108F6  A4D8     BTFSS STATUS, 2, ACCESS
108F8  D002     BRA 0x8FE
108FA  0E01     MOVLW 0x1
108FC  D001     BRA 0x900
108FE  0E00     MOVLW 0x0
10900  6FCC     MOVWF fnEnableLatch, BANKED
233:           			break;
10902  0012     RETURN 0
234:           			//		case MEM1:
235:           			//		case MEM2:
236:           			//		case MEM3:
237:           		case MD_1:
238:           			keyMode = 0;
10904  0E00     MOVLW 0x0
10906  6FCD     MOVWF keyMode, BANKED
239:           			break;
10908  0012     RETURN 0
240:           		case MD_2:
241:           			keyMode = 1;
1090A  0E01     MOVLW 0x1
1090C  6FCD     MOVWF keyMode, BANKED
242:           			break;
1090E  0012     RETURN 0
243:           		case MD_3:
244:           			keyMode = 2;
10910  0E02     MOVLW 0x2
10912  6FCD     MOVWF keyMode, BANKED
245:           			break;
10914  0012     RETURN 0
246:           		case BATT:
247:           			mainFlags.showBattery = 1;
10916  8C0B     BSF mainFlags, 6, ACCESS
248:           			break;
10918  0012     RETURN 0
249:           		case CONN:
250:           			mainFlags.connectToggle = 1;
1091A  8A0B     BSF mainFlags, 5, ACCESS
251:           			break;
1091C  0012     RETURN 0
252:           		case SHDN:
253:           			mainFlags.shutdown = 1;
1091E  840B     BSF mainFlags, 2, ACCESS
254:           			break;
10920  0012     RETURN 0
255:           		case vKey:
256:           			mainFlags.sendToggleKey = 1;
10922  860C     BSF 0xC, 3, ACCESS
257:           			break;
258:           		}
10924  0012     RETURN 0
259:           		break;
260:           	}
10990  0012     RETURN 0
10992  D7C1     BRA 0x916
10994  0E00     MOVLW 0x0
10996  6F79     MOVWF multiplier, BANKED
10998  0EF0     MOVLW 0xF0
1099A  6F7A     MOVWF e, BANKED
1099C  5184     MOVF c, W, BANKED
1099E  0D07     MULLW 0x7
109A0  0E05     MOVLW 0x5
109A2  26F3     ADDWF PROD, F, ACCESS
109A4  0E00     MOVLW 0x0
109A6  22F4     ADDWFC PRODH, F, ACCESS
109A8  0E00     MOVLW 0x0
109AA  24F3     ADDWF PROD, W, ACCESS
109AC  6ED9     MOVWF FSR2, ACCESS
109AE  0E01     MOVLW 0x1
109B0  20F4     ADDWFC PRODH, W, ACCESS
109B2  6EDA     MOVWF FSR2H, ACCESS
109B4  CFDE     MOVFF POSTINC2, kc
109B6  F07B     NOP
109B8  CFDD     MOVFF POSTDEC2, sameRow
109BA  F07C     NOP
109BC  5179     MOVF multiplier, W, BANKED
109BE  177B     ANDWF kc, F, BANKED
109C0  517A     MOVF e, W, BANKED
109C2  177C     ANDWF sameRow, F, BANKED
109C4  517C     MOVF sameRow, W, BANKED
109C6  0A00     XORLW 0x0
109C8  B4D8     BTFSC STATUS, 2, ACCESS
109CA  D013     BRA 0x9F2
109CC  0A10     XORLW 0x10
109CE  B4D8     BTFSC STATUS, 2, ACCESS
109D0  D015     BRA 0x9FC
109D2  0A30     XORLW 0x30
109D4  B4D8     BTFSC STATUS, 2, ACCESS
109D6  D017     BRA 0xA06
109D8  0A10     XORLW 0x10
109DA  B4D8     BTFSC STATUS, 2, ACCESS
109DC  D019     BRA 0xA10
109DE  0A70     XORLW 0x70
109E0  B4D8     BTFSC STATUS, 2, ACCESS
109E2  D01B     BRA 0xA1A
109E4  0A10     XORLW 0x10
109E6  B4D8     BTFSC STATUS, 2, ACCESS
109E8  D01D     BRA 0xA24
109EA  0AA0     XORLW 0xA0
109EC  A4D8     BTFSS STATUS, 2, ACCESS
109EE  0012     RETURN 0
109F0  D01E     BRA 0xA2E
109F2  517B     MOVF kc, W, BANKED
109F4  0A00     XORLW 0x0
109F6  A4D8     BTFSS STATUS, 2, ACCESS
109F8  0012     RETURN 0
109FA  D63D     BRA 0x676
109FC  517B     MOVF kc, W, BANKED
109FE  0A00     XORLW 0x0
10A00  A4D8     BTFSS STATUS, 2, ACCESS
10A02  0012     RETURN 0
10A04  D640     BRA 0x686
10A06  517B     MOVF kc, W, BANKED
10A08  0A00     XORLW 0x0
10A0A  A4D8     BTFSS STATUS, 2, ACCESS
10A0C  0012     RETURN 0
10A0E  D6B7     BRA 0x77E
10A10  517B     MOVF kc, W, BANKED
10A12  0A00     XORLW 0x0
10A14  A4D8     BTFSS STATUS, 2, ACCESS
10A16  0012     RETURN 0
10A18  D6CF     BRA 0x7B8
10A1A  517B     MOVF kc, W, BANKED
10A1C  0A00     XORLW 0x0
10A1E  A4D8     BTFSS STATUS, 2, ACCESS
10A20  0012     RETURN 0
10A22  D761     BRA 0x8E6
10A24  517B     MOVF kc, W, BANKED
10A26  0A00     XORLW 0x0
10A28  A4D8     BTFSS STATUS, 2, ACCESS
10A2A  0012     RETURN 0
10A2C  D736     BRA 0x89A
10A2E  517B     MOVF kc, W, BANKED
10A30  0A00     XORLW 0x0
10A32  A4D8     BTFSS STATUS, 2, ACCESS
10A34  0012     RETURN 0
10A36  D777     BRA 0x926
261:           }
262:           
263:           void swRelease(unsigned char c)
11590  0100     MOVLB 0x0
11592  6F7E     MOVWF c, BANKED
264:           {
265:           	switch (getKeyGroup(mSw[c].kc))
11594  D08F     BRA 0x16B4
116B4  0E00     MOVLW 0x0
266:           	{
267:           	case KEY_NORMAL: //Normal keys
268:           		mainFlags.sendKeyReport = 1;
11596  840C     BSF 0xC, 2, ACCESS
269:           		break;
11598  0012     RETURN 0
270:           	case KEY_MODIFIER: //Modifier keys
271:           	case KEY_MODIFIER_LATCH: //Modifier keys
272:           		keyReport.modifier.byte &= ~(1 << (mSw[c].kc & 0x07));
1159A  517E     MOVF c, W, BANKED
1159C  0D07     MULLW 0x7
1159E  0E05     MOVLW 0x5
115A0  26F3     ADDWF PROD, F, ACCESS
115A2  0E00     MOVLW 0x0
115A4  22F4     ADDWFC PRODH, F, ACCESS
115A6  0E00     MOVLW 0x0
115A8  24F3     ADDWF PROD, W, ACCESS
115AA  6ED9     MOVWF FSR2, ACCESS
115AC  0E01     MOVLW 0x1
115AE  20F4     ADDWFC PRODH, W, ACCESS
115B0  6EDA     MOVWF FSR2H, ACCESS
115B2  50DF     MOVF INDF2, W, ACCESS
115B4  6F79     MOVWF multiplier, BANKED
115B6  0E07     MOVLW 0x7
115B8  1779     ANDWF multiplier, F, BANKED
115BA  0E01     MOVLW 0x1
115BC  6F7A     MOVWF e, BANKED
115BE  2B79     INCF multiplier, F, BANKED
115C0  D002     BRA 0x15C6
115C2  90D8     BCF STATUS, 0, ACCESS
115C4  377A     RLCF e, F, BANKED
115C6  2F79     DECFSZ multiplier, F, BANKED
115C8  D7FC     BRA 0x15C2
115CA  0100     MOVLB 0x0
115CC  517A     MOVF e, W, BANKED
115CE  0AFF     XORLW 0xFF
115D0  17B9     ANDWF 0xB9, F, BANKED
273:           		mainFlags.sendKeyReport = 1;
115D2  840C     BSF 0xC, 2, ACCESS
274:           		break;
115D4  0012     RETURN 0
275:           	case KEY_MEDIA: //Consumer report keys
276:           		consumerKey &= ~(0x01 << (unsigned char) mSw[c].kc);
115D6  517E     MOVF c, W, BANKED
115D8  0D07     MULLW 0x7
115DA  0E05     MOVLW 0x5
115DC  26F3     ADDWF PROD, F, ACCESS
115DE  0E00     MOVLW 0x0
115E0  22F4     ADDWFC PRODH, F, ACCESS
115E2  0E00     MOVLW 0x0
115E4  24F3     ADDWF PROD, W, ACCESS
115E6  6ED9     MOVWF FSR2, ACCESS
115E8  0E01     MOVLW 0x1
115EA  20F4     ADDWFC PRODH, W, ACCESS
115EC  6EDA     MOVWF FSR2H, ACCESS
115EE  50DF     MOVF INDF2, W, ACCESS
115F0  6F79     MOVWF multiplier, BANKED
115F2  0E01     MOVLW 0x1
115F4  6F7A     MOVWF e, BANKED
115F6  0E00     MOVLW 0x0
115F8  6F7B     MOVWF kc, BANKED
115FA  2B79     INCF multiplier, F, BANKED
115FC  D003     BRA 0x1604
115FE  90D8     BCF STATUS, 0, ACCESS
11600  377A     RLCF e, F, BANKED
11602  377B     RLCF kc, F, BANKED
11604  2F79     DECFSZ multiplier, F, BANKED
11606  D7FB     BRA 0x15FE
11608  0100     MOVLB 0x0
1160A  1D7A     COMF e, W, BANKED
1160C  6F7C     MOVWF sameRow, BANKED
1160E  1D7B     COMF kc, W, BANKED
11610  6F7D     MOVWF multiplicand, BANKED
11612  517C     MOVF sameRow, W, BANKED
11614  17C8     ANDWF consumerKey, F, BANKED
11616  517D     MOVF multiplicand, W, BANKED
11618  17C9     ANDWF 0xC9, F, BANKED
277:           		//		consumerKey = 0;
278:           		mainFlags.sendComsumerKeyReport = 1;
1161A  820C     BSF 0xC, 1, ACCESS
279:           		break;
1161C  0012     RETURN 0
280:           	case KEY_MOUSE: //Mouse keys
281:           		switch (mSw[c].kc)
1162A  517E     MOVF c, W, BANKED
1162C  0D07     MULLW 0x7
1162E  0E05     MOVLW 0x5
11630  26F3     ADDWF PROD, F, ACCESS
11632  0E00     MOVLW 0x0
11634  22F4     ADDWFC PRODH, F, ACCESS
11636  0E00     MOVLW 0x0
11638  24F3     ADDWF PROD, W, ACCESS
1163A  6ED9     MOVWF FSR2, ACCESS
1163C  0E01     MOVLW 0x1
1163E  20F4     ADDWFC PRODH, W, ACCESS
11640  6EDA     MOVWF FSR2H, ACCESS
11642  CFDE     MOVFF POSTINC2, multiplier
11644  F079     NOP
11646  CFDD     MOVFF POSTDEC2, e
11648  F07A     NOP
1164A  517A     MOVF e, W, BANKED
1164C  0A50     XORLW 0x50
1164E  A4D8     BTFSS STATUS, 2, ACCESS
11650  D00A     BRA 0x1666
11652  5179     MOVF multiplier, W, BANKED
11654  0A01     XORLW 0x1
11656  B4D8     BTFSC STATUS, 2, ACCESS
11658  D7E2     BRA 0x161E
1165A  0A03     XORLW 0x3
1165C  B4D8     BTFSC STATUS, 2, ACCESS
1165E  D7E1     BRA 0x1622
11660  0A01     XORLW 0x1
11662  B4D8     BTFSC STATUS, 2, ACCESS
11664  D7E0     BRA 0x1626
282:           		{
283:           		case CL_L:
284:           			mouseReport.mouseButton.bits.Left = 0;
1161E  91C2     BCF mouseReport, 0, BANKED
285:           			break;
11620  D022     BRA 0x1666
286:           		case CL_M:
287:           			mouseReport.mouseButton.bits.Middle = 0;
11622  95C2     BCF mouseReport, 2, BANKED
288:           			break;
11624  D020     BRA 0x1666
289:           		case CL_R:
290:           			mouseReport.mouseButton.bits.Right = 0;
11626  93C2     BCF mouseReport, 1, BANKED
291:           			break;
292:           		}
11628  D01E     BRA 0x1666
293:           		mainFlags.sendMouseReport = 1;
11666  880C     BSF 0xC, 4, ACCESS
294:           		break;
11668  0012     RETURN 0
295:           	case KEY_SPECIAL: //Special keyboard keys
296:           		switch (mSw[c].kc)
11670  517E     MOVF c, W, BANKED
11672  0D07     MULLW 0x7
11674  0E05     MOVLW 0x5
11676  26F3     ADDWF PROD, F, ACCESS
11678  0E00     MOVLW 0x0
1167A  22F4     ADDWFC PRODH, F, ACCESS
1167C  0E00     MOVLW 0x0
1167E  24F3     ADDWF PROD, W, ACCESS
11680  6ED9     MOVWF FSR2, ACCESS
11682  0E01     MOVLW 0x1
11684  20F4     ADDWFC PRODH, W, ACCESS
11686  6EDA     MOVWF FSR2H, ACCESS
11688  CFDE     MOVFF POSTINC2, multiplier
1168A  F079     NOP
1168C  CFDD     MOVFF POSTDEC2, e
1168E  F07A     NOP
11690  517A     MOVF e, W, BANKED
11692  0AF0     XORLW 0xF0
11694  A4D8     BTFSS STATUS, 2, ACCESS
11696  0012     RETURN 0
11698  5179     MOVF multiplier, W, BANKED
1169A  0A00     XORLW 0x0
1169C  B4D8     BTFSC STATUS, 2, ACCESS
1169E  D7E5     BRA 0x166A
116A0  0A01     XORLW 0x1
116A2  B4D8     BTFSC STATUS, 2, ACCESS
116A4  D7E2     BRA 0x166A
116A6  0A03     XORLW 0x3
116A8  B4D8     BTFSC STATUS, 2, ACCESS
116AA  D7DF     BRA 0x166A
116AC  0A01     XORLW 0x1
116AE  A4D8     BTFSS STATUS, 2, ACCESS
116B2  D7DB     BRA 0x166A
297:           		{
298:           		case FN_L:
299:           		case FN_R:
300:           		case FNLL:
301:           		case FNRL:
302:           			fnEnable = 0;
1166A  0E00     MOVLW 0x0
1166C  6FCB     MOVWF fnEnable, BANKED
303:           			break;
304:           		}
1166E  0012     RETURN 0
305:           		break;
306:           	}
116B0  0012     RETURN 0
116B2  D7DB     BRA 0x166A
116B4  0E00     MOVLW 0x0
116B6  0100     MOVLB 0x0
116B8  6F79     MOVWF multiplier, BANKED
116BA  0EF0     MOVLW 0xF0
116BC  6F7A     MOVWF e, BANKED
116BE  517E     MOVF c, W, BANKED
116C0  0D07     MULLW 0x7
116C2  0E05     MOVLW 0x5
116C4  26F3     ADDWF PROD, F, ACCESS
116C6  0E00     MOVLW 0x0
116C8  22F4     ADDWFC PRODH, F, ACCESS
116CA  0E00     MOVLW 0x0
116CC  24F3     ADDWF PROD, W, ACCESS
116CE  6ED9     MOVWF FSR2, ACCESS
116D0  0E01     MOVLW 0x1
116D2  20F4     ADDWFC PRODH, W, ACCESS
116D4  6EDA     MOVWF FSR2H, ACCESS
116D6  CFDE     MOVFF POSTINC2, kc
116D8  F07B     NOP
116DA  CFDD     MOVFF POSTDEC2, sameRow
116DC  F07C     NOP
116DE  5179     MOVF multiplier, W, BANKED
116E0  177B     ANDWF kc, F, BANKED
116E2  517A     MOVF e, W, BANKED
116E4  177C     ANDWF sameRow, F, BANKED
116E6  517C     MOVF sameRow, W, BANKED
116E8  0A00     XORLW 0x0
116EA  B4D8     BTFSC STATUS, 2, ACCESS
116EC  D010     BRA 0x170E
116EE  0A10     XORLW 0x10
116F0  B4D8     BTFSC STATUS, 2, ACCESS
116F2  D012     BRA 0x1718
116F4  0A30     XORLW 0x30
116F6  B4D8     BTFSC STATUS, 2, ACCESS
116F8  D00F     BRA 0x1718
116FA  0A10     XORLW 0x10
116FC  B4D8     BTFSC STATUS, 2, ACCESS
116FE  D011     BRA 0x1722
11700  0A60     XORLW 0x60
11702  B4D8     BTFSC STATUS, 2, ACCESS
11704  D013     BRA 0x172C
11706  0AA0     XORLW 0xA0
11708  A4D8     BTFSS STATUS, 2, ACCESS
1170A  0012     RETURN 0
1170C  D014     BRA 0x1736
1170E  517B     MOVF kc, W, BANKED
11710  0A00     XORLW 0x0
11712  A4D8     BTFSS STATUS, 2, ACCESS
11714  0012     RETURN 0
11716  D73F     BRA 0x1596
11718  517B     MOVF kc, W, BANKED
1171A  0A00     XORLW 0x0
1171C  A4D8     BTFSS STATUS, 2, ACCESS
1171E  0012     RETURN 0
11720  D73C     BRA 0x159A
11722  517B     MOVF kc, W, BANKED
11724  0A00     XORLW 0x0
11726  A4D8     BTFSS STATUS, 2, ACCESS
11728  0012     RETURN 0
1172A  D755     BRA 0x15D6
1172C  517B     MOVF kc, W, BANKED
1172E  0A00     XORLW 0x0
11730  A4D8     BTFSS STATUS, 2, ACCESS
11732  0012     RETURN 0
11734  D77A     BRA 0x162A
11736  517B     MOVF kc, W, BANKED
11738  0A00     XORLW 0x0
1173A  A4D8     BTFSS STATUS, 2, ACCESS
1173C  0012     RETURN 0
1173E  D798     BRA 0x1670
307:           }
308:           
309:           void setScanCodes(void)
310:           {
311:           	unsigned char c = firstPush;
1183E  C0DF     MOVFF firstPush, multiplicand
11840  F07D     NOP
312:           	unsigned char d = 0;
11842  0E00     MOVLW 0x0
11844  0100     MOVLB 0x0
11846  6F7E     MOVWF c, BANKED
313:           
314:           	keyReport.modifier2delay.byte = keyReport.modifier2.byte;
11848  C0BA     MOVFF 0xBA, 0xBB
1184A  F0BB     NOP
315:           	keyReport.modifier2.byte = 0;
1184C  0E00     MOVLW 0x0
1184E  6FBA     MOVWF 0xBA, BANKED
316:           
317:           	while (c != 0xff)
11850  D056     BRA 0x18FE
318:           	{
319:           		if (mSw[c].state)
11852  517D     MOVF multiplicand, W, BANKED
11854  0D07     MULLW 0x7
11856  0E01     MOVLW 0x1
11858  26F3     ADDWF PROD, F, ACCESS
1185A  0E00     MOVLW 0x0
1185C  22F4     ADDWFC PRODH, F, ACCESS
1185E  0E00     MOVLW 0x0
11860  24F3     ADDWF PROD, W, ACCESS
11862  6ED9     MOVWF FSR2, ACCESS
11864  0E01     MOVLW 0x1
11866  20F4     ADDWFC PRODH, W, ACCESS
11868  6EDA     MOVWF FSR2H, ACCESS
1186A  50DF     MOVF INDF2, W, ACCESS
1186C  B4D8     BTFSC STATUS, 2, ACCESS
1186E  D039     BRA 0x18E2
320:           		{
321:           			unsigned short kc =mSw[c].kc;// getKeyCode(mSw[c].num);
11870  517D     MOVF multiplicand, W, BANKED
11872  0D07     MULLW 0x7
11874  0E05     MOVLW 0x5
11876  26F3     ADDWF PROD, F, ACCESS
11878  0E00     MOVLW 0x0
1187A  22F4     ADDWFC PRODH, F, ACCESS
1187C  0E00     MOVLW 0x0
1187E  24F3     ADDWF PROD, W, ACCESS
11880  6ED9     MOVWF FSR2, ACCESS
11882  0E01     MOVLW 0x1
11884  20F4     ADDWFC PRODH, W, ACCESS
11886  6EDA     MOVWF FSR2H, ACCESS
11888  CFDE     MOVFF POSTINC2, kc
1188A  F07B     NOP
1188C  CFDD     MOVFF POSTDEC2, sameRow
1188E  F07C     NOP
322:           
323:           			if (getKeyGroup(kc) == KEY_NORMAL)
11890  0EF0     MOVLW 0xF0
11892  157C     ANDWF sameRow, W, BANKED
11894  A4D8     BTFSS STATUS, 2, ACCESS
11896  D025     BRA 0x18E2
324:           			{
325:           				if (d < 6)
11898  0E06     MOVLW 0x6
1189A  617E     CPFSLT c, BANKED
1189C  D022     BRA 0x18E2
326:           				{
327:           					for (unsigned char e = 0; e < d; e++)
1189E  0E00     MOVLW 0x0
118A0  6F7A     MOVWF e, BANKED
118A2  D00D     BRA 0x18BE
118BC  2B7A     INCF e, F, BANKED
118BE  517E     MOVF c, W, BANKED
118C0  5D7A     SUBWF e, W, BANKED
118C2  A0D8     BTFSS STATUS, 0, ACCESS
118C4  D7EF     BRA 0x18A4
328:           					{
329:           						if (keyReport.scanCodes[e] == (unsigned char) kc)
118A4  517A     MOVF e, W, BANKED
118A6  0D01     MULLW 0x1
118A8  0EBC     MOVLW 0xBC
118AA  24F3     ADDWF PROD, W, ACCESS
118AC  6ED9     MOVWF FSR2, ACCESS
118AE  0E00     MOVLW 0x0
118B0  20F4     ADDWFC PRODH, W, ACCESS
118B2  6EDA     MOVWF FSR2H, ACCESS
118B4  517B     MOVF kc, W, BANKED
118B6  18DE     XORWF POSTINC2, W, ACCESS
118B8  B4D8     BTFSC STATUS, 2, ACCESS
118BA  D013     BRA 0x18E2
330:           						{
331:           							//Same key is already pushed.
332:           							//And "Modifiers + A" is canceled when 'A' is pushing because it will not works.
333:           							goto cancel;
334:           						}
335:           					}
336:           
337:           					keyReport.modifier2.byte |= (kc >> 8) & 0x0f;
118C6  517C     MOVF sameRow, W, BANKED
118C8  0B0F     ANDLW 0xF
118CA  13BA     IORWF 0xBA, F, BANKED
338:           					keyReport.scanCodes[d++] = kc;
118CC  517E     MOVF c, W, BANKED
118CE  0D01     MULLW 0x1
118D0  0EBC     MOVLW 0xBC
118D2  24F3     ADDWF PROD, W, ACCESS
118D4  6ED9     MOVWF FSR2, ACCESS
118D6  0E00     MOVLW 0x0
118D8  20F4     ADDWFC PRODH, W, ACCESS
118DA  6EDA     MOVWF FSR2H, ACCESS
118DC  C07B     MOVFF kc, INDF2
118DE  FFDF     NOP
118E0  2B7E     INCF c, F, BANKED
339:           				}
340:           			}
341:           		}
342:           cancel:
343:           		c = mSw[c].next;
118E2  517D     MOVF multiplicand, W, BANKED
118E4  0D07     MULLW 0x7
118E6  0E04     MOVLW 0x4
118E8  26F3     ADDWF PROD, F, ACCESS
118EA  0E00     MOVLW 0x0
118EC  22F4     ADDWFC PRODH, F, ACCESS
118EE  0E00     MOVLW 0x0
118F0  24F3     ADDWF PROD, W, ACCESS
118F2  6ED9     MOVWF FSR2, ACCESS
118F4  0E01     MOVLW 0x1
118F6  20F4     ADDWFC PRODH, W, ACCESS
118F8  6EDA     MOVWF FSR2H, ACCESS
118FA  50DF     MOVF INDF2, W, ACCESS
118FC  6F7D     MOVWF multiplicand, BANKED
344:           	}
118FE  297D     INCF multiplicand, W, BANKED
11900  A4D8     BTFSS STATUS, 2, ACCESS
11902  D7A7     BRA 0x1852
345:           
346:           	//0 fill
347:           	for (; d < 6; d++)
11904  0E05     MOVLW 0x5
11906  657E     CPFSGT c, BANKED
11908  D001     BRA 0x190C
1190A  0012     RETURN 0
11920  2B7E     INCF c, F, BANKED
348:           	{
349:           		keyReport.scanCodes[d] = 0;
1190C  517E     MOVF c, W, BANKED
1190E  0D01     MULLW 0x1
11910  0EBC     MOVLW 0xBC
11912  24F3     ADDWF PROD, W, ACCESS
11914  6ED9     MOVWF FSR2, ACCESS
11916  0E00     MOVLW 0x0
11918  20F4     ADDWFC PRODH, W, ACCESS
1191A  6EDA     MOVWF FSR2H, ACCESS
1191C  0E00     MOVLW 0x0
1191E  6EDF     MOVWF INDF2, ACCESS
11920  2B7E     INCF c, F, BANKED
11922  D7F0     BRA 0x1904
350:           	}
351:           }
352:           
353:           void setXY(void)
354:           {
355:           	unsigned char c = lastPush;
111A0  C0DE     MOVFF lastPush, c
111A2  F082     NOP
356:           
357:           	mouseReport.X = 0;
111A4  0E00     MOVLW 0x0
111A6  0100     MOVLB 0x0
111A8  6FC3     MOVWF 0xC3, BANKED
358:           	mouseReport.Y = 0;
111AA  0E00     MOVLW 0x0
111AC  6FC4     MOVWF 0xC4, BANKED
359:           	mouseReport.W = 0;
111AE  0E00     MOVLW 0x0
111B0  6FC5     MOVWF 0xC5, BANKED
360:           
361:           	while (c != 0xff)
111B2  D108     BRA 0x13C4
362:           	{
363:           		unsigned short kc = getKeyCode(mSw[c].num);
111B4  5182     MOVF c, W, BANKED
111B6  0D07     MULLW 0x7
111B8  0E02     MOVLW 0x2
111BA  26F3     ADDWF PROD, F, ACCESS
111BC  0E00     MOVLW 0x0
111BE  22F4     ADDWFC PRODH, F, ACCESS
111C0  0E00     MOVLW 0x0
111C2  24F3     ADDWF PROD, W, ACCESS
111C4  6ED9     MOVWF FSR2, ACCESS
111C6  0E01     MOVLW 0x1
111C8  20F4     ADDWFC PRODH, W, ACCESS
111CA  6EDA     MOVWF FSR2H, ACCESS
111CC  50DF     MOVF INDF2, W, ACCESS
111CE  6F79     MOVWF multiplier, BANKED
111D0  5179     MOVF multiplier, W, BANKED
111D2  0D02     MULLW 0x2
111D4  51CD     MOVF keyMode, W, BANKED
111D6  6F7A     MOVWF e, BANKED
111D8  6B7B     CLRF kc, BANKED
111DA  90D8     BCF STATUS, 0, ACCESS
111DC  377A     RLCF e, F, BANKED
111DE  377B     RLCF kc, F, BANKED
111E0  51CB     MOVF fnEnable, W, BANKED
111E2  11CC     IORWF fnEnableLatch, W, BANKED
111E4  6F7C     MOVWF sameRow, BANKED
111E6  6B7D     CLRF multiplicand, BANKED
111E8  517A     MOVF e, W, BANKED
111EA  277C     ADDWF sameRow, F, BANKED
111EC  517B     MOVF kc, W, BANKED
111EE  237D     ADDWFC multiplicand, F, BANKED
111F0  90D8     BCF STATUS, 0, ACCESS
111F2  377C     RLCF sameRow, F, BANKED
111F4  377D     RLCF multiplicand, F, BANKED
111F6  0ED0     MOVLW 0xD0
111F8  257C     ADDWF sameRow, W, BANKED
111FA  6ED9     MOVWF FSR2, ACCESS
111FC  0E00     MOVLW 0x0
111FE  217D     ADDWFC multiplicand, W, BANKED
11200  6EDA     MOVWF FSR2H, ACCESS
11202  CFDE     MOVFF POSTINC2, c
11204  F07E     NOP
11206  CFDD     MOVFF POSTDEC2, d
11208  F07F     NOP
1120A  50F3     MOVF PROD, W, ACCESS
1120C  277E     ADDWF c, F, BANKED
1120E  50F4     MOVF PRODH, W, ACCESS
11210  237F     ADDWFC d, F, BANKED
11212  C07E     MOVFF c, TBLPTR
11214  FFF6     NOP
11216  C07F     MOVFF d, TBLPTRH
11218  FFF7     NOP
1121A  0E00     MOVLW 0x0
1121C  6EF8     MOVWF TBLPTRU, ACCESS
1121E  0009     TBLRD*+
11220  CFF5     MOVFF TABLAT, kc
11222  F080     NOP
11224  000A     TBLRD*-
11226  CFF5     MOVFF TABLAT, product
11228  F081     NOP
364:           		if (getKeyGroup(kc)==KEY_MOUSE_AXIS)
1122A  0E00     MOVLW 0x0
1122C  6F79     MOVWF multiplier, BANKED
1122E  0EF0     MOVLW 0xF0
11230  6F7A     MOVWF e, BANKED
11232  C080     MOVFF kc, kc
11234  F07B     NOP
11236  C081     MOVFF product, sameRow
11238  F07C     NOP
1123A  5179     MOVF multiplier, W, BANKED
1123C  177B     ANDWF kc, F, BANKED
1123E  517A     MOVF e, W, BANKED
11240  177C     ANDWF sameRow, F, BANKED
11242  0E40     MOVLW 0x40
11244  197C     XORWF sameRow, W, BANKED
11246  117B     IORWF kc, W, BANKED
11248  B4D8     BTFSC STATUS, 2, ACCESS
1124A  D06E     BRA 0x1328
1124C  D0AD     BRA 0x13A8
365:           		{
366:           			switch (kc)
11328  C080     MOVFF kc, multiplier
1132A  F079     NOP
1132C  C081     MOVFF product, e
1132E  F07A     NOP
11330  517A     MOVF e, W, BANKED
11332  0A40     XORLW 0x40
11334  A4D8     BTFSS STATUS, 2, ACCESS
11336  0012     RETURN 0
11338  5179     MOVF multiplier, W, BANKED
1133A  0A00     XORLW 0x0
1133C  B4D8     BTFSC STATUS, 2, ACCESS
1133E  D787     BRA 0x124E
11340  0A01     XORLW 0x1
11342  B4D8     BTFSC STATUS, 2, ACCESS
11344  D788     BRA 0x1256
11346  0A03     XORLW 0x3
11348  B4D8     BTFSC STATUS, 2, ACCESS
1134A  D788     BRA 0x125C
1134C  0A01     XORLW 0x1
1134E  B4D8     BTFSC STATUS, 2, ACCESS
11350  D789     BRA 0x1264
11352  0A07     XORLW 0x7
11354  B4D8     BTFSC STATUS, 2, ACCESS
11356  D78A     BRA 0x126C
11358  0A01     XORLW 0x1
1135A  B4D8     BTFSC STATUS, 2, ACCESS
1135C  D78C     BRA 0x1276
1135E  0A03     XORLW 0x3
11360  B4D8     BTFSC STATUS, 2, ACCESS
11362  D78E     BRA 0x1280
11364  0A01     XORLW 0x1
11366  B4D8     BTFSC STATUS, 2, ACCESS
11368  D790     BRA 0x128A
1136A  0A17     XORLW 0x17
1136C  B4D8     BTFSC STATUS, 2, ACCESS
1136E  D791     BRA 0x1292
11370  0A01     XORLW 0x1
11372  B4D8     BTFSC STATUS, 2, ACCESS
11374  D796     BRA 0x12A2
11376  0A03     XORLW 0x3
11378  B4D8     BTFSC STATUS, 2, ACCESS
1137A  D79E     BRA 0x12B8
1137C  0A01     XORLW 0x1
1137E  B4D8     BTFSC STATUS, 2, ACCESS
11380  D7A3     BRA 0x12C8
11382  0A07     XORLW 0x7
11384  B4D8     BTFSC STATUS, 2, ACCESS
11386  D7AA     BRA 0x12DC
11388  0A01     XORLW 0x1
1138A  B4D8     BTFSC STATUS, 2, ACCESS
1138C  D7AE     BRA 0x12EA
1138E  0A03     XORLW 0x3
11390  B4D8     BTFSC STATUS, 2, ACCESS
11392  D7B4     BRA 0x12FC
11394  0A01     XORLW 0x1
11396  B4D8     BTFSC STATUS, 2, ACCESS
11398  D7B8     BRA 0x130A
1139A  0AE7     XORLW 0xE7
1139C  B4D8     BTFSC STATUS, 2, ACCESS
1139E  D7BF     BRA 0x131E
113A0  0A01     XORLW 0x1
113A2  A4D8     BTFSS STATUS, 2, ACCESS
113A6  D7BE     BRA 0x1324
367:           			{
368:           			case m_UU:
369:           				mouseReport.X = 0;
1124E  0E00     MOVLW 0x0
11250  6FC3     MOVWF 0xC3, BANKED
370:           				mouseReport.Y = -1 ;
11252  69C4     SETF 0xC4, BANKED
371:           				break;
11254  0012     RETURN 0
372:           			case m_UL:
373:           				mouseReport.X = -1 ;
11256  69C3     SETF 0xC3, BANKED
374:           				mouseReport.Y = -1 ;
11258  69C4     SETF 0xC4, BANKED
375:           				break;
1125A  0012     RETURN 0
376:           			case m_LL:
377:           				mouseReport.X = -1 ;
1125C  69C3     SETF 0xC3, BANKED
378:           				mouseReport.Y = 0;
1125E  0E00     MOVLW 0x0
11260  6FC4     MOVWF 0xC4, BANKED
379:           				break;
11262  0012     RETURN 0
380:           			case m_DL:
381:           				mouseReport.X = -1 ;
11264  69C3     SETF 0xC3, BANKED
382:           				mouseReport.Y = 1 ;
11266  0E01     MOVLW 0x1
11268  6FC4     MOVWF 0xC4, BANKED
383:           				break;
1126A  0012     RETURN 0
384:           			case m_DD:
385:           				mouseReport.X = 0;
1126C  0E00     MOVLW 0x0
1126E  6FC3     MOVWF 0xC3, BANKED
386:           				mouseReport.Y = 1 ;
11270  0E01     MOVLW 0x1
11272  6FC4     MOVWF 0xC4, BANKED
387:           				break;
11274  0012     RETURN 0
388:           			case m_DR:
389:           				mouseReport.X = 1 ;
11276  0E01     MOVLW 0x1
11278  6FC3     MOVWF 0xC3, BANKED
390:           				mouseReport.Y = 1 ;
1127A  0E01     MOVLW 0x1
1127C  6FC4     MOVWF 0xC4, BANKED
391:           				break;
1127E  0012     RETURN 0
392:           			case m_RR:
393:           				mouseReport.X = 1 ;
11280  0E01     MOVLW 0x1
11282  6FC3     MOVWF 0xC3, BANKED
394:           				mouseReport.Y = 0;
11284  0E00     MOVLW 0x0
11286  6FC4     MOVWF 0xC4, BANKED
395:           				break;
11288  0012     RETURN 0
396:           			case m_UR:
397:           				mouseReport.X = 1 ;
1128A  0E01     MOVLW 0x1
1128C  6FC3     MOVWF 0xC3, BANKED
398:           				mouseReport.Y = -1 ;
1128E  69C4     SETF 0xC4, BANKED
399:           				break;
11290  0012     RETURN 0
400:           			case M_UU:
401:           				mouseReport.X = 0;
11292  0E00     MOVLW 0x0
11294  6FC3     MOVWF 0xC3, BANKED
402:           				mouseReport.Y = -1 *  mouseSpeed;
11296  51E0     MOVF mouseSpeed, W, BANKED
11298  0D01     MULLW 0x1
1129A  50F3     MOVF PROD, W, ACCESS
1129C  0800     SUBLW 0x0
1129E  6FC4     MOVWF 0xC4, BANKED
403:           				break;
112A0  0012     RETURN 0
404:           			case M_UL:
405:           				mouseReport.X = -1 *  mouseSpeed;
112A2  51E0     MOVF mouseSpeed, W, BANKED
112A4  0D01     MULLW 0x1
112A6  50F3     MOVF PROD, W, ACCESS
112A8  0800     SUBLW 0x0
112AA  6FC3     MOVWF 0xC3, BANKED
406:           				mouseReport.Y = -1 *  mouseSpeed;
112AC  51E0     MOVF mouseSpeed, W, BANKED
112AE  0D01     MULLW 0x1
112B0  50F3     MOVF PROD, W, ACCESS
112B2  0800     SUBLW 0x0
112B4  6FC4     MOVWF 0xC4, BANKED
407:           				break;
112B6  0012     RETURN 0
408:           			case M_LL:
409:           				mouseReport.X = -1 *  mouseSpeed;
112B8  51E0     MOVF mouseSpeed, W, BANKED
112BA  0D01     MULLW 0x1
112BC  50F3     MOVF PROD, W, ACCESS
112BE  0800     SUBLW 0x0
112C0  6FC3     MOVWF 0xC3, BANKED
410:           				mouseReport.Y = 0;
112C2  0E00     MOVLW 0x0
112C4  6FC4     MOVWF 0xC4, BANKED
411:           				break;
112C6  0012     RETURN 0
412:           			case M_DL:
413:           				mouseReport.X = -1 *  mouseSpeed;
112C8  51E0     MOVF mouseSpeed, W, BANKED
112CA  0D01     MULLW 0x1
112CC  50F3     MOVF PROD, W, ACCESS
112CE  0800     SUBLW 0x0
112D0  6FC3     MOVWF 0xC3, BANKED
414:           				mouseReport.Y = 1 *  mouseSpeed;
112D2  51E0     MOVF mouseSpeed, W, BANKED
112D4  0D01     MULLW 0x1
112D6  CFF3     MOVFF PROD, 0xC4
112D8  F0C4     NOP
415:           				break;
112DA  0012     RETURN 0
416:           			case M_DD:
417:           				mouseReport.X = 0;
112DC  0E00     MOVLW 0x0
112DE  6FC3     MOVWF 0xC3, BANKED
418:           				mouseReport.Y = 1 *  mouseSpeed;
112E0  51E0     MOVF mouseSpeed, W, BANKED
112E2  0D01     MULLW 0x1
112E4  CFF3     MOVFF PROD, 0xC4
112E6  F0C4     NOP
419:           				break;
112E8  0012     RETURN 0
420:           			case M_DR:
421:           				mouseReport.X = 1 *  mouseSpeed;
112EA  51E0     MOVF mouseSpeed, W, BANKED
112EC  0D01     MULLW 0x1
112EE  CFF3     MOVFF PROD, 0xC3
112F0  F0C3     NOP
422:           				mouseReport.Y = 1 *  mouseSpeed;
112F2  51E0     MOVF mouseSpeed, W, BANKED
112F4  0D01     MULLW 0x1
112F6  CFF3     MOVFF PROD, 0xC4
112F8  F0C4     NOP
423:           				break;
112FA  0012     RETURN 0
424:           			case M_RR:
425:           				mouseReport.X = 1 *  mouseSpeed;
112FC  51E0     MOVF mouseSpeed, W, BANKED
112FE  0D01     MULLW 0x1
11300  CFF3     MOVFF PROD, 0xC3
11302  F0C3     NOP
426:           				mouseReport.Y = 0;
11304  0E00     MOVLW 0x0
11306  6FC4     MOVWF 0xC4, BANKED
427:           				break;
11308  0012     RETURN 0
428:           			case M_UR:
429:           				mouseReport.X = 1 *  mouseSpeed;
1130A  51E0     MOVF mouseSpeed, W, BANKED
1130C  0D01     MULLW 0x1
1130E  CFF3     MOVFF PROD, 0xC3
11310  F0C3     NOP
430:           				mouseReport.Y = -1 *  mouseSpeed;
11312  51E0     MOVF mouseSpeed, W, BANKED
11314  0D01     MULLW 0x1
11316  50F3     MOVF PROD, W, ACCESS
11318  0800     SUBLW 0x0
1131A  6FC4     MOVWF 0xC4, BANKED
431:           				break;
1131C  0012     RETURN 0
432:           			case S_UP:
433:           				mouseReport.W = 1;
1131E  0E01     MOVLW 0x1
11320  6FC5     MOVWF 0xC5, BANKED
434:           				break;
11322  0012     RETURN 0
435:           			case S_DN:
436:           				mouseReport.W = -1;
11324  69C5     SETF 0xC5, BANKED
437:           				break;
438:           			}
11326  0012     RETURN 0
439:           			return;
113A4  0012     RETURN 0
440:           		}
441:           		c = mSw[c].pre;
113A8  5182     MOVF c, W, BANKED
113AA  0D07     MULLW 0x7
113AC  0E03     MOVLW 0x3
113AE  26F3     ADDWF PROD, F, ACCESS
113B0  0E00     MOVLW 0x0
113B2  22F4     ADDWFC PRODH, F, ACCESS
113B4  0E00     MOVLW 0x0
113B6  24F3     ADDWF PROD, W, ACCESS
113B8  6ED9     MOVWF FSR2, ACCESS
113BA  0E01     MOVLW 0x1
113BC  20F4     ADDWFC PRODH, W, ACCESS
113BE  6EDA     MOVWF FSR2H, ACCESS
113C0  50DF     MOVF INDF2, W, ACCESS
113C2  6F82     MOVWF c, BANKED
442:           	}
113C4  2982     INCF c, W, BANKED
113C6  B4D8     BTFSC STATUS, 2, ACCESS
113C8  0012     RETURN 0
113CA  D6F4     BRA 0x11B4
443:           }
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/interrupts.c  -------------------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             
6:             #include <stdint.h>         /* For uint8_t definition */
7:             #include <stdbool.h>        /* For true/false definition */
8:             #include <string.h>
9:             #include "eusart2.h"
10:            #include "eusart5.h"
11:            #include "user.h"
12:            #include "main.h"
13:            #include "FT230X.h"
14:            #include "RN42.h"
15:            #include "keys.h"
16:            #include "swMatrix.h"
17:            #include "ringBuffer.h"
18:            
19:            static const unsigned char connectedString[] = "-CONNECT,";
20:            unsigned char connectedStringIndex = 0;
21:            
22:            /******************************************************************************/
23:            /* Interrupt Routines                                                         */
24:            /******************************************************************************/
25:            
26:            /* High-priority service */
27:            void interrupt high_isr(void)
0808  8241     BSF btemp, 1, ACCESS
10D0C  CFFA     MOVFF PCLATH, 0x2B
28:            {
29:            	//	static unsigned short UsbHostCount = 0;
30:            	if (PIR5bits.TMR1IF)
10D54  010E     MOVLB 0xE
31:            	{
32:            		//500k / 256 = 1953.125Hz
33:            		TMR1H = 255;
10D5A  68CE     SETF TMR1H, ACCESS
34:            		PIR5bits.TMR1IF = 0;
10D5C  9138     BCF 0x38, 0, BANKED
35:            
36:            
37:            		//LEDs
38:            		ledMatrixProcess();
10D5E  ECF3     CALL 0x11BE6, 0
39:            
40:            		//
41:            		time++;
10D62  0E01     MOVLW 0x1
42:            
43:            		if (!(time & 0xffff))
10D6E  0EFF     MOVLW 0xFF
44:            		{
45:            			mainFlags.cycle33s = 1;
10D90  8E0B     BSF mainFlags, 7, ACCESS
46:            		}
47:            		if (!(time & 0x3ff))
10D92  0EFF     MOVLW 0xFF
48:            		{
49:            			mainFlags.cycle052s = 1;
10DB4  800C     BSF 0xC, 0, ACCESS
50:            		}
51:            
52:            		if (USB_SLEEP)
10DB6  BE8E     BTFSC PORTF, 7, ACCESS
53:            		{
54:            			if (sleepCountDown)
10DBA  5001     MOVF sleepCountDown, W, ACCESS
55:            			{
56:            				sleepCountDown--;
10DC6  0601     DECF sleepCountDown, F, ACCESS
57:            			}
10DD0  D0A0     BRA 0xF12
58:            			else
59:            			{
60:            				mainFlags.shutdown = 1;
10DD2  840B     BSF mainFlags, 2, ACCESS
61:            			}
62:            		}
63:            	}
10DD4  D09E     BRA 0xF12
64:            	else if (PIR3bits.RC2IF)
10DD6  AF36     BTFSS 0x36, 7, BANKED
65:            	{
66:            		BT_SetReady(0);
10DDA  9486     BCF TRISF, 2, ACCESS
67:            		if (RC2STAbits.OERR || RC2STAbits.FERR)
10DDC  B3F5     BTFSC 0xF5, 1, BANKED
68:            		{
69:            			//			Reset();
70:            			EUSART2_Read();
10DE4  ECE2     CALL 0x127C4, 0
71:            			RC2STAbits.CREN = 0;
10DE8  010E     MOVLB 0xE
72:            			RC2STAbits.CREN = 1;
10DEC  89F5     BSF 0xF5, 4, BANKED
73:            			BT_SetReady(1);
10DEE  D045     BRA 0xE7A
74:            		}
75:            		else
76:            		{
77:            			unsigned char c = EUSART2_Read();
10DF0  ECE2     CALL 0x127C4, 0
78:            
79:            			bufWriteIntH(&bufU5_intH, c);
10DF6  0E1D     MOVLW 0x1D
80:            
81:            			//Check BT connect string
82:            			if (c == connectedString[0])
10E06  0EE3     MOVLW 0xE3
83:            			{
84:            				connectedStringIndex = 1;
10E1C  0E01     MOVLW 0x1
85:            			}
86:            			else if (c == connectedString[connectedStringIndex])
10E20  5010     MOVF connectedStringIndex, W, ACCESS
87:            			{
88:            				connectedStringIndex++;
10E40  2A10     INCF connectedStringIndex, F, ACCESS
89:            				if (connectedStringIndex == strlen(connectedString))
10E42  0EE3     MOVLW 0xE3
90:            				{
91:            					connectedStringIndex = 0;
10E62  0E00     MOVLW 0x0
92:            					mainFlags.connected = 1;
10E66  880B     BSF mainFlags, 4, ACCESS
93:            				}
94:            			}
10E68  D002     BRA 0xE6E
95:            			else
96:            			{
97:            				connectedStringIndex = 0;
10E6A  0E00     MOVLW 0x0
98:            			}
99:            			outputReportReceived = 1;
10E6E  0E01     MOVLW 0x1
100:           
101:           			if (!PIR3bits.RC2IF)
10E74  010E     MOVLB 0xE
102:           			{
103:           				BT_SetReady(1);
10E7A  8486     BSF TRISF, 2, ACCESS
104:           			}
105:           		}
106:           	}
10E7C  D04A     BRA 0xF12
107:           	else if (PIR4bits.RC5IF)
10E7E  AB37     BTFSS 0x37, 5, BANKED
108:           	{
109:           		USB_SetReady(0);
10E82  907E     BCF LATF, 0, ACCESS
110:           		if (RC5STAbits.OERR || RC5STAbits.FERR)
10E84  B3E0     BTFSC mouseSpeed, 1, BANKED
111:           		{
112:           			//						Reset();
113:           			EUSART5_Read();
10E8C  ECDF     CALL 0x127BE, 0
114:           			RC5STAbits.CREN = 0;
10E90  010E     MOVLB 0xE
115:           			RC5STAbits.CREN = 1;
10E94  89E0     BSF mouseSpeed, 4, BANKED
116:           			USB_SetReady(1);
10E96  D03C     BRA 0xF10
117:           		}
118:           		else
119:           		{
120:           			unsigned char c = EUSART5_Read();
10E98  ECDF     CALL 0x127BE, 0
121:           
122:           			bufWriteIntH(&bufU5_intH, c);
10E9E  0E1D     MOVLW 0x1D
123:           
124:           			if (c == '!')
10EAE  0E21     MOVLW 0x21
125:           			{
126:           				BT_Reset(1);
10EB6  9879     BCF LATA, 4, ACCESS
127:           			}
10EB8  D029     BRA 0xF0C
128:           			else if (c == '@')
10EBA  0E40     MOVLW 0x40
129:           			{
130:           				BT_Reset(0);
10EC2  8879     BSF LATA, 4, ACCESS
131:           			}
10EC4  D023     BRA 0xF0C
132:           			else if (c == '#')
10EC6  0E23     MOVLW 0x23
133:           			{
134:           				Reset();
10ECE  00FF     RESET
135:           			}
10ED0  D01D     BRA 0xF0C
136:           			else if (c == '$')
10ED2  0E24     MOVLW 0x24
137:           			{
138:           				mainFlags.enterCommand = 1;
10EDA  860B     BSF mainFlags, 3, ACCESS
139:           			}
10EDC  D017     BRA 0xF0C
140:           			else if (c == '%')
10EDE  0E25     MOVLW 0x25
141:           			{
142:           				mainFlags.connectToggle = 1;
10EE6  8A0B     BSF mainFlags, 5, ACCESS
143:           			}
10EE8  D011     BRA 0xF0C
144:           			else if (c == '^')
10EEA  0E5E     MOVLW 0x5E
145:           			{
146:           				mainFlags.showBattery = 1;
10EF2  8C0B     BSF mainFlags, 6, ACCESS
147:           			}
10EF4  D00B     BRA 0xF0C
148:           			else if (c)
10EF6  503E     MOVF c, W, ACCESS
149:           			{
150:           				bufWriteIntH(&bufU2_intH, c);
10EFC  0E19     MOVLW 0x19
151:           			}
152:           			//			else if (c == '^')
153:           			//			{
154:           			//				//				endCommand();
155:           			//			}
156:           			//			else if (c == 0)
157:           			//			{
158:           			//			}
159:           
160:           			if (!PIR4bits.RC5IF)
10F0C  010E     MOVLB 0xE
161:           			{
162:           				USB_SetReady(1);
10F10  807E     BSF LATF, 0, ACCESS
163:           			}
164:           		}
165:           	}
166:           	else
167:           	{
168:           		/* Unhandled interrupts */
169:           	}
170:           }
10F12  C03C     MOVFF 0x3C, 0x44
171:           
172:           /* Low-priority interrupt routine */
173:           void low_priority interrupt low_isr(void)
0818  8041     BSF btemp, 0, ACCESS
081A  CFD8     MOVFF STATUS, 0x64
081C  F064     NOP
081E  CFE8     MOVFF WREG, 0x65
0820  F065     NOP
0822  CFE0     MOVFF BSR, 0x66
0824  F066     NOP
0826  CFFA     MOVFF PCLATH, 0x67
0828  F067     NOP
082A  CFFB     MOVFF PCLATU, 0x68
082C  F068     NOP
082E  CFE9     MOVFF FSR0, 0x69
0830  F069     NOP
0832  CFEA     MOVFF FSR0H, 0x6A
0834  F06A     NOP
0836  CFE1     MOVFF FSR1, 0x6B
0838  F06B     NOP
083A  CFE2     MOVFF FSR1H, 0x6C
083C  F06C     NOP
083E  CFD9     MOVFF FSR2, 0x6D
0840  F06D     NOP
0842  CFDA     MOVFF FSR2H, 0x6E
0844  F06E     NOP
0846  CFF3     MOVFF PROD, 0x6F
0848  F06F     NOP
084A  CFF4     MOVFF PRODH, 0x70
084C  F070     NOP
084E  CFF6     MOVFF TBLPTR, 0x71
0850  F071     NOP
0852  CFF7     MOVFF TBLPTRH, 0x72
0854  F072     NOP
0856  CFF8     MOVFF TBLPTRU, 0x73
0858  F073     NOP
085A  CFF5     MOVFF TABLAT, 0x74
085C  F074     NOP
085E  C041     MOVFF btemp, 0x75
0860  F075     NOP
0862  C042     MOVFF 0x42, 0x76
0864  F076     NOP
0866  C043     MOVFF 0x43, 0x77
0868  F077     NOP
086A  C044     MOVFF 0x44, 0x78
086C  F078     NOP
174:           {
175:           	if (PIR5bits.TMR3IF)
086E  010E     MOVLB 0xE
0870  A538     BTFSS 0x38, 2, BANKED
0872  D006     BRA 0x880
176:           	{
177:           		//500k / 256 / 10 = 195.3125Hz
178:           		TMR3H = 246;
0874  0EF6     MOVLW 0xF6
0876  6EC8     MOVWF TMR3H, ACCESS
179:           		PIR5bits.TMR3IF = 0;
0878  9538     BCF 0x38, 2, BANKED
180:           
181:           		sawToothWave++;
087A  0100     MOVLB 0x0
087C  2BCE     INCF sawToothWave, F, BANKED
182:           	}
087E  D054     BRA 0x928
183:           	else if (PIE3bits.TX2IE && PIR3bits.TX2IF)
0880  BD2C     BTFSC 0x2C, 6, BANKED
0882  AD36     BTFSS 0x36, 6, BANKED
0884  D01F     BRA 0x8C4
184:           	{
185:           		if (BT_Ready)
0886  B48E     BTFSC PORTF, 2, ACCESS
0888  D04F     BRA 0x928
186:           		{
187:           			if (bufDataExist(bufU2_main))SendCharBT(bufRead(&bufU2_main));
088A  5017     MOVF 0x17, W, ACCESS
088C  1818     XORWF 0x18, W, ACCESS
088E  B4D8     BTFSC STATUS, 2, ACCESS
0890  D009     BRA 0x8A4
0892  0E15     MOVLW 0x15
0894  6E3F     MOVWF txData, ACCESS
0896  0E00     MOVLW 0x0
0898  6E40     MOVWF d, ACCESS
089A  EC87     CALL 0x1230E, 0
089C  F091     NOP
089E  ECDA     CALL 0x127B4, 0
08A0  F093     NOP
08A2  D042     BRA 0x928
188:           				//			else if (bufDataExist(bufU2_intL))SendCharBT(bufRead(&bufU2_intL));
189:           			else if (bufDataExist(bufU2_intH)) SendCharBT(bufRead(&bufU2_intH));
08A4  501B     MOVF 0x1B, W, ACCESS
08A6  181C     XORWF 0x1C, W, ACCESS
08A8  B4D8     BTFSC STATUS, 2, ACCESS
08AA  D009     BRA 0x8BE
08AC  0E19     MOVLW 0x19
08AE  6E3F     MOVWF txData, ACCESS
08B0  0E00     MOVLW 0x0
08B2  6E40     MOVWF d, ACCESS
08B4  EC87     CALL 0x1230E, 0
08B6  F091     NOP
08B8  ECDA     CALL 0x127B4, 0
08BA  F093     NOP
08BC  D035     BRA 0x928
190:           			else PIE3bits.TX2IE = 0;
08BE  010E     MOVLB 0xE
08C0  9D2C     BCF 0x2C, 6, BANKED
191:           		}
192:           		//		else PIE3bits.TX2IE = 0;
193:           	}
08C2  D032     BRA 0x928
194:           	else if (PIE4bits.TX5IE && PIR4bits.TX5IF)
08C4  B92D     BTFSC 0x2D, 4, BANKED
08C6  A937     BTFSS 0x37, 4, BANKED
08C8  D02F     BRA 0x928
195:           	{
196:           		if (USB_Host)
08CA  AC8E     BTFSS PORTF, 6, ACCESS
08CC  AE8E     BTFSS PORTF, 7, ACCESS
08CE  D01E     BRA 0x90C
08D0  BA8E     BTFSC PORTF, 5, ACCESS
08D2  D01C     BRA 0x90C
197:           		{
198:           			if (USB_Ready)
08D4  A08E     BTFSS PORTF, 0, ACCESS
08D6  D028     BRA 0x928
199:           			{
200:           				if (bufDataExist(bufU5_main))SendCharUSB(bufRead(&bufU5_main));
08D8  5013     MOVF 0x13, W, ACCESS
08DA  1814     XORWF 0x14, W, ACCESS
08DC  B4D8     BTFSC STATUS, 2, ACCESS
08DE  D009     BRA 0x8F2
08E0  0E11     MOVLW 0x11
08E2  6E3F     MOVWF txData, ACCESS
08E4  0E00     MOVLW 0x0
08E6  6E40     MOVWF d, ACCESS
08E8  EC87     CALL 0x1230E, 0
08EA  F091     NOP
08EC  ECD5     CALL 0x127AA, 0
08EE  F093     NOP
08F0  D01B     BRA 0x928
201:           					//			else if (bufDataExist(bufU5_intL))SendCharUSB(bufRead(&bufU5_intL));
202:           				else if (bufDataExist(bufU5_intH))SendCharUSB(bufRead(&bufU5_intH));
08F2  501F     MOVF 0x1F, W, ACCESS
08F4  1820     XORWF 0x20, W, ACCESS
08F6  B4D8     BTFSC STATUS, 2, ACCESS
08F8  D015     BRA 0x924
08FA  0E1D     MOVLW 0x1D
08FC  6E3F     MOVWF txData, ACCESS
08FE  0E00     MOVLW 0x0
0900  6E40     MOVWF d, ACCESS
0902  EC87     CALL 0x1230E, 0
0904  F091     NOP
0906  ECD5     CALL 0x127AA, 0
0908  F093     NOP
090A  D00E     BRA 0x928
203:           				else PIE4bits.TX5IE = 0;
204:           			}
205:           		}
206:           		else
207:           		{
208:           			bufClear(&bufU5_main);
090C  0E11     MOVLW 0x11
090E  6E3F     MOVWF txData, ACCESS
0910  0E00     MOVLW 0x0
0912  6E40     MOVWF d, ACCESS
0914  ECE5     CALL 0x127CA, 0
0916  F093     NOP
209:           			bufClear(&bufU5_intH);
0918  0E1D     MOVLW 0x1D
091A  6E3F     MOVWF txData, ACCESS
091C  0E00     MOVLW 0x0
091E  6E40     MOVWF d, ACCESS
0920  ECE5     CALL 0x127CA, 0
0922  F093     NOP
210:           			PIE4bits.TX5IE = 0;
0924  010E     MOVLB 0xE
0926  992D     BCF 0x2D, 4, BANKED
211:           		}
212:           	}
213:           	else
214:           	{
215:           	}
216:           }
0928  C078     MOVFF 0x78, 0x44
092A  F044     NOP
092C  C077     MOVFF 0x77, 0x43
092E  F043     NOP
0930  C076     MOVFF 0x76, 0x42
0932  F042     NOP
0934  C075     MOVFF 0x75, btemp
0936  F041     NOP
0938  C074     MOVFF 0x74, TABLAT
093A  FFF5     NOP
093C  C073     MOVFF 0x73, TBLPTRU
093E  FFF8     NOP
0940  C072     MOVFF 0x72, TBLPTRH
0942  FFF7     NOP
0944  C071     MOVFF 0x71, TBLPTR
0946  FFF6     NOP
0948  C070     MOVFF 0x70, PRODH
094A  FFF4     NOP
094C  C06F     MOVFF 0x6F, PROD
094E  FFF3     NOP
0950  C06E     MOVFF 0x6E, FSR2H
0952  FFDA     NOP
0954  C06D     MOVFF 0x6D, FSR2
0956  FFD9     NOP
0958  C06C     MOVFF 0x6C, FSR1H
095A  FFE2     NOP
095C  C06B     MOVFF 0x6B, FSR1
095E  FFE1     NOP
0960  C06A     MOVFF 0x6A, FSR0H
0962  FFEA     NOP
0964  C069     MOVFF 0x69, FSR0
0966  FFE9     NOP
0968  C068     MOVFF 0x68, PCLATU
096A  FFFB     NOP
096C  C067     MOVFF 0x67, PCLATH
096E  FFFA     NOP
0970  C066     MOVFF 0x66, BSR
0972  FFE0     NOP
0974  C065     MOVFF 0x65, WREG
0976  FFE8     NOP
0978  C064     MOVFF 0x64, STATUS
097A  FFD8     NOP
097C  9041     BCF btemp, 0, ACCESS
097E  0010     RETFIE 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/eusart5.c  ----------------------------------
1:             /**
2:               EUSART5 Generated Driver File
3:             
4:               @Company
5:             	Microchip Technology Inc.
6:             
7:               @File Name
8:             	eusart5.c
9:             
10:              @Summary
11:            	This is the generated driver implementation file for the EUSART5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:            	This source file provides APIs for EUSART5.
15:            	Generation Information :
16:            		Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:            		Device            :  PIC18LF67K40
18:            		Driver Version    :  2.00
19:            	The generated drivers are tested against the following:
20:            		Compiler          :  XC8 1.45
21:            		MPLAB 	          :  MPLAB X 4.10
22:             */
23:            /*
24:            	(c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:            	software and any derivatives exclusively with Microchip products.
26:            
27:            	THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            	EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            	WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            	PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:            	WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:            
33:            	IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:            	INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:            	WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:            	BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:            	FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:            	ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:            	THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:            
41:            	MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:            	TERMS.
43:             */
44:            /**
45:              Section: Included Files
46:             */
47:            #include "eusart5.h"
48:            #include "keys.h"
49:            
50:            /**
51:              Section: EUSART5 APIs
52:             */
53:            void EUSART5_Initialize(void)
54:            {
55:            	// Set the EUSART5 module to the options selected in the user interface.
56:            
57:            	// ABDOVF no_overflow; SCKP Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
58:            	BAUD5CON = 0x18;
126C4  0E18     MOVLW 0x18
126C6  010E     MOVLB 0xE
126C8  6FE2     MOVWF 0xE2, BANKED
59:            
60:            	// SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
61:            	RC5STA = 0x90;
126CA  0E90     MOVLW 0x90
126CC  6FE0     MOVWF mouseSpeed, BANKED
62:            
63:            	// TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
64:            	TX5STA = 0x24;
126CE  0E24     MOVLW 0x24
126D0  6FE1     MOVWF 0xE1, BANKED
65:            
66:            	// SP5BRGL 34; 
67:            	SP5BRGL = 0x22;
126D2  0E22     MOVLW 0x22
126D4  6FDE     MOVWF lastPush, BANKED
68:            
69:            	// SP5BRGH 0; 
70:            	SP5BRGH = 0x00;
126D6  0E00     MOVLW 0x0
126D8  6FDF     MOVWF firstPush, BANKED
71:            
72:            
73:            }
126DA  0012     RETURN 0
74:            
75:            uint8_t EUSART5_Read(void)
76:            {
77:            	return RC5REG;
127BE  010E     MOVLB 0xE
127C0  51DC     MOVF volt, W, BANKED
127C2  0012     RETURN 0
78:            }
79:            
80:            void EUSART5_Write(uint8_t txData)
12782  6E3F     MOVWF txData, ACCESS
81:            {
82:            //	while (!PIR4bits.TX5IF);
83:            	while(!TXSTA5bits.TRMT);
12784  010E     MOVLB 0xE
12786  A3E1     BTFSS 0xE1, 1, BANKED
12788  D7FD     BRA 0x2784
84:            
85:            	TX5REG = txData; // Write the data byte to the USART.
1278A  C03F     MOVFF txData, TX5REG
1278C  FEDD     NOP
86:            }
1278E  0012     RETURN 0
87:            
88:            /**
89:              End of File
90:             */
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/eusart2.c  ----------------------------------
1:             /**
2:               EUSART2 Generated Driver File
3:             
4:               @Company
5:             	Microchip Technology Inc.
6:             
7:               @File Name
8:             	eusart2.c
9:             
10:              @Summary
11:            	This is the generated driver implementation file for the EUSART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:            	This source file provides APIs for EUSART2.
15:            	Generation Information :
16:            		Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:            		Device            :  PIC18LF67K40
18:            		Driver Version    :  2.00
19:            	The generated drivers are tested against the following:
20:            		Compiler          :  XC8 1.45
21:            		MPLAB 	          :  MPLAB X 4.10
22:             */
23:            /*
24:            	(c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:            	software and any derivatives exclusively with Microchip products.
26:            
27:            	THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:            	EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:            	WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:            	PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:            	WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:            
33:            	IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:            	INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:            	WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:            	BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:            	FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:            	ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:            	THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:            
41:            	MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:            	TERMS.
43:             */
44:            /**
45:              Section: Included Files
46:             */
47:            #include "eusart2.h"
48:            
49:            /**
50:              Section: EUSART2 APIs
51:             */
52:            void EUSART2_Initialize(void)
53:            {
54:            	// Set the EUSART2 module to the options selected in the user interface.
55:            
56:            	// ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
57:            	BAUD2CON = 0x08;
126DC  0E08     MOVLW 0x8
126DE  010E     MOVLB 0xE
126E0  6FF7     MOVWF 0xF7, BANKED
58:            
59:            	// SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
60:            	RC2STA = 0x90;
126E2  0E90     MOVLW 0x90
126E4  6FF5     MOVWF 0xF5, BANKED
61:            
62:            	// TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
63:            	TX2STA = 0x24;
126E6  0E24     MOVLW 0x24
126E8  6FF6     MOVWF 0xF6, BANKED
64:            
65:            	// SP2BRGL 34; 
66:            	SP2BRGL = 0x22;
126EA  0E22     MOVLW 0x22
126EC  6FF3     MOVWF 0xF3, BANKED
67:            
68:            	// SP2BRGH 0; 
69:            	SP2BRGH = 0x00;
126EE  0E00     MOVLW 0x0
126F0  6FF4     MOVWF 0xF4, BANKED
70:            
71:            
72:            }
126F2  0012     RETURN 0
73:            
74:            uint8_t EUSART2_Read(void)
75:            {
76:            	return RC2REG;
127C4  010E     MOVLB 0xE
127C6  51F1     MOVF 0xF1, W, BANKED
127C8  0012     RETURN 0
77:            }
78:            
79:            void EUSART2_Write(uint8_t txData)
12790  6E3F     MOVWF txData, ACCESS
80:            {
81:            //	while (!PIR3bits.TX2IF);
82:            	while(!TXSTA2bits.TRMT);
12792  010E     MOVLB 0xE
12794  A3F6     BTFSS 0xF6, 1, BANKED
12796  D7FD     BRA 0x2792
83:            
84:            	TX2REG = txData; // Write the data byte to the USART.
12798  C03F     MOVFF txData, TX2REG
1279A  FEF2     NOP
85:            }
0808  8241     BSF btemp, 1, ACCESS
1279C  0012     RETURN 0
86:            
87:            /**
88:              End of File
89:             */
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/adcc.c  -------------------------------------
1:             /**
2:               ADCC Generated Driver File
3:             
4:               @Company
5:             	Microchip Technology Inc.
6:             
7:               @File Name
8:             	adcc.c
9:             
10:              @Summary
11:            	This is the generated driver implementation file for the ADCC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:            	This source file provides implementations for driver APIs for ADCC.
15:            	Generation Information :
16:            		Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65
17:            		Device            :  PIC18LF67K40
18:            		Driver Version    :  2.00
19:            	The generated drivers are tested against the following:
20:            		Compiler          :  XC8 1.45
21:            		MPLAB             :  MPLAB X 4.10
22:             */
23:            
24:            /*
25:            	(c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:            	software and any derivatives exclusively with Microchip products.
27:            
28:            	THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:            	EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:            	WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:            	PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:            	WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:            	IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:            	INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:            	WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:            	BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:            	FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:            	ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:            	THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:            	MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:            	TERMS.
44:             */
45:            
46:            /**
47:              Section: Included Files
48:             */
49:            
50:            #include <xc.h>
51:            #include "adcc.h"
52:            
53:            /**
54:              Section: ADCC Module Variables
55:             */
56:            
57:            /**
58:              Section: ADCC Module APIs
59:             */
60:            
61:            void ADCC_Initialize(void)
62:            {
63:            	// set the ADCC to the options selected in the User Interface
64:            	// ADLTHL 0; 
65:            	ADLTHL = 0x00;
122C4  0E00     MOVLW 0x0
122C6  6E6A     MOVWF ADLTH, ACCESS
66:            	// ADLTHH 0; 
67:            	ADLTHH = 0x00;
122C8  0E00     MOVLW 0x0
122CA  6E6B     MOVWF ADLTHH, ACCESS
68:            	// ADUTHL 0; 
69:            	ADUTHL = 0x00;
122CC  0E00     MOVLW 0x0
122CE  6E6C     MOVWF ADUTH, ACCESS
70:            	// ADUTHH 0; 
71:            	ADUTHH = 0x00;
122D0  0E00     MOVLW 0x0
122D2  6E6D     MOVWF ADUTHH, ACCESS
72:            	// ADSTPTL 0; 
73:            	ADSTPTL = 0x00;
122D4  0E00     MOVLW 0x0
122D6  6E68     MOVWF ADSTPT, ACCESS
74:            	// ADSTPTH 0; 
75:            	ADSTPTH = 0x00;
122D8  0E00     MOVLW 0x0
122DA  6E69     MOVWF ADSTPTH, ACCESS
76:            	// ADRPT 0; 
77:            	ADRPT = 0x00;
122DC  0E00     MOVLW 0x0
122DE  6E66     MOVWF ADRPT, ACCESS
78:            	// ADPCH ANA0; 
79:            	ADPCH = 0x00;
122E0  0E00     MOVLW 0x0
122E2  010F     MOVLB 0xF
122E4  6F5F     MOVWF 0x5F, BANKED
80:            	// ADCAP Additional uC disabled; 
81:            	ADCAP = 0x00;
122E6  0E00     MOVLW 0x0
122E8  6F5D     MOVWF 0x5D, BANKED
82:            	// ADDSEN disabled; ADGPOL digital_low; ADIPEN disabled; ADPPOL VSS; 
83:            	ADCON1 = 0x00;
122EA  0E00     MOVLW 0x0
122EC  6F59     MOVWF 0x59, BANKED
84:            	// ADCRS 0; ADMD Basic_mode; ADACLR disabled; ADPSIS ADFLTR; 
85:            	ADCON2 = 0x00;
122EE  0E00     MOVLW 0x0
122F0  6F5A     MOVWF 0x5A, BANKED
86:            	// ADCALC First derivative of Single measurement; ADTMD disabled; ADSOI ADGO not cleared; 
87:            	ADCON3 = 0x00;
122F2  0E00     MOVLW 0x0
122F4  6F5B     MOVWF 0x5B, BANKED
88:            	ADACQ = 255;
122F6  695C     SETF 0x5C, BANKED
89:            	// ADAOV ACC or ADERR not Overflowed; 
90:            	ADSTAT = 0x00;
122F8  0E00     MOVLW 0x0
122FA  6E65     MOVWF ADSTAT, ACCESS
91:            	// ADNREF VSS; ADPREF FVR; 
92:            	ADREF = 0x03;
122FC  0E03     MOVLW 0x3
122FE  6F58     MOVWF 0x58, BANKED
93:            	// ADACT disabled; 
94:            	ADACT = 0x00;
12300  0E00     MOVLW 0x0
12302  6F56     MOVWF 0x56, BANKED
95:            	// ADCS FOSC/2; 
96:            	ADCLK = 0x00;
12304  0E00     MOVLW 0x0
12306  6F57     MOVWF 0x57, BANKED
97:            	// ADGO stop; ADFM right; ADON enabled; ADCONT disabled; ADCS FRC; 
98:            	ADCON0 = 0x94;
12308  0E94     MOVLW 0x94
1230A  6E60     MOVWF ADCON0, ACCESS
99:            
100:           
101:           }
1230C  0012     RETURN 0
102:           
103:           //void ADCC_StartConversion(adcc_channel_t channel)
104:           //{
105:           //	// select the A/D channel
106:           //	ADPCH = channel;
107:           //
108:           //	// Turn on the ADC module
109:           //	ADCON0bits.ADON = 1;
110:           //
111:           //	// Start the conversion
112:           //	ADCON0bits.ADGO = 1;
113:           //}
114:           //
115:           //bool ADCC_IsConversionDone()
116:           //{
117:           //	// Start the conversion
118:           //	return ((unsigned char) (!ADCON0bits.ADGO));
119:           //}
120:           //
121:           //adc_result_t ADCC_GetConversionResult(void)
122:           //{
123:           //	// Return the result
124:           //	return ((adc_result_t) ((ADRESH << 8) + ADRESL));
125:           //}
126:           
127:           adc_result_t ADCC_GetSingleConversion(adcc_channel_t channel)
12620  0100     MOVLB 0x0
12622  6F7D     MOVWF multiplicand, BANKED
128:           {
129:           	// select the A/D channel
130:           	ADPCH = channel;
12624  C07D     MOVFF multiplicand, ADPCH
12626  FF5F     NOP
131:           
132:           	// Turn on the ADC module
133:           	ADCON0bits.ADON = 1;
12628  8E60     BSF ADCON0, 7, ACCESS
134:           
135:           	//Disable the continuous mode.
136:           	ADCON0bits.ADCONT = 0;
1262A  9C60     BCF ADCON0, 6, ACCESS
137:           
138:           	// Start the conversion
139:           	ADCON0bits.ADGO = 1;
1262C  8060     BSF ADCON0, 0, ACCESS
140:           
141:           
142:           	// Wait for the conversion to finish
143:           	while (ADCON0bits.ADGO)
1262E  B060     BTFSC ADCON0, 0, ACCESS
12630  D7FE     BRA 0x262E
144:           	{
145:           	}
146:           
147:           
148:           	// Conversion finished, return the result
149:           	return ((adc_result_t) ((ADRESH << 8) + ADRESL));
12632  5064     MOVF ADRESH, W, ACCESS
12634  0100     MOVLB 0x0
12636  6F7C     MOVWF sameRow, BANKED
12638  6B7B     CLRF kc, BANKED
1263A  5063     MOVF ADRES, W, ACCESS
1263C  257B     ADDWF kc, W, BANKED
1263E  6F79     MOVWF multiplier, BANKED
12640  0E00     MOVLW 0x0
12642  217C     ADDWFC sameRow, W, BANKED
12644  6F7A     MOVWF e, BANKED
12646  0012     RETURN 0
150:           }
151:           
152:           //void ADCC_StopConversion(void)
153:           //{
154:           //	//Reset the ADGO bit.
155:           //	ADCON0bits.ADGO = 0;
156:           //}
157:           //
158:           //void ADCC_SetStopOnInterrupt(void)
159:           //{
160:           //	//Set the ADSOI bit.
161:           //	ADCON3bits.ADSOI = 1;
162:           //}
163:           //
164:           //void ADCC_DischargeSampleCapacitor(void)
165:           //{
166:           //	//Set the ADC channel to AVss.
167:           //	ADPCH = 0x3C;
168:           //}
169:           //
170:           //void ADCC_LoadAcquisitionRegister(uint8_t acquisitionValue)
171:           //{
172:           //	//Load the ADACQ register.
173:           //	ADACQ = acquisitionValue;
174:           //}
175:           //
176:           //void ADCC_SetPrechargeTime(uint8_t prechargeTime)
177:           //{
178:           //	//Load the ADPRE register.
179:           //	ADPRE = prechargeTime;
180:           //}
181:           //
182:           //void ADCC_SetRepeatCount(uint8_t repeatCount)
183:           //{
184:           //	//Load the ADRPT register.
185:           //	ADRPT = repeatCount;
186:           //}
187:           //
188:           //uint8_t ADCC_GetCurrentCountofConversions(void)
189:           //{
190:           //	//Return the contents of ADCNT register
191:           //	return ADCNT;
192:           //}
193:           //
194:           //void ADCC_ClearAccumulator(void)
195:           //{
196:           //	//Reset the ADCON2bits.ADACLR bit.
197:           //	ADCON2bits.ADACLR = 1;
198:           //}
199:           //
200:           //uint16_t ADCC_GetAccumulatorValue(void)
201:           //{
202:           //	//Return the contents of ADACCH and ADACCL registers
203:           //	return ((uint16_t) ((ADACCH << 8) + ADACCL));
204:           //}
205:           //
206:           //bool ADCC_HasAccumulatorOverflowed(void)
207:           //{
208:           //	//Return the status of ADSTATbits.ADAOV
209:           //	return ADSTATbits.ADAOV;
210:           //}
211:           //
212:           //uint16_t ADCC_GetFilterValue(void)
213:           //{
214:           //	//Return the contents of ADFLTRH and ADFLTRL registers
215:           //	return ((uint16_t) ((ADFLTRH << 8) + ADFLTRL));
216:           //}
217:           //
218:           //uint16_t ADCC_GetPreviousResult(void)
219:           //{
220:           //	//Return the contents of ADPREVH and ADPREVL registers
221:           //	return ((uint16_t) ((ADPREVH << 8) + ADPREVL));
222:           //}
223:           //
224:           //void ADCC_DefineSetPoint(uint16_t setPoint)
225:           //{
226:           //	//Sets the ADSTPTH and ADSTPTL registers
227:           //	ADSTPTH = setPoint >> 8;
228:           //	ADSTPTL = setPoint;
229:           //}
230:           //
231:           //void ADCC_SetUpperThreshold(uint16_t upperThreshold)
232:           //{
233:           //	//Sets the ADUTHH and ADUTHL registers
234:           //	ADUTHH = upperThreshold >> 8;
235:           //	ADUTHL = upperThreshold;
236:           //}
237:           //
238:           //void ADCC_SetLowerThreshold(uint16_t lowerThreshold)
239:           //{
240:           //	//Sets the ADLTHH and ADLTHL registers
241:           //	ADLTHH = lowerThreshold >> 8;
242:           //	ADLTHL = lowerThreshold;
243:           //}
244:           //
245:           //uint16_t ADCC_GetErrorCalculation(void)
246:           //{
247:           //	//Return the contents of ADERRH and ADERRL registers
248:           //	return ((uint16_t) ((ADERRH << 8) + ADERRL));
249:           //}
250:           //
251:           //void ADCC_EnableDoubleSampling(void)
252:           //{
253:           //	//Sets the ADCON1bits.ADDSEN
254:           //	ADCON1bits.ADDSEN = 1;
255:           //}
256:           //
257:           //void ADCC_EnableContinuousConversion(void)
258:           //{
259:           //	//Sets the ADCON0bits.ADCONT
260:           //	ADCON0bits.ADCONT = 1;
261:           //}
262:           //
263:           //void ADCC_DisableContinuousConversion(void)
264:           //{
265:           //	//Resets the ADCON0bits.ADCONT
266:           //	ADCON0bits.ADCONT = 0;
267:           //}
268:           //
269:           //bool ADCC_HasErrorCrossedUpperThreshold(void)
270:           //{
271:           //	//Returns the value of ADSTATbits.ADUTHR bit.
272:           //	return ADSTATbits.ADUTHR;
273:           //}
274:           //
275:           //bool ADCC_HasErrorCrossedLowerThreshold(void)
276:           //{
277:           //	//Returns the value of ADSTATbits.ADLTHR bit.
278:           //	return ADSTATbits.ADLTHR;
279:           //}
280:           //
281:           //uint8_t ADCC_GetConversionStageStatus(void)
282:           //{
283:           //	//Returns the contents of ADSTATbits.ADSTAT field.
284:           //	return ADSTATbits.ADSTAT;
285:           //}
286:           
287:           
288:           /**
289:            End of File
290:            */
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/RN42.c  -------------------------------------
1:             #include <xc.h>         /* XC8 General Include File */
2:             #include "user.h"
3:             
4:             #include "RN42.h"
5:             #include "HID_Define.h"
6:             #include "FT230X.h"
7:             #include "eusart2.h"
8:             #include "eusart5.h"
9:             #include "main.h"
10:            #include "ringBuffer.h"
11:            
12:            unsigned char BtConnected = 0;
13:            
14:            struct KeyReport keyReport;
15:            
16:            struct MouseReport mouseReport;
17:            signed char mouseSpeed = (MOUSE_S_MAX + MOUSE_S_MIN) / 2;
18:            
19:            unsigned short consumerKey = 0;
20:            unsigned short BtGPIO5LowCount = 0;
21:            
22:            unsigned char outputReportReceived = 0;
23:            
24:            void connected(void)
25:            {
26:            	while (BT_GPIO5);
1279E  B28E     BTFSC PORTF, 1, ACCESS
127A0  D7FE     BRA 0x279E
27:            	BtConnected = 1;
127A2  0E01     MOVLW 0x1
127A4  0100     MOVLB 0x0
127A6  6FCA     MOVWF BtConnected, BANKED
28:            	//	LATG6 = 1;
29:            
30:            	//	bufWrite(&bufU2_main, '-');	//DEBUG
31:            }
127A8  0012     RETURN 0
32:            
33:            inline void checkBtState(void)
34:            {
35:            	if (/*LATG7 = */!BT_GPIO5)
12736  A28E     BTFSS PORTF, 1, ACCESS
12738  0012     RETURN 0
36:            	{
37:            		//		if (!BtConnected)
38:            		//		{
39:            		//			if (++BtGPIO5LowCount > 220)
40:            		//			{
41:            		//				//Low 1.1sec
42:            		//				BtConnected = 1;
43:            		//			}
44:            		//		}
45:            	}
46:            	else
47:            	{
48:            		BtGPIO5LowCount = 0;
1273A  0E00     MOVLW 0x0
1273C  0100     MOVLB 0x0
1273E  6FC7     MOVWF 0xC7, BANKED
12740  0E00     MOVLW 0x0
12742  6FC6     MOVWF BtGPIO5LowCount, BANKED
49:            		BtConnected = 0;
12744  0E00     MOVLW 0x0
12746  6FCA     MOVWF BtConnected, BANKED
12748  0012     RETURN 0
50:            		//		LATG6 = 0;
51:            	}
52:            }
53:            
54:            void disconnect(void)
55:            {
56:            	//	bufWrite(&bufU2_main,0);
57:            	//	BT_Reset(1);
58:            //	BT_Connect(1);		//?????
59:            	waitMs(10);
12648  0E0A     MOVLW 0xA
1264A  0100     MOVLB 0x0
1264C  6F79     MOVWF multiplier, BANKED
1264E  0E00     MOVLW 0x0
12650  6F7A     MOVWF e, BANKED
12652  0E00     MOVLW 0x0
12654  6F7B     MOVWF kc, BANKED
12656  0E00     MOVLW 0x0
12658  6F7C     MOVWF sameRow, BANKED
1265A  EC11     CALL 0x12422, 0
1265C  F092     NOP
60:            	BT_Connect(0);
1265E  9279     BCF LATA, 1, ACCESS
61:            	BtConnected = 0;
12660  0E00     MOVLW 0x0
12662  0100     MOVLB 0x0
12664  6FCA     MOVWF BtConnected, BANKED
62:            	BtGPIO5LowCount = 0;
12666  0E00     MOVLW 0x0
12668  6FC7     MOVWF 0xC7, BANKED
1266A  0E00     MOVLW 0x0
1266C  6FC6     MOVWF BtGPIO5LowCount, BANKED
63:            }
1266E  0012     RETURN 0
64:            
65:            void connect(void)
66:            {
67:            	BT_Connect(0);
1268E  9279     BCF LATA, 1, ACCESS
68:            	BT_Reset(0);
12690  8879     BSF LATA, 4, ACCESS
69:            	waitMs(200);
12692  0EC8     MOVLW 0xC8
12694  0100     MOVLB 0x0
12696  6F79     MOVWF multiplier, BANKED
12698  0E00     MOVLW 0x0
1269A  6F7A     MOVWF e, BANKED
1269C  0E00     MOVLW 0x0
1269E  6F7B     MOVWF kc, BANKED
126A0  0E00     MOVLW 0x0
126A2  6F7C     MOVWF sameRow, BANKED
126A4  EC11     CALL 0x12422, 0
126A6  F092     NOP
70:            	BT_Connect(1);
126A8  8279     BSF LATA, 1, ACCESS
71:            
72:            	//	BT_Reset(1);
73:            	//	waitMs(1);
74:            	//	BT_Reset(0);
75:            	//	waitMs(5);
76:            	//	bufWrite(&bufU2_main,1);
77:            	//	//	waitMs(10);
78:            	//	//	bufWrite(&bufU2_main,'$');	//SM,2
79:            	//	//	bufWrite(&bufU2_main,'$');
80:            	//	//	bufWrite(&bufU2_main,'$');
81:            	//	//				waitMs(1100);
82:            	//	//	bufWrite(&bufU2_main,'C');
83:            	//	//				bufWrite(&bufU2_main,'F');
84:            	//	//				bufWrite(&bufU2_main,'I');
85:            	//	//		bufWrite(&bufU2_main,'\n');
86:            }
126AA  0012     RETURN 0
87:            
88:            void waitOutputReport(void)
89:            {
90:            	outputReportReceived = 0;
1239A  0E00     MOVLW 0x0
1239C  0100     MOVLB 0x0
1239E  6FCF     MOVWF outputReportReceived, BANKED
91:            	bufWrite(&bufU2_main, 0xff);
123A0  0E15     MOVLW 0x15
123A2  6F85     MOVWF b, BANKED
123A4  0E00     MOVLW 0x0
123A6  6F86     MOVWF c, BANKED
123A8  0EFF     MOVLW 0xFF
123AA  6F87     MOVWF d, BANKED
123AC  EC54     CALL 0x120A8, 0
123AE  F090     NOP
92:            	time = 0;
123B0  0E00     MOVLW 0x0
123B2  6E05     MOVWF time, ACCESS
123B4  0E00     MOVLW 0x0
123B6  6E06     MOVWF 0x6, ACCESS
123B8  0E00     MOVLW 0x0
123BA  6E07     MOVWF 0x7, ACCESS
123BC  0E00     MOVLW 0x0
123BE  6E08     MOVWF 0x8, ACCESS
93:            	while (!outputReportReceived && time < 10000);
123C0  0100     MOVLB 0x0
123C2  51CF     MOVF outputReportReceived, W, BANKED
123C4  A4D8     BTFSS STATUS, 2, ACCESS
123C6  0012     RETURN 0
123C8  5008     MOVF 0x8, W, ACCESS
123CA  1007     IORWF 0x7, W, ACCESS
123CC  E107     BNZ 0x23DC
123CE  0E10     MOVLW 0x10
123D0  5C05     SUBWF time, W, ACCESS
123D2  0E27     MOVLW 0x27
123D4  5806     SUBWFB 0x6, W, ACCESS
123D6  B0D8     BTFSC STATUS, 0, ACCESS
123D8  0012     RETURN 0
123DA  D7F2     BRA 0x23C0
94:            }
123DC  0012     RETURN 0
95:            
96:            void connectToggle(void)
97:            {
98:            	if (BtConnected)
12722  0100     MOVLB 0x0
12724  51CA     MOVF BtConnected, W, BANKED
12726  B4D8     BTFSC STATUS, 2, ACCESS
12728  D003     BRA 0x2730
99:            	{
100:           		disconnect();
1272A  EC24     CALL 0x12648, 0
1272C  F093     NOP
101:           	}
1272E  0012     RETURN 0
102:           	else
103:           	{
104:           		connect();
12730  EC47     CALL 0x1268E, 0
12732  F093     NOP
12734  0012     RETURN 0
105:           	}
106:           }
107:           
108:           void enterCommand(void)
109:           {
110:           	if (BtConnected)
12218  0100     MOVLB 0x0
1221A  51CA     MOVF BtConnected, W, BANKED
1221C  A4D8     BTFSS STATUS, 2, ACCESS
111:           	{
112:           		disconnect();
1221E  EC24     CALL 0x12648, 0
12220  F093     NOP
113:           	}
114:           				waitMs(1000);
12222  0EE8     MOVLW 0xE8
12224  0100     MOVLB 0x0
12226  6F79     MOVWF multiplier, BANKED
12228  0E03     MOVLW 0x3
1222A  6F7A     MOVWF e, BANKED
1222C  0E00     MOVLW 0x0
1222E  6F7B     MOVWF kc, BANKED
12230  0E00     MOVLW 0x0
12232  6F7C     MOVWF sameRow, BANKED
12234  EC11     CALL 0x12422, 0
12236  F092     NOP
115:           	bufWriteIntH(&bufU2_main, '$');
12238  0E15     MOVLW 0x15
1223A  0100     MOVLB 0x0
1223C  6F79     MOVWF multiplier, BANKED
1223E  0E00     MOVLW 0x0
12240  6F7A     MOVWF e, BANKED
12242  0E24     MOVLW 0x24
12244  6F7B     MOVWF kc, BANKED
12246  EC83     CALL 0x12106, 0
12248  F090     NOP
116:           	bufWriteIntH(&bufU2_main, '$');
1224A  0E15     MOVLW 0x15
1224C  0100     MOVLB 0x0
1224E  6F79     MOVWF multiplier, BANKED
12250  0E00     MOVLW 0x0
12252  6F7A     MOVWF e, BANKED
12254  0E24     MOVLW 0x24
12256  6F7B     MOVWF kc, BANKED
12258  EC83     CALL 0x12106, 0
1225A  F090     NOP
117:           	bufWriteIntH(&bufU2_main, '$');
1225C  0E15     MOVLW 0x15
1225E  0100     MOVLB 0x0
12260  6F79     MOVWF multiplier, BANKED
12262  0E00     MOVLW 0x0
12264  6F7A     MOVWF e, BANKED
12266  0E24     MOVLW 0x24
12268  6F7B     MOVWF kc, BANKED
1226A  EC83     CALL 0x12106, 0
1226C  F090     NOP
118:           }
1226E  0012     RETURN 0
119:           
120:           void sendMouse(void)
121:           {
122:           	if (BtConnected)
11C76  0100     MOVLB 0x0
11C78  51CA     MOVF BtConnected, W, BANKED
11C7A  B4D8     BTFSC STATUS, 2, ACCESS
11C7C  0012     RETURN 0
123:           	{
124:           		bufWrite(&bufU2_main, 0xfd);
11C7E  0E15     MOVLW 0x15
11C80  6F85     MOVWF b, BANKED
11C82  0E00     MOVLW 0x0
11C84  6F86     MOVWF c, BANKED
11C86  0EFD     MOVLW 0xFD
11C88  6F87     MOVWF d, BANKED
11C8A  EC54     CALL 0x120A8, 0
11C8C  F090     NOP
125:           		bufWrite(&bufU2_main, 0x05);
11C8E  0E15     MOVLW 0x15
11C90  0100     MOVLB 0x0
11C92  6F85     MOVWF b, BANKED
11C94  0E00     MOVLW 0x0
11C96  6F86     MOVWF c, BANKED
11C98  0E05     MOVLW 0x5
11C9A  6F87     MOVWF d, BANKED
11C9C  EC54     CALL 0x120A8, 0
11C9E  F090     NOP
126:           		bufWrite(&bufU2_main, 0x02);
11CA0  0E15     MOVLW 0x15
11CA2  0100     MOVLB 0x0
11CA4  6F85     MOVWF b, BANKED
11CA6  0E00     MOVLW 0x0
11CA8  6F86     MOVWF c, BANKED
11CAA  0E02     MOVLW 0x2
11CAC  6F87     MOVWF d, BANKED
11CAE  EC54     CALL 0x120A8, 0
11CB0  F090     NOP
127:           		bufWrite(&bufU2_main, mouseReport.mouseButton.byte);
11CB2  0E15     MOVLW 0x15
11CB4  0100     MOVLB 0x0
11CB6  6F85     MOVWF b, BANKED
11CB8  0E00     MOVLW 0x0
11CBA  6F86     MOVWF c, BANKED
11CBC  C0C2     MOVFF mouseReport, d
11CBE  F087     NOP
11CC0  EC54     CALL 0x120A8, 0
11CC2  F090     NOP
128:           		bufWrite(&bufU2_main, mouseReport.X);
11CC4  0E15     MOVLW 0x15
11CC6  0100     MOVLB 0x0
11CC8  6F85     MOVWF b, BANKED
11CCA  0E00     MOVLW 0x0
11CCC  6F86     MOVWF c, BANKED
11CCE  C0C3     MOVFF 0xC3, d
11CD0  F087     NOP
11CD2  EC54     CALL 0x120A8, 0
11CD4  F090     NOP
129:           		bufWrite(&bufU2_main, mouseReport.Y);
11CD6  0E15     MOVLW 0x15
11CD8  0100     MOVLB 0x0
11CDA  6F85     MOVWF b, BANKED
11CDC  0E00     MOVLW 0x0
11CDE  6F86     MOVWF c, BANKED
11CE0  C0C4     MOVFF 0xC4, d
11CE2  F087     NOP
11CE4  EC54     CALL 0x120A8, 0
11CE6  F090     NOP
130:           		bufWrite(&bufU2_main, mouseReport.W);
11CE8  0E15     MOVLW 0x15
11CEA  0100     MOVLB 0x0
11CEC  6F85     MOVWF b, BANKED
11CEE  0E00     MOVLW 0x0
11CF0  6F86     MOVWF c, BANKED
11CF2  C0C5     MOVFF 0xC5, d
11CF4  F087     NOP
11CF6  EC54     CALL 0x120A8, 0
11CF8  F090     NOP
131:           		waitOutputReport();
11CFA  ECCD     CALL 0x1239A, 0
11CFC  F091     NOP
11CFE  0012     RETURN 0
132:           	}
133:           }
134:           
135:           void sendKey(void)
136:           {
137:           	if (BtConnected)
11924  0100     MOVLB 0x0
11926  51CA     MOVF BtConnected, W, BANKED
11928  B4D8     BTFSC STATUS, 2, ACCESS
1192A  0012     RETURN 0
138:           	{
139:           		bufWrite(&bufU2_main, 0xfd);
1192C  0E15     MOVLW 0x15
1192E  6F85     MOVWF b, BANKED
11930  0E00     MOVLW 0x0
11932  6F86     MOVWF c, BANKED
11934  0EFD     MOVLW 0xFD
11936  6F87     MOVWF d, BANKED
11938  EC54     CALL 0x120A8, 0
1193A  F090     NOP
140:           		bufWrite(&bufU2_main, 0x09);
1193C  0E15     MOVLW 0x15
1193E  0100     MOVLB 0x0
11940  6F85     MOVWF b, BANKED
11942  0E00     MOVLW 0x0
11944  6F86     MOVWF c, BANKED
11946  0E09     MOVLW 0x9
11948  6F87     MOVWF d, BANKED
1194A  EC54     CALL 0x120A8, 0
1194C  F090     NOP
141:           		bufWrite(&bufU2_main, 0x01);
1194E  0E15     MOVLW 0x15
11950  0100     MOVLB 0x0
11952  6F85     MOVWF b, BANKED
11954  0E00     MOVLW 0x0
11956  6F86     MOVWF c, BANKED
11958  0E01     MOVLW 0x1
1195A  6F87     MOVWF d, BANKED
1195C  EC54     CALL 0x120A8, 0
1195E  F090     NOP
142:           		bufWrite(&bufU2_main, keyReport.modifier.byte | keyReport.modifier2.byte | keyReport.modifier2delay.byte | keyReport.modifierLatch.byte);
11960  0E15     MOVLW 0x15
11962  0100     MOVLB 0x0
11964  6F85     MOVWF b, BANKED
11966  0E00     MOVLW 0x0
11968  6F86     MOVWF c, BANKED
1196A  51B9     MOVF 0xB9, W, BANKED
1196C  11BA     IORWF 0xBA, W, BANKED
1196E  11BB     IORWF 0xBB, W, BANKED
11970  11B8     IORWF keyReport, W, BANKED
11972  6F87     MOVWF d, BANKED
11974  EC54     CALL 0x120A8, 0
11976  F090     NOP
143:           		bufWrite(&bufU2_main, 0x00);
11978  0E15     MOVLW 0x15
1197A  0100     MOVLB 0x0
1197C  6F85     MOVWF b, BANKED
1197E  0E00     MOVLW 0x0
11980  6F86     MOVWF c, BANKED
11982  0E00     MOVLW 0x0
11984  6F87     MOVWF d, BANKED
11986  EC54     CALL 0x120A8, 0
11988  F090     NOP
144:           		bufWrite(&bufU2_main, keyReport.scanCodes[0]);
1198A  0E15     MOVLW 0x15
1198C  0100     MOVLB 0x0
1198E  6F85     MOVWF b, BANKED
11990  0E00     MOVLW 0x0
11992  6F86     MOVWF c, BANKED
11994  C0BC     MOVFF 0xBC, d
11996  F087     NOP
11998  EC54     CALL 0x120A8, 0
1199A  F090     NOP
145:           		bufWrite(&bufU2_main, keyReport.scanCodes[1]);
1199C  0E15     MOVLW 0x15
1199E  0100     MOVLB 0x0
119A0  6F85     MOVWF b, BANKED
119A2  0E00     MOVLW 0x0
119A4  6F86     MOVWF c, BANKED
119A6  C0BD     MOVFF 0xBD, d
119A8  F087     NOP
119AA  EC54     CALL 0x120A8, 0
119AC  F090     NOP
146:           		bufWrite(&bufU2_main, keyReport.scanCodes[2]);
119AE  0E15     MOVLW 0x15
119B0  0100     MOVLB 0x0
119B2  6F85     MOVWF b, BANKED
119B4  0E00     MOVLW 0x0
119B6  6F86     MOVWF c, BANKED
119B8  C0BE     MOVFF 0xBE, d
119BA  F087     NOP
119BC  EC54     CALL 0x120A8, 0
119BE  F090     NOP
147:           		bufWrite(&bufU2_main, keyReport.scanCodes[3]);
119C0  0E15     MOVLW 0x15
119C2  0100     MOVLB 0x0
119C4  6F85     MOVWF b, BANKED
119C6  0E00     MOVLW 0x0
119C8  6F86     MOVWF c, BANKED
119CA  C0BF     MOVFF 0xBF, d
119CC  F087     NOP
119CE  EC54     CALL 0x120A8, 0
119D0  F090     NOP
148:           		bufWrite(&bufU2_main, keyReport.scanCodes[4]);
119D2  0E15     MOVLW 0x15
119D4  0100     MOVLB 0x0
119D6  6F85     MOVWF b, BANKED
119D8  0E00     MOVLW 0x0
119DA  6F86     MOVWF c, BANKED
119DC  C0C0     MOVFF 0xC0, d
119DE  F087     NOP
119E0  EC54     CALL 0x120A8, 0
119E2  F090     NOP
149:           		bufWrite(&bufU2_main, keyReport.scanCodes[5]);
119E4  0E15     MOVLW 0x15
119E6  0100     MOVLB 0x0
119E8  6F85     MOVWF b, BANKED
119EA  0E00     MOVLW 0x0
119EC  6F86     MOVWF c, BANKED
119EE  C0C1     MOVFF 0xC1, d
119F0  F087     NOP
119F2  EC54     CALL 0x120A8, 0
119F4  F090     NOP
150:           		waitOutputReport();
119F6  ECCD     CALL 0x1239A, 0
119F8  F091     NOP
119FA  0012     RETURN 0
151:           	}
152:           }
153:           
154:           void sendToggle(void)
155:           {
156:           	if (BtConnected)
12670  0100     MOVLB 0x0
12672  51CA     MOVF BtConnected, W, BANKED
12674  B4D8     BTFSC STATUS, 2, ACCESS
12676  0012     RETURN 0
157:           	{
158:           		bufWrite(&bufU2_main, 0x7f);
12678  0E15     MOVLW 0x15
1267A  6F85     MOVWF b, BANKED
1267C  0E00     MOVLW 0x0
1267E  6F86     MOVWF c, BANKED
12680  0E7F     MOVLW 0x7F
12682  6F87     MOVWF d, BANKED
12684  EC54     CALL 0x120A8, 0
12686  F090     NOP
159:           		waitOutputReport();
12688  ECCD     CALL 0x1239A, 0
1268A  F091     NOP
1268C  0012     RETURN 0
160:           	}
161:           }
162:           
163:           void sendConsumerReport(void)
164:           {
165:           	if (BtConnected)
12042  0100     MOVLB 0x0
12044  51CA     MOVF BtConnected, W, BANKED
12046  B4D8     BTFSC STATUS, 2, ACCESS
12048  0012     RETURN 0
166:           	{
167:           		bufWrite(&bufU2_main, 0xfd);
1204A  0E15     MOVLW 0x15
1204C  6F85     MOVWF b, BANKED
1204E  0E00     MOVLW 0x0
12050  6F86     MOVWF c, BANKED
12052  0EFD     MOVLW 0xFD
12054  6F87     MOVWF d, BANKED
12056  EC54     CALL 0x120A8, 0
12058  F090     NOP
168:           		bufWrite(&bufU2_main, 0x03);
1205A  0E15     MOVLW 0x15
1205C  0100     MOVLB 0x0
1205E  6F85     MOVWF b, BANKED
12060  0E00     MOVLW 0x0
12062  6F86     MOVWF c, BANKED
12064  0E03     MOVLW 0x3
12066  6F87     MOVWF d, BANKED
12068  EC54     CALL 0x120A8, 0
1206A  F090     NOP
169:           		bufWrite(&bufU2_main, 0x03);
1206C  0E15     MOVLW 0x15
1206E  0100     MOVLB 0x0
12070  6F85     MOVWF b, BANKED
12072  0E00     MOVLW 0x0
12074  6F86     MOVWF c, BANKED
12076  0E03     MOVLW 0x3
12078  6F87     MOVWF d, BANKED
1207A  EC54     CALL 0x120A8, 0
1207C  F090     NOP
170:           		bufWrite(&bufU2_main, consumerKey);
1207E  0E15     MOVLW 0x15
12080  0100     MOVLB 0x0
12082  6F85     MOVWF b, BANKED
12084  0E00     MOVLW 0x0
12086  6F86     MOVWF c, BANKED
12088  C0C8     MOVFF consumerKey, d
1208A  F087     NOP
1208C  EC54     CALL 0x120A8, 0
1208E  F090     NOP
171:           		bufWrite(&bufU2_main, consumerKey >> 8);
12090  0E15     MOVLW 0x15
12092  0100     MOVLB 0x0
12094  6F85     MOVWF b, BANKED
12096  0E00     MOVLW 0x0
12098  6F86     MOVWF c, BANKED
1209A  51C9     MOVF 0xC9, W, BANKED
1209C  6F87     MOVWF d, BANKED
1209E  EC54     CALL 0x120A8, 0
120A0  F090     NOP
172:           		waitOutputReport();
120A2  ECCD     CALL 0x1239A, 0
120A4  F091     NOP
120A6  0012     RETURN 0
173:           	}
174:           }
175:           
176:           void putText(unsigned char* text)
177:           {
178:           	while (*text)
179:           	{
180:           		bufWrite(&bufU2_main, *text++);
181:           	}
182:           	bufWrite(&bufU2_main, 0xff);
183:           }
184:           
185:           void SendCharBT(unsigned char d)
127B4  6E40     MOVWF d, ACCESS
186:           {
187:           	//	LATG6 = !LATG6;
188:           	EUSART2_Write(d);
127B6  5040     MOVF d, W, ACCESS
127B8  ECC8     CALL 0x12790, 0
127BA  F093     NOP
189:           }
127BC  0012     RETURN 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/FT230X.c  -----------------------------------
1:             #include <xc.h>         /* XC8 General Include File */
2:             #include "FT230X.h"
3:             #include "eusart5.h"
4:             #include "main.h"
5:             #include "ringBuffer.h"
6:             
7:             //unsigned char UsbConnected = 0;
8:             
9:             static const unsigned char hex[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
10:            
11:            void SendCharUSB(unsigned char d)
127AA  6E40     MOVWF d, ACCESS
12:            {
13:            	EUSART5_Write(d);
127AC  5040     MOVF d, W, ACCESS
127AE  ECC1     CALL 0x12782, 0
127B0  F093     NOP
14:            }
127B2  0012     RETURN 0
15:            
16:            void showText(unsigned char* text)
17:            {
18:            	while (*text)
124A6  D013     BRA 0x24CE
19:            	{
20:            		bufWrite(&bufU5_main,*text++);
124A8  0E11     MOVLW 0x11
124AA  0100     MOVLB 0x0
124AC  6F85     MOVWF b, BANKED
124AE  0E00     MOVLW 0x0
124B0  6F86     MOVWF c, BANKED
124B2  C08B     MOVFF col, TBLPTR
124B4  FFF6     NOP
124B6  C08C     MOVFF sw2, TBLPTRH
124B8  FFF7     NOP
124BA  0E00     MOVLW 0x0
124BC  6EF8     MOVWF TBLPTRU, ACCESS
124BE  0008     TBLRD*
124C0  CFF5     MOVFF TABLAT, d
124C2  F087     NOP
124C4  EC54     CALL 0x120A8, 0
124C6  F090     NOP
124C8  0100     MOVLB 0x0
124CA  4B8B     INFSNZ col, F, BANKED
124CC  2B8C     INCF sw2, F, BANKED
21:            	}
124CE  C08B     MOVFF col, TBLPTR
124D0  FFF6     NOP
124D2  C08C     MOVFF sw2, TBLPTRH
124D4  FFF7     NOP
124D6  0E00     MOVLW 0x0
124D8  6EF8     MOVWF TBLPTRU, ACCESS
124DA  0008     TBLRD*
124DC  50F5     MOVF TABLAT, W, ACCESS
124DE  0900     IORLW 0x0
124E0  B4D8     BTFSC STATUS, 2, ACCESS
124E2  0012     RETURN 0
124E4  D7E1     BRA 0x24A8
22:            }
23:            
24:            void showHex2(unsigned char n)
119FC  0100     MOVLB 0x0
119FE  6F8D     MOVWF v, BANKED
25:            {
26:            	bufWrite(&bufU5_main,'0');
11A00  0E11     MOVLW 0x11
11A02  0100     MOVLB 0x0
11A04  6F85     MOVWF b, BANKED
11A06  0E00     MOVLW 0x0
11A08  6F86     MOVWF c, BANKED
11A0A  0E30     MOVLW 0x30
11A0C  6F87     MOVWF d, BANKED
11A0E  EC54     CALL 0x120A8, 0
11A10  F090     NOP
27:            	bufWrite(&bufU5_main,'x');
11A12  0E11     MOVLW 0x11
11A14  0100     MOVLB 0x0
11A16  6F85     MOVWF b, BANKED
11A18  0E00     MOVLW 0x0
11A1A  6F86     MOVWF c, BANKED
11A1C  0E78     MOVLW 0x78
11A1E  6F87     MOVWF d, BANKED
11A20  EC54     CALL 0x120A8, 0
11A22  F090     NOP
28:            	bufWrite(&bufU5_main,hex[n / 0x10]);
11A24  0E11     MOVLW 0x11
11A26  0100     MOVLB 0x0
11A28  6F85     MOVWF b, BANKED
11A2A  0E00     MOVLW 0x0
11A2C  6F86     MOVWF c, BANKED
11A2E  C08D     MOVFF v, multiplier
11A30  F079     NOP
11A32  6B7A     CLRF e, BANKED
11A34  0E00     MOVLW 0x0
11A36  6F7C     MOVWF sameRow, BANKED
11A38  0E10     MOVLW 0x10
11A3A  6F7B     MOVWF kc, BANKED
11A3C  EC80     CALL 0x11D00, 0
11A3E  F08E     NOP
11A40  0E33     MOVLW 0x33
11A42  0100     MOVLB 0x0
11A44  2579     ADDWF multiplier, W, BANKED
11A46  6EF6     MOVWF TBLPTR, ACCESS
11A48  0EFB     MOVLW 0xFB
11A4A  217A     ADDWFC e, W, BANKED
11A4C  6EF7     MOVWF TBLPTRH, ACCESS
11A4E  6AF8     CLRF TBLPTRU, ACCESS
11A50  0E00     MOVLW 0x0
11A52  22F8     ADDWFC TBLPTRU, F, ACCESS
11A54  0008     TBLRD*
11A56  CFF5     MOVFF TABLAT, d
11A58  F087     NOP
11A5A  EC54     CALL 0x120A8, 0
11A5C  F090     NOP
29:            	bufWrite(&bufU5_main,hex[ n % 0x10]);
11A5E  0E11     MOVLW 0x11
11A60  0100     MOVLB 0x0
11A62  6F85     MOVWF b, BANKED
11A64  0E00     MOVLW 0x0
11A66  6F86     MOVWF c, BANKED
11A68  518D     MOVF v, W, BANKED
11A6A  0B0F     ANDLW 0xF
11A6C  6F8B     MOVWF col, BANKED
11A6E  6B8C     CLRF sw2, BANKED
11A70  0E33     MOVLW 0x33
11A72  258B     ADDWF col, W, BANKED
11A74  6EF6     MOVWF TBLPTR, ACCESS
11A76  0EFB     MOVLW 0xFB
11A78  218C     ADDWFC sw2, W, BANKED
11A7A  6EF7     MOVWF TBLPTRH, ACCESS
11A7C  6AF8     CLRF TBLPTRU, ACCESS
11A7E  0E00     MOVLW 0x0
11A80  22F8     ADDWFC TBLPTRU, F, ACCESS
11A82  0008     TBLRD*
11A84  CFF5     MOVFF TABLAT, d
11A86  F087     NOP
11A88  EC54     CALL 0x120A8, 0
11A8A  F090     NOP
30:            	bufWrite(&bufU5_main,',');
11A8C  0E11     MOVLW 0x11
11A8E  0100     MOVLB 0x0
11A90  6F85     MOVWF b, BANKED
11A92  0E00     MOVLW 0x0
11A94  6F86     MOVWF c, BANKED
11A96  0E2C     MOVLW 0x2C
11A98  6F87     MOVWF d, BANKED
11A9A  EC54     CALL 0x120A8, 0
11A9C  F090     NOP
31:            }
11A9E  0012     RETURN 0
32:            
33:            void showHex4(unsigned short n)
34:            {
35:            	bufWrite(&bufU5_main,'0');
36:            	bufWrite(&bufU5_main,'x');
37:            	bufWrite(&bufU5_main,hex[ n / 0x1000]);
38:            	bufWrite(&bufU5_main,hex[n / 0x100 % 0x10]);
39:            	bufWrite(&bufU5_main,hex[ n / 0x10 % 0x10]);
40:            	bufWrite(&bufU5_main,hex[ n % 0x10]);
41:            	bufWrite(&bufU5_main,',');
42:            }
43:            
44:            void showState(unsigned short v)
45:            {
46:            	showText("Vbat=");
11740  0EF9     MOVLW 0xF9
11742  0100     MOVLB 0x0
11744  6F8B     MOVWF col, BANKED
11746  0EFF     MOVLW 0xFF
11748  6F8C     MOVWF sw2, BANKED
1174A  EC53     CALL 0x124A6, 0
1174C  F092     NOP
47:            	bufWrite(&bufU5_main, '0' + v / 100);
1174E  0E11     MOVLW 0x11
11750  0100     MOVLB 0x0
11752  6F85     MOVWF b, BANKED
11754  0E00     MOVLW 0x0
11756  6F86     MOVWF c, BANKED
11758  C08D     MOVFF v, multiplier
1175A  F079     NOP
1175C  C08E     MOVFF row, e
1175E  F07A     NOP
11760  0E00     MOVLW 0x0
11762  6F7C     MOVWF sameRow, BANKED
11764  0E64     MOVLW 0x64
11766  6F7B     MOVWF kc, BANKED
11768  EC38     CALL 0x12270, 0
1176A  F091     NOP
1176C  0100     MOVLB 0x0
1176E  5179     MOVF multiplier, W, BANKED
11770  0F30     ADDLW 0x30
11772  6F87     MOVWF d, BANKED
11774  EC54     CALL 0x120A8, 0
11776  F090     NOP
48:            	bufWrite(&bufU5_main, '.');
11778  0E11     MOVLW 0x11
1177A  0100     MOVLB 0x0
1177C  6F85     MOVWF b, BANKED
1177E  0E00     MOVLW 0x0
11780  6F86     MOVWF c, BANKED
11782  0E2E     MOVLW 0x2E
11784  6F87     MOVWF d, BANKED
11786  EC54     CALL 0x120A8, 0
11788  F090     NOP
49:            	bufWrite(&bufU5_main, '0' + v / 10 % 10);
1178A  0E11     MOVLW 0x11
1178C  0100     MOVLB 0x0
1178E  6F85     MOVWF b, BANKED
11790  0E00     MOVLW 0x0
11792  6F86     MOVWF c, BANKED
11794  0E00     MOVLW 0x0
11796  6F7C     MOVWF sameRow, BANKED
11798  0E0A     MOVLW 0xA
1179A  6F7B     MOVWF kc, BANKED
1179C  C08D     MOVFF v, multiplier
1179E  F079     NOP
117A0  C08E     MOVFF row, e
117A2  F07A     NOP
117A4  EC38     CALL 0x12270, 0
117A6  F091     NOP
117A8  C079     MOVFF multiplier, kc
117AA  F080     NOP
117AC  C07A     MOVFF e, product
117AE  F081     NOP
117B0  0E00     MOVLW 0x0
117B2  0100     MOVLB 0x0
117B4  6F83     MOVWF 0x83, BANKED
117B6  0E0A     MOVLW 0xA
117B8  6F82     MOVWF c, BANKED
117BA  ECAB     CALL 0x12356, 0
117BC  F091     NOP
117BE  0100     MOVLB 0x0
117C0  5180     MOVF kc, W, BANKED
117C2  0F30     ADDLW 0x30
117C4  6F87     MOVWF d, BANKED
117C6  EC54     CALL 0x120A8, 0
117C8  F090     NOP
50:            	bufWrite(&bufU5_main, '0' + v % 10);
117CA  0E11     MOVLW 0x11
117CC  0100     MOVLB 0x0
117CE  6F85     MOVWF b, BANKED
117D0  0E00     MOVLW 0x0
117D2  6F86     MOVWF c, BANKED
117D4  C08D     MOVFF v, kc
117D6  F080     NOP
117D8  C08E     MOVFF row, product
117DA  F081     NOP
117DC  0E00     MOVLW 0x0
117DE  6F83     MOVWF 0x83, BANKED
117E0  0E0A     MOVLW 0xA
117E2  6F82     MOVWF c, BANKED
117E4  ECAB     CALL 0x12356, 0
117E6  F091     NOP
117E8  0100     MOVLB 0x0
117EA  5180     MOVF kc, W, BANKED
117EC  0F30     ADDLW 0x30
117EE  6F87     MOVWF d, BANKED
117F0  EC54     CALL 0x120A8, 0
117F2  F090     NOP
51:            	bufWrite(&bufU5_main, 'V');
117F4  0E11     MOVLW 0x11
117F6  0100     MOVLB 0x0
117F8  6F85     MOVWF b, BANKED
117FA  0E00     MOVLW 0x0
117FC  6F86     MOVWF c, BANKED
117FE  0E56     MOVLW 0x56
11800  6F87     MOVWF d, BANKED
11802  EC54     CALL 0x120A8, 0
11804  F090     NOP
52:            	bufWrite(&bufU5_main, ' ');
11806  0E11     MOVLW 0x11
11808  0100     MOVLB 0x0
1180A  6F85     MOVWF b, BANKED
1180C  0E00     MOVLW 0x0
1180E  6F86     MOVWF c, BANKED
11810  0E20     MOVLW 0x20
11812  6F87     MOVWF d, BANKED
11814  EC54     CALL 0x120A8, 0
11816  F090     NOP
53:            	bufWrite(&bufU5_main, '\r');
11818  0E11     MOVLW 0x11
1181A  0100     MOVLB 0x0
1181C  6F85     MOVWF b, BANKED
1181E  0E00     MOVLW 0x0
11820  6F86     MOVWF c, BANKED
11822  0E0D     MOVLW 0xD
11824  6F87     MOVWF d, BANKED
11826  EC54     CALL 0x120A8, 0
11828  F090     NOP
54:            	bufWrite(&bufU5_main, '\r');
1182A  0E11     MOVLW 0x11
1182C  0100     MOVLB 0x0
1182E  6F85     MOVWF b, BANKED
11830  0E00     MOVLW 0x0
11832  6F86     MOVWF c, BANKED
11834  0E0D     MOVLW 0xD
11836  6F87     MOVWF d, BANKED
11838  EC54     CALL 0x120A8, 0
1183A  F090     NOP
55:            }
1183C  0012     RETURN 0
---  C:/Users/imada/OneDrive/Documents/BTKB/Software/BTKB.X/EEPROM.c  -----------------------------------
1:             /*
2:              * File:   EEPROM.c
3:              * Author: SYSTEM
4:              *
5:              * Created on July 25, 2018, 4:07 AM
6:              */
7:             
8:             #include <xc.h>
9:             
10:            void WriteEEPROM(unsigned short address, unsigned char d)
11:            {
12:            	unsigned char GIE_t = INTCONbits.GIE;
123DE  0E00     MOVLW 0x0
123E0  BEF2     BTFSC INTCON, 7, ACCESS
123E2  0E01     MOVLW 0x1
123E4  0100     MOVLB 0x0
123E6  6F7C     MOVWF sameRow, BANKED
13:            
14:            	//Prevention of NVM table read error in interrupt (see the errata sheet)
15:            	INTCONbits.GIE = 0;
123E8  9EF2     BCF INTCON, 7, ACCESS
16:            	NVMCON1bits.NVMREG = 0b00;
123EA  0E3F     MOVLW 0x3F
123EC  1677     ANDWF NVMCON1, F, ACCESS
17:            	
18:            	NVMADR = address;
123EE  C079     MOVFF multiplier, NVMADR
123F0  FF74     NOP
123F2  C07A     MOVFF e, NVMADRH
123F4  FF75     NOP
19:            	NVMDAT = d;
123F6  C07B     MOVFF kc, NVMDAT
123F8  FF76     NOP
20:            
21:            	//write sequence
22:            	NVMCON1bits.WREN = 1;
123FA  8477     BSF NVMCON1, 2, ACCESS
23:            	asm("MOVLW 0x55");
123FC  0E55     MOVLW 0x55
24:            	asm("MOVWF NVMCON2");
123FE  6E78     MOVWF NVMCON2, ACCESS
25:            	asm("MOVLW 0xAA");
12400  0EAA     MOVLW 0xAA
26:            	asm("MOVWF NVMCON2");
12402  6E78     MOVWF NVMCON2, ACCESS
27:            	//	NVMCON2 = 0x55;
28:            	//	NVMCON2 = 0xAA;
29:            	asm("BSF NVMCON1,1");
12404  8277     BSF NVMCON1, 1, ACCESS
30:            //	NVMCON1bits.WR = 1;
31:            
32:            	while (NVMCON1bits.WR);
12406  B277     BTFSC NVMCON1, 1, ACCESS
12408  D7FE     BRA 0x2406
33:            	NVMCON1bits.WREN = 0;
1240A  9477     BCF NVMCON1, 2, ACCESS
34:            
35:            	//restore
36:            	NVMCON1bits.NVMREG = 0b10;
1240C  5077     MOVF NVMCON1, W, ACCESS
1240E  0B3F     ANDLW 0x3F
12410  0980     IORLW 0x80
12412  6E77     MOVWF NVMCON1, ACCESS
37:            	INTCONbits.GIE = GIE_t;
12414  0100     MOVLB 0x0
12416  B17C     BTFSC sameRow, 0, BANKED
12418  D002     BRA 0x241E
1241A  9EF2     BCF INTCON, 7, ACCESS
1241C  D001     BRA 0x2420
1241E  8EF2     BSF INTCON, 7, ACCESS
38:            }
12420  0012     RETURN 0
39:            
40:            unsigned char ReadEEPROM(unsigned short address)
41:            {
42:            	unsigned char GIE_t = INTCONbits.GIE;
12564  0E00     MOVLW 0x0
12566  BEF2     BTFSC INTCON, 7, ACCESS
12568  0E01     MOVLW 0x1
1256A  0100     MOVLB 0x0
1256C  6F7B     MOVWF kc, BANKED
43:            	unsigned char d;
44:            
45:            	//Prevention of NVM table read error in interrupt (see the errata sheet)
46:            	INTCONbits.GIE = 0;
1256E  9EF2     BCF INTCON, 7, ACCESS
47:            	NVMCON1bits.NVMREG = 0b00;
12570  0E3F     MOVLW 0x3F
12572  1677     ANDWF NVMCON1, F, ACCESS
48:            	
49:            	NVMADR = address;
12574  C079     MOVFF multiplier, NVMADR
12576  FF74     NOP
12578  C07A     MOVFF e, NVMADRH
1257A  FF75     NOP
50:            
51:            	//read sequence
52:            	NVMCON1bits.RD = 1;
1257C  8077     BSF NVMCON1, 0, ACCESS
53:            	d = NVMDAT;
1257E  CF76     MOVFF NVMDAT, sameRow
12580  F07C     NOP
54:            
55:            	//restore
56:            	NVMCON1bits.NVMREG = 0b10;
12582  5077     MOVF NVMCON1, W, ACCESS
12584  0B3F     ANDLW 0x3F
12586  0980     IORLW 0x80
12588  6E77     MOVWF NVMCON1, ACCESS
57:            	INTCONbits.GIE = GIE_t;
1258A  B17B     BTFSC kc, 0, BANKED
1258C  D002     BRA 0x2592
1258E  9EF2     BCF INTCON, 7, ACCESS
12590  D001     BRA 0x2594
12592  8EF2     BSF INTCON, 7, ACCESS
58:            
59:            	return d;
12594  0100     MOVLB 0x0
12596  517C     MOVF sameRow, W, BANKED
12598  0012     RETURN 0
60:            }
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/strlen.c  --------------------------------
1:             #include	<string.h>
2:             
3:             size_t
4:             strlen(const char * s)
5:             {
6:             	register const char *	cp;
7:             
8:             	cp = s;
12464  C021     MOVFF __pcstackCOMRAM, cp
12466  F025     NOP
12468  C022     MOVFF 0x22, 0x26
1246A  F026     NOP
9:             	while(*cp) {
1246C  D002     BRA 0x2472
10:            		cp++;
1246E  4A25     INFSNZ cp, F, ACCESS
12470  2A26     INCF 0x26, F, ACCESS
11:            	}
12472  C025     MOVFF cp, TBLPTR
12474  FFF6     NOP
12476  C026     MOVFF 0x26, TBLPTRH
12478  FFF7     NOP
1247A  0E00     MOVLW 0x0
1247C  6EF8     MOVWF TBLPTRU, ACCESS
1247E  0008     TBLRD*
12480  50F5     MOVF TABLAT, W, ACCESS
12482  0900     IORLW 0x0
12484  A4D8     BTFSS STATUS, 2, ACCESS
12486  D7F3     BRA 0x246E
12:            	return cp-s;
12488  C021     MOVFF __pcstackCOMRAM, d
1248A  F023     NOP
1248C  C022     MOVFF 0x22, 0x24
1248E  F024     NOP
12490  1E23     COMF d, F, ACCESS
12492  1E24     COMF 0x24, F, ACCESS
12494  4A23     INFSNZ d, F, ACCESS
12496  2A24     INCF 0x24, F, ACCESS
12498  5025     MOVF cp, W, ACCESS
1249A  2423     ADDWF d, W, ACCESS
1249C  6E21     MOVWF __pcstackCOMRAM, ACCESS
1249E  5026     MOVF 0x26, W, ACCESS
124A0  2024     ADDWFC 0x24, W, ACCESS
124A2  6E22     MOVWF 0x22, ACCESS
124A4  0012     RETURN 0
13:            }
14:            
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/lwmod.c  ---------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
12356  0100     MOVLB 0x0
12358  5182     MOVF c, W, BANKED
1235A  1183     IORWF 0x83, W, BANKED
1235C  B4D8     BTFSC STATUS, 2, ACCESS
1235E  D018     BRA 0x2390
14:            		counter = 1;
12360  0E01     MOVLW 0x1
12362  6F84     MOVWF c, BANKED
15:            		while((divisor & 0x8000) == 0) {
12364  D004     BRA 0x236E
16:            			divisor <<= 1;
12366  90D8     BCF STATUS, 0, ACCESS
12368  3782     RLCF c, F, BANKED
1236A  3783     RLCF 0x83, F, BANKED
17:            			counter++;
1236C  2B84     INCF c, F, BANKED
18:            		}
1236E  AF83     BTFSS 0x83, 7, BANKED
12370  D7FA     BRA 0x2366
19:            		do {
20:            			if(divisor <= dividend)
12372  5182     MOVF c, W, BANKED
12374  5D80     SUBWF kc, W, BANKED
12376  5183     MOVF 0x83, W, BANKED
12378  5981     SUBWFB product, W, BANKED
1237A  A0D8     BTFSS STATUS, 0, ACCESS
1237C  D004     BRA 0x2386
21:            				dividend -= divisor;
1237E  5182     MOVF c, W, BANKED
12380  5F80     SUBWF kc, F, BANKED
12382  5183     MOVF 0x83, W, BANKED
12384  5B81     SUBWFB product, F, BANKED
22:            			divisor >>= 1;
12386  90D8     BCF STATUS, 0, ACCESS
12388  3383     RRCF 0x83, F, BANKED
1238A  3382     RRCF c, F, BANKED
23:            		} while(--counter != 0);
1238C  2F84     DECFSZ c, F, BANKED
1238E  D7F1     BRA 0x2372
24:            	}
25:            	return dividend;
12390  C080     MOVFF kc, kc
12392  F080     NOP
12394  C081     MOVFF product, product
12396  F081     NOP
26:            }
12398  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/lwdiv.c  ---------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
12270  0E00     MOVLW 0x0
12272  0100     MOVLB 0x0
12274  6F7E     MOVWF c, BANKED
12276  0E00     MOVLW 0x0
12278  6F7D     MOVWF multiplicand, BANKED
15:            	if(divisor != 0) {
1227A  517B     MOVF kc, W, BANKED
1227C  117C     IORWF sameRow, W, BANKED
1227E  B4D8     BTFSC STATUS, 2, ACCESS
12280  D01C     BRA 0x22BA
16:            		counter = 1;
12282  0E01     MOVLW 0x1
12284  6F7F     MOVWF d, BANKED
17:            		while((divisor & 0x8000) == 0) {
12286  D004     BRA 0x2290
18:            			divisor <<= 1;
12288  90D8     BCF STATUS, 0, ACCESS
1228A  377B     RLCF kc, F, BANKED
1228C  377C     RLCF sameRow, F, BANKED
19:            			counter++;
1228E  2B7F     INCF d, F, BANKED
20:            		}
12290  AF7C     BTFSS sameRow, 7, BANKED
12292  D7FA     BRA 0x2288
21:            		do {
22:            			quotient <<= 1;
12294  90D8     BCF STATUS, 0, ACCESS
12296  377D     RLCF multiplicand, F, BANKED
12298  377E     RLCF c, F, BANKED
23:            			if(divisor <= dividend) {
1229A  517B     MOVF kc, W, BANKED
1229C  5D79     SUBWF multiplier, W, BANKED
1229E  517C     MOVF sameRow, W, BANKED
122A0  597A     SUBWFB e, W, BANKED
122A2  A0D8     BTFSS STATUS, 0, ACCESS
122A4  D005     BRA 0x22B0
24:            				dividend -= divisor;
122A6  517B     MOVF kc, W, BANKED
122A8  5F79     SUBWF multiplier, F, BANKED
122AA  517C     MOVF sameRow, W, BANKED
122AC  5B7A     SUBWFB e, F, BANKED
25:            				quotient |= 1;
122AE  817D     BSF multiplicand, 0, BANKED
26:            			}
27:            			divisor >>= 1;
122B0  90D8     BCF STATUS, 0, ACCESS
122B2  337C     RRCF sameRow, F, BANKED
122B4  337B     RRCF kc, F, BANKED
28:            		} while(--counter != 0);
122B6  2F7F     DECFSZ d, F, BANKED
122B8  D7ED     BRA 0x2294
29:            	}
30:            	return quotient;
122BA  C07D     MOVFF multiplicand, multiplier
122BC  F079     NOP
122BE  C07E     MOVFF c, e
122C0  F07A     NOP
31:            }
122C2  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/awdiv.c  ---------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
11D00  0E00     MOVLW 0x0
11D02  0100     MOVLB 0x0
11D04  6F7E     MOVWF c, BANKED
15:            	if(divisor < 0) {
11D06  AF7C     BTFSS sameRow, 7, BANKED
11D08  D006     BRA 0x1D16
16:            		divisor = -divisor;
11D0A  6D7B     NEGF kc, BANKED
11D0C  1F7C     COMF sameRow, F, BANKED
11D0E  B0D8     BTFSC STATUS, 0, ACCESS
11D10  2B7C     INCF sameRow, F, BANKED
17:            		sign = 1;
11D12  0E01     MOVLW 0x1
11D14  6F7E     MOVWF c, BANKED
18:            	}
19:            	if(dividend < 0) {
11D16  AF7A     BTFSS e, 7, BANKED
11D18  D006     BRA 0x1D26
20:            		dividend = -dividend;
11D1A  6D79     NEGF multiplier, BANKED
11D1C  1F7A     COMF e, F, BANKED
11D1E  B0D8     BTFSC STATUS, 0, ACCESS
11D20  2B7A     INCF e, F, BANKED
21:            		sign ^= 1;
11D22  0E01     MOVLW 0x1
11D24  1B7E     XORWF c, F, BANKED
22:            	}
23:            	quotient = 0;
11D26  0E00     MOVLW 0x0
11D28  6F80     MOVWF kc, BANKED
11D2A  0E00     MOVLW 0x0
11D2C  6F7F     MOVWF d, BANKED
24:            	if(divisor != 0) {
11D2E  517B     MOVF kc, W, BANKED
11D30  117C     IORWF sameRow, W, BANKED
11D32  B4D8     BTFSC STATUS, 2, ACCESS
11D34  D01C     BRA 0x1D6E
25:            		counter = 1;
11D36  0E01     MOVLW 0x1
11D38  6F7D     MOVWF multiplicand, BANKED
26:            		while((divisor & 0x8000U) == 0) {
11D3A  D004     BRA 0x1D44
27:            			divisor <<= 1;
11D3C  90D8     BCF STATUS, 0, ACCESS
11D3E  377B     RLCF kc, F, BANKED
11D40  377C     RLCF sameRow, F, BANKED
28:            			counter++;
11D42  2B7D     INCF multiplicand, F, BANKED
29:            		}
11D44  AF7C     BTFSS sameRow, 7, BANKED
11D46  D7FA     BRA 0x1D3C
30:            		do {
31:            			quotient <<= 1;
11D48  90D8     BCF STATUS, 0, ACCESS
11D4A  377F     RLCF d, F, BANKED
11D4C  3780     RLCF kc, F, BANKED
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
11D4E  517B     MOVF kc, W, BANKED
11D50  5D79     SUBWF multiplier, W, BANKED
11D52  517C     MOVF sameRow, W, BANKED
11D54  597A     SUBWFB e, W, BANKED
11D56  A0D8     BTFSS STATUS, 0, ACCESS
11D58  D005     BRA 0x1D64
33:            				dividend -= divisor;
11D5A  517B     MOVF kc, W, BANKED
11D5C  5F79     SUBWF multiplier, F, BANKED
11D5E  517C     MOVF sameRow, W, BANKED
11D60  5B7A     SUBWFB e, F, BANKED
34:            				quotient |= 1;
11D62  817F     BSF d, 0, BANKED
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
11D64  90D8     BCF STATUS, 0, ACCESS
11D66  337C     RRCF sameRow, F, BANKED
11D68  337B     RRCF kc, F, BANKED
37:            		} while(--counter != 0);
11D6A  2F7D     DECFSZ multiplicand, F, BANKED
11D6C  D7ED     BRA 0x1D48
38:            	}
39:            	if(sign)
11D6E  517E     MOVF c, W, BANKED
11D70  B4D8     BTFSC STATUS, 2, ACCESS
11D72  D004     BRA 0x1D7C
40:            		quotient = -quotient;
11D74  6D7F     NEGF d, BANKED
11D76  1F80     COMF kc, F, BANKED
11D78  B0D8     BTFSC STATUS, 0, ACCESS
11D7A  2B80     INCF kc, F, BANKED
41:            	return quotient;
11D7C  C07F     MOVFF d, multiplier
11D7E  F079     NOP
11D80  C080     MOVFF kc, e
11D82  F07A     NOP
11D84  0012     RETURN 0
42:            }
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/Umul32.c  --------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
121C0  0E00     MOVLW 0x0
121C2  0100     MOVLB 0x0
121C4  6F81     MOVWF product, BANKED
121C6  0E00     MOVLW 0x0
121C8  6F82     MOVWF c, BANKED
121CA  0E00     MOVLW 0x0
121CC  6F83     MOVWF 0x83, BANKED
121CE  0E00     MOVLW 0x0
121D0  6F84     MOVWF c, BANKED
120:           	do {
121:           		if(multiplier & 1)
121D2  A179     BTFSS multiplier, 0, BANKED
121D4  D008     BRA 0x21E6
122:           			product += multiplicand;
121D6  517D     MOVF multiplicand, W, BANKED
121D8  2781     ADDWF product, F, BANKED
121DA  517E     MOVF c, W, BANKED
121DC  2382     ADDWFC c, F, BANKED
121DE  517F     MOVF d, W, BANKED
121E0  2383     ADDWFC 0x83, F, BANKED
121E2  5180     MOVF kc, W, BANKED
121E4  2384     ADDWFC c, F, BANKED
123:           		multiplicand <<= 1;
121E6  90D8     BCF STATUS, 0, ACCESS
121E8  377D     RLCF multiplicand, F, BANKED
121EA  377E     RLCF c, F, BANKED
121EC  377F     RLCF d, F, BANKED
121EE  3780     RLCF kc, F, BANKED
124:           		multiplier >>= 1;
121F0  90D8     BCF STATUS, 0, ACCESS
121F2  337C     RRCF sameRow, F, BANKED
121F4  337B     RRCF kc, F, BANKED
121F6  337A     RRCF e, F, BANKED
121F8  3379     RRCF multiplier, F, BANKED
125:           	} while(multiplier != 0);
121FA  5179     MOVF multiplier, W, BANKED
121FC  117A     IORWF e, W, BANKED
121FE  117B     IORWF kc, W, BANKED
12200  117C     IORWF sameRow, W, BANKED
12202  A4D8     BTFSS STATUS, 2, ACCESS
12204  D7E6     BRA 0x21D2
126:           
127:           #endif
128:           	return product;
12206  C081     MOVFF product, multiplier
12208  F079     NOP
1220A  C082     MOVFF c, e
1220C  F07A     NOP
1220E  C083     MOVFF 0x83, kc
12210  F07B     NOP
12212  C084     MOVFF c, sameRow
12214  F07C     NOP
129:           }
12216  0012     RETURN 0
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/Umul16.c  --------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
125F8  0100     MOVLB 0x0
125FA  5179     MOVF multiplier, W, BANKED
125FC  037B     MULWF kc, BANKED
125FE  CFF3     MOVFF PROD, multiplicand
12600  F07D     NOP
12602  CFF4     MOVFF PRODH, c
12604  F07E     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
12606  5179     MOVF multiplier, W, BANKED
12608  037C     MULWF sameRow, BANKED
1260A  50F3     MOVF PROD, W, ACCESS
1260C  277E     ADDWF c, F, BANKED
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
1260E  517A     MOVF e, W, BANKED
12610  037B     MULWF kc, BANKED
12612  50F3     MOVF PROD, W, ACCESS
12614  277E     ADDWF c, F, BANKED
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
12616  C07D     MOVFF multiplicand, multiplier
12618  F079     NOP
1261A  C07E     MOVFF c, e
1261C  F07A     NOP
1261E  0012     RETURN 0
53:            }
